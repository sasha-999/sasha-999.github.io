"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[7250],{8453:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>d});var t=r(6540);const i={},o=t.createContext(i);function s(e){const n=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),t.createElement(o.Provider,{value:n},e.children)}},9195:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>a,contentTitle:()=>d,default:()=>h,frontMatter:()=>s,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"pwn/rop-2.34+/the-problem","title":"the-problem","description":"---","source":"@site/pwn/pwn/rop-2.34+/the-problem.md","sourceDirName":"pwn/rop-2.34+","slug":"/pwn/rop-2.34+/the-problem","permalink":"/pwn/pwn/rop-2.34+/the-problem","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"ROP 2.34+","permalink":"/pwn/category/rop-234"},"next":{"title":"ret2gets","permalink":"/pwn/pwn/rop-2.34+/ret2gets"}}');var i=r(4848),o=r(8453);const s={sidebar_position:1},d=void 0,a={},c=[{value:"description: What happened to ROP?",id:"description-what-happened-to-rop",level:2},{value:"Where does <code>pop rdi ; ret</code> come from?",id:"where-does-pop-rdi--ret-come-from",level:2},{value:"Quirk of x86",id:"quirk-of-x86",level:3},{value:"Where did <code>pop rdi ; ret</code> go?",id:"where-did-pop-rdi--ret-go",level:2},{value:"Side note on <code>__libc_start_main</code>",id:"side-note-on-__libc_start_main",level:3},{value:"Sooo what now?",id:"sooo-what-now",level:2},{value:"Other sources of <code>pop rdi ; ret</code>",id:"other-sources-of-pop-rdi--ret",level:3},{value:"Summary",id:"summary",level:2}];function l(e){const n={a:"a",admonition:"admonition",code:"code",del:"del",em:"em",h1:"h1",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"description-what-happened-to-rop",children:"description: What happened to ROP?"}),"\n",(0,i.jsx)(n.h1,{id:"the-problem",children:"The problem"}),"\n",(0,i.jsx)(n.p,{children:"Ah the classic overflow challenge. By now most people are familiar with this style of exploit, where you have some buffer on the stack, and you can provide more data than what's been allocated for it, leading to a classic overflow. And because it's so well known, so are the techniques for it. Take the simple program below."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:'// gcc demo.c -o demo -no-pie -fno-stack-protector\n#include <stdio.h>\n\nint main() {\n\tchar buf[0x20];\n\tputs("ROP me if you can!");\n\tgets(buf);\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["It's obvious that we can overflow the ",(0,i.jsx)(n.code,{children:"buf"})," buffer, so from here we'd typically use the classic ret2plt attack, where we:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Use ",(0,i.jsx)(n.code,{children:"puts"})," to leak a GOT entry"]}),"\n",(0,i.jsxs)(n.li,{children:["Return to ",(0,i.jsx)(n.code,{children:"main"})]}),"\n",(0,i.jsxs)(n.li,{children:["Call ",(0,i.jsx)(n.code,{children:'system("/bin/sh")'})]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["First we're going to need to find the ",(0,i.jsx)(n.code,{children:"pop rdi ; ret"})," gadget, so let's run ",(0,i.jsx)(n.code,{children:"ROPgadget"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"$ ROPgadget --binary demo\nGadgets information\n============================================================\n0x00000000004010ab : add bh, bh ; loopne 0x401115 ; nop ; ret\n0x0000000000401037 : add byte ptr [rax], al ; add byte ptr [rax], al ; jmp 0x401020\n0x000000000040115f : add byte ptr [rax], al ; add byte ptr [rax], al ; leave ; ret\n0x0000000000401078 : add byte ptr [rax], al ; add byte ptr [rax], al ; nop dword ptr [rax] ; ret\n0x0000000000401160 : add byte ptr [rax], al ; add cl, cl ; ret\n0x000000000040111a : add byte ptr [rax], al ; add dword ptr [rbp - 0x3d], ebx ; nop ; ret\n0x0000000000401039 : add byte ptr [rax], al ; jmp 0x401020\n0x0000000000401161 : add byte ptr [rax], al ; leave ; ret\n0x000000000040107a : add byte ptr [rax], al ; nop dword ptr [rax] ; ret\n0x0000000000401034 : add byte ptr [rax], al ; push 0 ; jmp 0x401020\n0x0000000000401044 : add byte ptr [rax], al ; push 1 ; jmp 0x401020\n0x0000000000401009 : add byte ptr [rax], al ; test rax, rax ; je 0x401012 ; call rax\n0x000000000040111b : add byte ptr [rcx], al ; pop rbp ; ret\n0x0000000000401162 : add cl, cl ; ret\n0x00000000004010aa : add dil, dil ; loopne 0x401115 ; nop ; ret\n0x0000000000401047 : add dword ptr [rax], eax ; add byte ptr [rax], al ; jmp 0x401020\n0x000000000040111c : add dword ptr [rbp - 0x3d], ebx ; nop ; ret\n0x0000000000401117 : add eax, 0x2f03 ; add dword ptr [rbp - 0x3d], ebx ; nop ; ret\n0x0000000000401118 : add ebp, dword ptr [rdi] ; add byte ptr [rax], al ; add dword ptr [rbp - 0x3d], ebx ; nop ; ret\n0x0000000000401013 : add esp, 8 ; ret\n0x0000000000401012 : add rsp, 8 ; ret\n0x00000000004010a8 : and byte ptr [rax + 0x40], al ; add bh, bh ; loopne 0x401115 ; nop ; ret\n0x0000000000401010 : call rax\n0x0000000000401133 : cli ; jmp 0x4010c0\n0x0000000000401130 : endbr64 ; jmp 0x4010c0\n0x000000000040100e : je 0x401012 ; call rax\n0x00000000004010a5 : je 0x4010b0 ; mov edi, 0x404020 ; jmp rax\n0x00000000004010e7 : je 0x4010f0 ; mov edi, 0x404020 ; jmp rax\n0x000000000040103b : jmp 0x401020\n0x0000000000401134 : jmp 0x4010c0\n0x00000000004010ac : jmp rax\n0x0000000000401163 : leave ; ret\n0x00000000004010ad : loopne 0x401115 ; nop ; ret\n0x0000000000401116 : mov byte ptr [rip + 0x2f03], 1 ; pop rbp ; ret\n0x000000000040115e : mov eax, 0 ; leave ; ret\n0x00000000004010a7 : mov edi, 0x404020 ; jmp rax\n0x00000000004010af : nop ; ret\n0x000000000040112c : nop dword ptr [rax] ; endbr64 ; jmp 0x4010c0\n0x000000000040107c : nop dword ptr [rax] ; ret\n0x00000000004010a6 : or dword ptr [rdi + 0x404020], edi ; jmp rax\n0x000000000040111d : pop rbp ; ret\n0x0000000000401036 : push 0 ; jmp 0x401020\n0x0000000000401046 : push 1 ; jmp 0x401020\n0x0000000000401016 : ret\n0x0000000000401042 : ret 0x2f\n0x0000000000401022 : retf 0x2f\n0x000000000040100d : sal byte ptr [rdx + rax - 1], 0xd0 ; add rsp, 8 ; ret\n0x0000000000401169 : sub esp, 8 ; add rsp, 8 ; ret\n0x0000000000401168 : sub rsp, 8 ; add rsp, 8 ; ret\n0x000000000040100c : test eax, eax ; je 0x401012 ; call rax\n0x00000000004010a3 : test eax, eax ; je 0x4010b0 ; mov edi, 0x404020 ; jmp rax\n0x00000000004010e5 : test eax, eax ; je 0x4010f0 ; mov edi, 0x404020 ; jmp rax\n0x000000000040100b : test rax, rax ; je 0x401012 ; call rax\n\nUnique gadgets found: 53\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Wait a second. Where's ",(0,i.jsx)(n.code,{children:"pop rdi ; ret"}),"? It should be here somewhere right??? Well actually a lot of gadgets here are missing such as:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"pop rdi ; ret"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"pop rsi ; pop r15 ; ret"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret"})}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"So what's going on? Let's investigate, shall we?"}),"\n",(0,i.jsxs)(n.h2,{id:"where-does-pop-rdi--ret-come-from",children:["Where does ",(0,i.jsx)(n.code,{children:"pop rdi ; ret"})," come from?"]}),"\n",(0,i.jsxs)(n.p,{children:["Where did it come from, and where did it go? ",(0,i.jsx)(n.del,{children:"Where did it come from cotton eye joe?"})]}),"\n",(0,i.jsxs)(n.p,{children:["To find this out, let's take a binary which has this gadget (which hasn't been stripped). There's plenty to choose from from countless CTFs, so I chose hackthebox's ",(0,i.jsx)(n.code,{children:"ropme"}),". Running ",(0,i.jsx)(n.code,{children:"ROPgadget"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"ROPgadget --binary ropme\nGadgets information\n============================================================\n...\n0x00000000004006d3 : pop rdi ; ret\n...\n"})}),"\n",(0,i.jsx)(n.p,{children:"Let's see where this lies in the binary."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"pwndbg> x/2i 0x00000000004006d3\n   0x4006d3 <__libc_csu_init+99>:\tpop    rdi\n   0x4006d4 <__libc_csu_init+100>:\tret\n"})}),"\n",(0,i.jsxs)(n.p,{children:["So it seems our beloved gadget belongs to a function called ",(0,i.jsx)(n.code,{children:"__libc_csu_init"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"pwndbg> disassemble __libc_csu_init\nDump of assembler code for function __libc_csu_init:\n   0x0000000000400670 <+0>:\tpush   r15\n   0x0000000000400672 <+2>:\tpush   r14\n   0x0000000000400674 <+4>:\tmov    r15d,edi\n   0x0000000000400677 <+7>:\tpush   r13\n   0x0000000000400679 <+9>:\tpush   r12\n   0x000000000040067b <+11>:\tlea    r12,[rip+0x20078e]        # 0x600e10\n   0x0000000000400682 <+18>:\tpush   rbp\n   0x0000000000400683 <+19>:\tlea    rbp,[rip+0x20078e]        # 0x600e18\n   0x000000000040068a <+26>:\tpush   rbx\n   0x000000000040068b <+27>:\tmov    r14,rsi\n   0x000000000040068e <+30>:\tmov    r13,rdx\n   0x0000000000400691 <+33>:\tsub    rbp,r12\n   0x0000000000400694 <+36>:\tsub    rsp,0x8\n   0x0000000000400698 <+40>:\tsar    rbp,0x3\n   0x000000000040069c <+44>:\tcall   0x4004b0 <_init>\n   0x00000000004006a1 <+49>:\ttest   rbp,rbp\n   0x00000000004006a4 <+52>:\tje     0x4006c6 <__libc_csu_init+86>\n   0x00000000004006a6 <+54>:\txor    ebx,ebx\n   0x00000000004006a8 <+56>:\tnop    DWORD PTR [rax+rax*1+0x0]\n   0x00000000004006b0 <+64>:\tmov    rdx,r13\n   0x00000000004006b3 <+67>:\tmov    rsi,r14\n   0x00000000004006b6 <+70>:\tmov    edi,r15d\n   0x00000000004006b9 <+73>:\tcall   QWORD PTR [r12+rbx*8]\n   0x00000000004006bd <+77>:\tadd    rbx,0x1\n   0x00000000004006c1 <+81>:\tcmp    rbx,rbp\n   0x00000000004006c4 <+84>:\tjne    0x4006b0 <__libc_csu_init+64>\n   0x00000000004006c6 <+86>:\tadd    rsp,0x8\n   0x00000000004006ca <+90>:\tpop    rbx\n   0x00000000004006cb <+91>:\tpop    rbp\n   0x00000000004006cc <+92>:\tpop    r12\n   0x00000000004006ce <+94>:\tpop    r13\n   0x00000000004006d0 <+96>:\tpop    r14\n   0x00000000004006d2 <+98>:\tpop    r15\n   0x00000000004006d4 <+100>:\tret\nEnd of assembler dump.\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Interestingly the function's disassembly doesn't seem to contain ",(0,i.jsx)(n.code,{children:"pop rdi ; ret"}),"? That's because ",(0,i.jsx)(n.code,{children:"pop rdi ; ret"})," doesn't show up in regular code, but rather comes from splitting an instruction in half, specifically ",(0,i.jsx)(n.code,{children:"pop r15"}),". You may have noticed that we have ",(0,i.jsx)(n.code,{children:"__libc_csu_init+98"})," and ",(0,i.jsx)(n.code,{children:"__libc_csu_init+100"})," in the disassembly, but ",(0,i.jsx)(n.code,{children:"pop rdi ; ret"})," is at ",(0,i.jsx)(n.code,{children:"__libc_csu_init+99"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"quirk-of-x86",children:"Quirk of x86"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"pop r15 ; ret = 41 5f c3\n                   ~~~~~\n\npop rdi ; ret = 5f c3\n                ~~~~~\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The above is how these instructions get assembled. You can notice that ",(0,i.jsx)(n.code,{children:"pop r15 ; ret"})," is longer, but the last 2 bytes are the same as ",(0,i.jsx)(n.code,{children:"pop rdi ; ret"})," (for some reason). Due to how x86 instructions aren't fixed-length like ARM, we can execute an instruction from any point. So, we could take the address of ",(0,i.jsx)(n.code,{children:"pop r15 ; ret"}),", increment it by 1, and get ",(0,i.jsx)(n.code,{children:"pop rdi ; ret"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"pwndbg> x/2i 0x00000000004006d2\n   0x4006d2 <__libc_csu_init+98>:\tpop    r15\n   0x4006d4 <__libc_csu_init+100>:\tret\npwndbg> x/2i 0x00000000004006d2+1\n   0x4006d3 <__libc_csu_init+99>:\tpop    rdi\n   0x4006d4 <__libc_csu_init+100>:\tret\n"})}),"\n",(0,i.jsxs)(n.p,{children:["So wherever there is a ",(0,i.jsx)(n.code,{children:"pop r15"}),", there will also be ",(0,i.jsx)(n.code,{children:"pop rdi"}),". And since ",(0,i.jsx)(n.code,{children:"__libc_csu_init"})," will always contain ",(0,i.jsx)(n.code,{children:"pop r15 ; ret"}),", binaries with ",(0,i.jsx)(n.code,{children:"__libc_csu_init"})," will have ",(0,i.jsx)(n.code,{children:"pop rdi ; ret"}),"!"]}),"\n",(0,i.jsxs)(n.h2,{id:"where-did-pop-rdi--ret-go",children:["Where did ",(0,i.jsx)(n.code,{children:"pop rdi ; ret"})," go?"]}),"\n",(0,i.jsxs)(n.p,{children:["So if any binary containing ",(0,i.jsx)(n.code,{children:"__libc_csu_init"})," has the ",(0,i.jsx)(n.code,{children:"pop rdi"})," gadget, what's happening in the demo binary?"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"pwndbg> info functions\nAll defined functions:\n\nNon-debugging symbols:\n0x0000000000401000  _init\n0x0000000000401030  puts@plt\n0x0000000000401040  gets@plt\n0x0000000000401050  _start\n0x0000000000401080  _dl_relocate_static_pie\n0x0000000000401090  deregister_tm_clones\n0x00000000004010c0  register_tm_clones\n0x0000000000401100  __do_global_dtors_aux\n0x0000000000401130  frame_dummy\n0x0000000000401136  main\n0x0000000000401168  _fini\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Aha! In the demo binary, ",(0,i.jsx)(n.code,{children:"__libc_csu_init"})," is ",(0,i.jsx)(n.strong,{children:"not"})," present! But why is that?"]}),"\n",(0,i.jsxs)(n.p,{children:["Well recently in glibc 2.34, there was a ",(0,i.jsx)(n.a,{href:"https://sourceware.org/pipermail/libc-alpha/2021-February/122794.html",children:"patch"})," which stopped ",(0,i.jsx)(n.code,{children:"__libc_csu_init"})," being compiled into binaries. The patch was designed to remove useful ROP gadgets for ",(0,i.jsx)(n.code,{children:"ret2csu"}),", and has the effect of removing ",(0,i.jsx)(n.code,{children:"pop rdi ; ret"})," in binaries compiled against glibc 2.34+."]}),"\n",(0,i.jsxs)(n.h3,{id:"side-note-on-__libc_start_main",children:["Side note on ",(0,i.jsx)(n.code,{children:"__libc_start_main"})]}),"\n",(0,i.jsxs)(n.p,{children:["This would change a few things, such as ",(0,i.jsx)(n.code,{children:"__libc_start_main"}),", which took ",(0,i.jsx)(n.code,{children:"__libc_csu_init"})," as an argument, expecting it to be run. Now that it doesn't exist, it still takes the argument, but does nothing with it, so it had be versioned off for 2.34, as it now had different behaviour. This meant that you couldn't run binaries compiled for 2.34+ on older glibc versions, otherwise you'd get the very annoying error:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"/lib/x86_64-linux-gnu/libc.so.6: version `GLIBC_2.34' not found\n"})}),"\n",(0,i.jsx)(n.p,{children:"So you have this patch to thank for this :)"}),"\n",(0,i.jsx)(n.h2,{id:"sooo-what-now",children:"Sooo what now?"}),"\n",(0,i.jsx)(n.p,{children:"So has this completely killed ROP on modern binaries? Has our time spent practising and mastering the art of ROP all been for nothing, and we'll have to move on to other types of exploits entirely?"}),"\n",(0,i.jsx)(n.p,{children:"Woah slow down, I want to argue that it hasn't. While it has thrown a wrench in how we do ROP, there are still tricks we can do to get around this, which I will showcase in the following sections."}),"\n",(0,i.jsxs)(n.h3,{id:"other-sources-of-pop-rdi--ret",children:["Other sources of ",(0,i.jsx)(n.code,{children:"pop rdi ; ret"})]}),"\n",(0,i.jsxs)(n.p,{children:["For one thing, ",(0,i.jsx)(n.code,{children:"__libc_csu_init"})," isn't our only source of ",(0,i.jsx)(n.code,{children:"pop rdi ; ret"}),". Recall that wherever there's ",(0,i.jsx)(n.code,{children:"pop r15 ; ret"})," there is ",(0,i.jsx)(n.code,{children:"pop rdi ; ret"}),". But why does ",(0,i.jsx)(n.code,{children:"pop r15 ; ret"})," show up in ",(0,i.jsx)(n.code,{children:"__libc_csu_init"}),"?"]}),"\n",(0,i.jsxs)(n.p,{children:["Well normally when we compile, the variables in a function are stored on the stack. But, if we compile using optimization flags (or use ",(0,i.jsx)(n.code,{children:"register"})," when defining a variable), some variables can be stored in registers instead. The registers typically used include ",(0,i.jsx)(n.code,{children:"rbp"}),", ",(0,i.jsx)(n.code,{children:"r12"}),", ",(0,i.jsx)(n.code,{children:"r13"}),", ",(0,i.jsx)(n.code,{children:"r14"}),", ",(0,i.jsx)(n.code,{children:"r15"}),", ",(0,i.jsx)(n.code,{children:"rbx"}),". For this to work, a function using these registers must push the old values of these registers before using them, and then restore them when returning. This is because other functions may also be using these registers, and so this function could clobber those registers for the other function(s). So, this involves pushing these to the stack at the start, then popping them at the end. If you look back at ",(0,i.jsx)(n.code,{children:"__libc_csu_init"}),"'s disassembly above, it follows this same pattern, because it's compiled with optimization."]}),"\n",(0,i.jsxs)(n.p,{children:["This means that if your binary is compiled for optimization, there is a chance ",(0,i.jsx)(n.code,{children:"r15"})," is used for a variable, meaning it must also be pushed, and more importantly ",(0,i.jsx)(n.em,{children:"popped"}),", which would result in ",(0,i.jsx)(n.code,{children:"pop r15"})," -> ",(0,i.jsx)(n.code,{children:"pop rdi"}),"."]}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsxs)(n.p,{children:["Unfortunately, from my testing, ",(0,i.jsx)(n.code,{children:"r15"})," seems to be one of the last ones that gets used, so a function would likely need many register variables for ",(0,i.jsx)(n.code,{children:"r15"})," to be used."]})}),"\n",(0,i.jsxs)(n.p,{children:["This is why glibc will always contain  ",(0,i.jsx)(n.code,{children:"pop rdi"}),", because it's compiled for optimization, and there so many functions with lots of variables stored in registers, so it's basically guaranteed that ",(0,i.jsx)(n.code,{children:"r15"})," is used in at least one of them."]}),"\n",(0,i.jsxs)(n.p,{children:["This means that once you have a libc leak, you'll always be able to find a ",(0,i.jsx)(n.code,{children:"pop rdi ; ret"})," gadget. However if all you have is an overflow, and no leak, then this will still cause problems."]}),"\n",(0,i.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsxs)(n.p,{children:["So if your binary doesn't have ",(0,i.jsx)(n.code,{children:"pop rdi ; ret"}),", then you have a few approaches:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Get a libc leak using a different bug"}),"\n",(0,i.jsxs)(n.li,{children:["Controlling ",(0,i.jsx)(n.code,{children:"rdi"})," some other way"]}),"\n",(0,i.jsx)(n.li,{children:"Use overflow to leak libc"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"In the following sections, I'll show some tricks you can use to do the latter 2 approaches :)"})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}}}]);