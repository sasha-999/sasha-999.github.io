"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[5509],{8453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>a});var s=r(6540);const t={},i=s.createContext(t);function o(e){const n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),s.createElement(i.Provider,{value:n},e.children)}},9198:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"pwn/rop-2.34+/controlling-rbp","title":"Controlling rbp","description":"A method of arbitrary writing","source":"@site/pwn/pwn/rop-2.34+/controlling-rbp.md","sourceDirName":"pwn/rop-2.34+","slug":"/pwn/rop-2.34+/controlling-rbp","permalink":"/pwn/pwn/rop-2.34+/controlling-rbp","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"description":"A method of arbitrary writing","sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"ret2gets","permalink":"/pwn/pwn/rop-2.34+/ret2gets"},"next":{"title":"Controlling rax","permalink":"/pwn/pwn/rop-2.34+/controlling-rax"}}');var t=r(4848),i=r(8453);const o={description:"A method of arbitrary writing",sidebar_position:3},a="Controlling rbp",c={},d=[{value:"What is the saved base pointer?",id:"what-is-the-saved-base-pointer",level:3},{value:"Arbitrary write",id:"arbitrary-write",level:3},{value:"Overwriting <code>GOT</code>",id:"overwriting-got",level:3},{value:"Other targets",id:"other-targets",level:3}];function l(e){const n={a:"a",admonition:"admonition",br:"br",code:"code",em:"em",h1:"h1",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"controlling-rbp",children:"Controlling rbp"})}),"\n",(0,t.jsx)(n.p,{children:"Once again, let's go back to the demo program."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:'// gcc demo.c -o demo -no-pie -fno-stack-protector\n#include <stdio.h>\n\nint main() {\n\tchar buf[0x20];\n\tputs("ROP me if you can!");\n\tgets(buf);\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["The main idea we'd have when overflowing this to just control the return address to get RCE. And in most cases that's sufficient, however with the lack of ",(0,t.jsx)(n.code,{children:"pop rdi ; ret"}),", we're forced to look for alternatives."]}),"\n",(0,t.jsx)(n.p,{children:"There's another value that's overwritten when we overflow, and that is the saved base pointer. While not as exciting as the return address, it can also be very useful."}),"\n",(0,t.jsx)(n.h3,{id:"what-is-the-saved-base-pointer",children:"What is the saved base pointer?"}),"\n",(0,t.jsxs)(n.p,{children:["In our case, the stack is managed using 2 registers: ",(0,t.jsx)(n.code,{children:"rsp"})," and ",(0,t.jsx)(n.code,{children:"rbp"}),"."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"rsp"})," is the stack pointer, and is used when popping and pushing values."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"rbp"})," is the base pointer, and is used to determine where the variables on the stack are located."]}),"\n"]}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.p,{children:["Sometimes In optimized code, only ",(0,t.jsx)(n.code,{children:"rsp"})," is needed, and ",(0,t.jsx)(n.code,{children:"rbp"})," is instead used as a scratch variable. This is common to see in glibc code. However, this isn't relevant here."]})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"rsp"})," will typically point to the bottom of the stack (address-wise), and ",(0,t.jsx)(n.code,{children:"rbp"})," to the top of the current stack frame."]}),"\n",(0,t.jsxs)("figure",{children:[(0,t.jsx)("img",{src:"/assets/image (128).png",alt:""}),(0,t.jsx)("figcaption",{children:(0,t.jsxs)("p",{children:["Disassembly of ",(0,t.jsx)("code",{children:"main"})]})})]}),"\n",(0,t.jsxs)(n.p,{children:["When ",(0,t.jsx)(n.code,{children:"main"})," is called:"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"call main"})," will push ",(0,t.jsx)(n.code,{children:"rip"})," (the address of the instruction after ",(0,t.jsx)(n.code,{children:"call"}),"), which is the return address.",(0,t.jsx)(n.br,{}),"\n","Then it jumps to the function."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"push rbp"})," will push the previous value of ",(0,t.jsx)(n.code,{children:"rbp"})," to the stack. This becomes the saved base pointer."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"mov rbp, rsp"})," makes ",(0,t.jsx)(n.code,{children:"rbp"}),' now point to the recently pushed "saved base pointer". This is important to recognise, that ',(0,t.jsx)(n.code,{children:"rbp"})," points to the saved base pointer of the ",(0,t.jsx)(n.em,{children:"previous function."})]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"sub rsp, 0x20"})," allocates the space for the variables (the space used for variables is between ",(0,t.jsx)(n.code,{children:"rsp"})," and ",(0,t.jsx)(n.code,{children:"rbp"}),")"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"The code of the function"}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"leave"})," will restore the previous values of ",(0,t.jsx)(n.code,{children:"rbp"})," and ",(0,t.jsx)(n.code,{children:"rsp"})," before ",(0,t.jsx)(n.code,{children:"push rbp"})," (i.e. at the very start of the function). It does this by effectively doing"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-nasm",children:"mov rsp, rbp\npop rbp\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"ret"})," now jumps back to the previous function, with ",(0,t.jsx)(n.code,{children:"rsp"})," and ",(0,t.jsx)(n.code,{children:"rbp"})," back to their original values."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["And we also see that when ",(0,t.jsx)(n.code,{children:"gets"})," is called, the argument is loaded using ",(0,t.jsx)(n.code,{children:"lea rax, [rbp-0x20]"}),", showing that the ",(0,t.jsx)(n.code,{children:"buf"})," buffer is relative to ",(0,t.jsx)(n.code,{children:"rbp"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"arbitrary-write",children:"Arbitrary write"}),"\n",(0,t.jsxs)(n.p,{children:["However, in the process above, when we overflow, things start going wrong. The obvious one is changing the return address to jump somewhere else, but right before the return address, is the saved base pointer. When we overwrite that, we end up controlling the value of ",(0,t.jsx)(n.code,{children:"rbp"})," when we return."]}),"\n",(0,t.jsxs)(n.p,{children:["Combining this with the fact that we have a gadget that does ",(0,t.jsx)(n.code,{children:"gets(rbp-0x20)"}),", we can return back to this with a controlled value of ",(0,t.jsx)(n.code,{children:"rbp"}),", and get an arbitrary write!"]}),"\n",(0,t.jsxs)(n.h3,{id:"overwriting-got",children:["Overwriting ",(0,t.jsx)(n.code,{children:"GOT"})]}),"\n",(0,t.jsxs)(n.p,{children:["The scope of this write is limited when we don't have any leaks, but one example of a useful target is ",(0,t.jsx)(n.code,{children:"GOT"}),". In fact, I wrote a challenge for ",(0,t.jsx)(n.a,{href:"https://www.hackthebox.com/events/htb-business-ctf-2024",children:"HTB Business CTF 2024"})," which used this exact technique, and if you want to see an example of how you could use this, check out ",(0,t.jsx)(n.a,{href:"../../ctf-writeups/htb-business-2024/no-gadgets",children:"my writeup"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"other-targets",children:"Other targets"}),"\n",(0,t.jsxs)(n.p,{children:["Overwriting ",(0,t.jsx)(n.code,{children:"GOT"})," can be useful in some cases, but what about if there are no good targets in ",(0,t.jsx)(n.code,{children:"GOT"}),", or ",(0,t.jsx)(n.code,{children:"FULL RELRO"})," is enabled?"]}),"\n",(0,t.jsx)(n.p,{children:"Aside from that, your targets for a write could be global variables used by the program for example."}),"\n",(0,t.jsxs)(n.p,{children:["Another idea is to create fake objects in a known location, which can be useful for certain things, such as ",(0,t.jsx)(n.code,{children:"ret2dlresolve"})," (covered ",(0,t.jsx)(n.a,{href:"dlrop",children:"here"}),")."]}),"\n",(0,t.jsxs)(n.p,{children:["Another idea is to forge a fake stack frame, and to return to a certain section of a function. Since all variables are relative to ",(0,t.jsx)(n.code,{children:"rbp"}),", by pointing ",(0,t.jsx)(n.code,{children:"rbp"}),' to a controlled buffer, you could "set" certain variables to controlled values, such as pointers to buffers, size variables, and so on.']}),"\n",(0,t.jsxs)(n.p,{children:["Unfortunately both of these are dependent on what the binary does, so there aren't many universal approaches for when ",(0,t.jsx)(n.code,{children:"FULL RELRO"})," is enabled, but this can still remain to be a useful trick which may aid exploitation in some cases."]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}}}]);